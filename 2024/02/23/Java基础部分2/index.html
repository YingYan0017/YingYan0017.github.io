<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java 基础知识一、 package 和 importpackage其实包就是把很多很多的代码进行整理，便于代码的统一管理。 ①怎么定义包：在java源码第一行编写 package 语句。注意：package语句只能出现在java代码第一行。 ②包名命名规范中要求是全部小写。 ③包名命名规范：公司域名倒序 + 项目名 + 模块名 + 功能名。例如： ①com.powernode.oa.empgt">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础部分2">
<meta property="og:url" content="http://example.com/2024/02/23/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/index.html">
<meta property="og:site_name" content="Loloooo">
<meta property="og:description" content="Java 基础知识一、 package 和 importpackage其实包就是把很多很多的代码进行整理，便于代码的统一管理。 ①怎么定义包：在java源码第一行编写 package 语句。注意：package语句只能出现在java代码第一行。 ②包名命名规范中要求是全部小写。 ③包名命名规范：公司域名倒序 + 项目名 + 模块名 + 功能名。例如： ①com.powernode.oa.empgt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223194626584.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223194657595.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223195906110.png">
<meta property="og:image" content="http://example.com/2024/02/23/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223202022775.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223202252613.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225145941617.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225150328362.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225151158129.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225154836218.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225194625857.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225194714666.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225195106209.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225195527691.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225212935175.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225213020734.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225213131315.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225214223891.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225214331825.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225220833968.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225221336300.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225225653075.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225224843910.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225224915679.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225225250788.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225231010553.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225231835927.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226111210195.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226112229142.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226150228776.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226161310540.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226162231265.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226162707551.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226173319940.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226173405538.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226173521101.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226174835150.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175009462.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175047202.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175206352.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175919594.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226180456350.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226181415375.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226181815569.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226182500898.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226182936458.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226184438712.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226184739067.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/v2-cb4cb526cc8a637848ad2ad176d50d40_720w.webp">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226185936183.png">
<meta property="article:published_time" content="2024-02-23T11:30:38.000Z">
<meta property="article:modified_time" content="2024-03-05T06:41:04.219Z">
<meta property="article:author" content="lolo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223194626584.png">


<link rel="canonical" href="http://example.com/2024/02/23/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/02/23/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/","path":"2024/02/23/Java基础部分2/","title":"Java基础部分2"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java基础部分2 | Loloooo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Loloooo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">Java 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81-package-%E5%92%8C-import"><span class="nav-number">1.1.</span> <span class="nav-text">一、 package 和 import</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#package"><span class="nav-number">1.1.1.</span> <span class="nav-text">package</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#import"><span class="nav-number">1.1.2.</span> <span class="nav-text">import</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.</span> <span class="nav-text">二、面向对象概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 面向对象三大特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.对象的创建与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">①对象的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">②对象的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">③通过一个类可以实例化多个对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3-public-static-void-functionA%EF%BC%88%EF%BC%89%EF%BC%8C%E7%9B%B4%E6%8E%A5%E7%94%A8%E7%B1%BB%E5%90%8D-functionA-%E6%9D%A5%E8%AE%BF%E9%97%AE"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">④ public static   void functionA（），直接用类名.functionA()来访问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="nav-number">1.2.3.</span> <span class="nav-text">3.JVM内存结构图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E6%97%A6%E5%BC%95%E7%94%A8%E4%B8%BANULL%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%BC%95%E7%94%A8%E4%B8%8D%E5%86%8D%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BA%86"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">&#x3D;&#x3D;一旦引用为NULL，表示引用不再指向对象了&#x3D;&#x3D;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%B0%81%E8%A3%85"><span class="nav-number">1.2.4.</span> <span class="nav-text">4.封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E8%A3%85%EF%BC%9F"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">什么是封装？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">封装的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">在代码上如何实现封装</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%B1%9E%E6%80%A7%E7%A7%81%E6%9C%89%E5%8C%96%EF%BC%8C%E5%AF%B9%E5%A4%96%E6%8F%90%E4%BE%9Bgetter%E5%92%8Csetter%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-number">1.2.4.3.1.</span> <span class="nav-text">1. 属性私有化，对外提供getter和setter方法。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%B8%BA%E4%BA%86%E4%BF%9D%E8%AF%81%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F%E4%BB%A5%E7%84%B6%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEage%E5%B1%9E%E6%80%A7%EF%BC%8C%E8%BF%98%E6%98%AF%E9%9C%80%E8%A6%81%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E5%85%AC%E5%BC%80%E7%9A%84%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E7%9A%84%E5%85%A5%E5%8F%A3%E3%80%82"><span class="nav-number">1.2.4.3.2.</span> <span class="nav-text">2. 为了保证外部程序以然可以访问age属性，还是需要提供一个公开的外部访问的入口。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89constructor"><span class="nav-number">1.2.5.</span> <span class="nav-text">5.  构造方法（构造器）constructor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">构造方法的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">构造方法怎么定义？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%90%8D%E4%B8%80%E5%AE%9A%E8%A6%81%E5%92%8C%E7%B1%BB%E5%90%8D%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%EF%BC%81"><span class="nav-number">1.2.5.2.1.</span> <span class="nav-text">构造方法名一定要和类名保持一致！</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">缺省构造器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.6.</span> <span class="nav-text">6. this关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.7.</span> <span class="nav-text">7.static关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">静态变量内存图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">空指针异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">静态代码块</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.7.3.1.</span> <span class="nav-text">语法结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-JVMjava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.8.</span> <span class="nav-text">8.JVMjava虚拟机的体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.9.</span> <span class="nav-text">9、设计模式概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.10.</span> <span class="nav-text">10.继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96"><span class="nav-number">1.2.11.</span> <span class="nav-text">11.方法覆盖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%EF%BC%9F"><span class="nav-number">1.2.11.1.</span> <span class="nav-text">①什么情况下考虑使用方法覆盖？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%8F%91%E7%94%9F%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%9F"><span class="nav-number">1.2.11.2.</span> <span class="nav-text">②发生方法覆盖的条件？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82%EF%BC%9A"><span class="nav-number">1.2.11.3.</span> <span class="nav-text">③方法覆盖的小细节：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%A4%9A%E6%80%81"><span class="nav-number">1.2.12.</span> <span class="nav-text">12.多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9F"><span class="nav-number">1.2.12.1.</span> <span class="nav-text">①什么是向上转型和向下转型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="nav-number">1.2.12.2.</span> <span class="nav-text">②什么是多态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2-instanceof%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.12.3.</span> <span class="nav-text">③ instanceof运算符可以解决类型转换问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="nav-number">1.2.12.4.</span> <span class="nav-text">④ 软件开发七大原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4-%E5%A4%9A%E6%80%81%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.12.5.</span> <span class="nav-text">⑤ 多态在开发中的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A5%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">1.2.12.6.</span> <span class="nav-text">⑥多态的基础语法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.2.13.</span> <span class="nav-text">13 . 抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%80%83%E8%99%91%E5%B0%86%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9F"><span class="nav-number">1.2.13.1.</span> <span class="nav-text">①什么时候考虑将类定义为抽象类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="nav-number">1.2.13.2.</span> <span class="nav-text">②抽象类如何定义？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%86%E6%97%A0%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%82%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%98%AF%E7%BB%99%E5%AD%90%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%9A%84%E3%80%82"><span class="nav-number">1.2.13.3.</span> <span class="nav-text">③抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="nav-number">1.2.13.4.</span> <span class="nav-text">④抽象方法如何定义？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%86%E5%A6%82%E6%9E%9C%E6%9C%89%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E9%82%A3%E4%B9%88%E7%B1%BB%E8%A6%81%E6%B1%82%E5%BF%85%E9%A1%BB%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%82"><span class="nav-number">1.2.13.5.</span> <span class="nav-text">⑤抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A5%E4%B8%80%E4%B8%AA%E9%9D%9E%E6%8A%BD%E8%B1%A1%E7%9A%84%E7%B1%BB%E7%BB%A7%E6%89%BFextend%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E8%A6%81%E6%B1%82%E5%BF%85%E9%A1%BB%E5%B0%86%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%AE%9E%E7%8E%B0-%E9%87%8D%E5%86%99%E3%80%82"><span class="nav-number">1.2.13.6.</span> <span class="nav-text">&#x3D;&#x3D;⑥一个非抽象的类继承extend抽象类，要求必须将抽象方法进行实现&#x2F;重写。&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A6abstract%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8D%E8%83%BD%E5%92%8Cprivate%EF%BC%8Cfinal%EF%BC%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97%E5%85%B1%E5%AD%98%E3%80%82"><span class="nav-number">1.2.13.7.</span> <span class="nav-text">⑦abstract关键字不能和private，final，static关键字共存。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A7%E6%8A%BD%E8%B1%A1%E7%B1%BB%E9%9C%80%E8%A6%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E4%BD%86%E6%98%AF%E6%97%A0%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%AE%9E%E4%BE%8B%E5%8C%96-%E8%BF%99%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%98%AF%E7%BB%99%E5%85%B6%E5%AD%90%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%9A%84"><span class="nav-number">1.2.13.8.</span> <span class="nav-text">⑧抽象类需要构造方法,但是无法实现实例化,这个构造方法是给其子类使用的.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.14.</span> <span class="nav-text">14. super关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.15.</span> <span class="nav-text">15.final关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.16.</span> <span class="nav-text">16.接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">1.2.16.1.</span> <span class="nav-text">接口的基础语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.16.2.</span> <span class="nav-text">接口的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="nav-number">1.2.16.3.</span> <span class="nav-text">接口与抽象类如何选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-UML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.17.</span> <span class="nav-text">17. UML(统一建模语言概述)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%80%83%E8%99%91%E4%B8%80%E4%B8%8B%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.17.1.</span> <span class="nav-text">考虑一下类之间的关系.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.17.2.</span> <span class="nav-text">类之间的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90"><span class="nav-number">1.2.18.</span> <span class="nav-text">&#x3D;&#x3D;18. 访问控制权限&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-Object%E7%B1%BB"><span class="nav-number">1.2.19.</span> <span class="nav-text">19.Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0java-lang-Object%E6%98%AF%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB%E3%80%82java%E4%B8%AD%E6%89%80%E6%9C%89%E7%B1%BB%E9%83%BD%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%BF%99%E4%B8%AA%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-number">1.2.19.1.</span> <span class="nav-text">①java.lang.Object是所有类的超类。java中所有类都实现了这个类中的方法。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1Object%E7%B1%BB%E6%98%AF%E6%88%91%E4%BB%AC%E5%AD%A6%E4%B9%A0JDK%E7%B1%BB%E5%BA%93%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%B1%BB%E3%80%82%E9%80%9A%E8%BF%87%E8%BF%99%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0%E8%A6%81%E6%B1%82%E6%8E%8C%E6%8F%A1%E4%BC%9A%E6%9F%A5%E9%98%85API%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E3%80%82"><span class="nav-number">1.2.19.2.</span> <span class="nav-text">②Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E7%8E%B0%E9%98%B6%E6%AE%B5Object%E7%B1%BB%E4%B8%AD%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">1.2.19.3.</span> <span class="nav-text">③现阶段Object类中需要掌握的方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E7%8E%B0%E9%98%B6%E6%AE%B5Object%E7%B1%BB%E4%B8%AD%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">1.2.19.4.</span> <span class="nav-text">④现阶段Object类中需要了解的方法：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#clone%EF%BC%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%B7%E8%B4%9D%E3%80%82%EF%BC%88%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%89"><span class="nav-number">1.2.19.4.1.</span> <span class="nav-text">&#x3D;&#x3D;clone：对象的拷贝。（浅拷贝，深拷贝）&#x3D;&#x3D;</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.2.19.4.1.1.</span> <span class="nav-text">浅拷贝:</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.2.19.4.1.2.</span> <span class="nav-text">深拷贝:</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-clone"><span class="nav-number">1.2.20.</span> <span class="nav-text">20.clone</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC"><span class="nav-number">1.2.20.0.1.</span> <span class="nav-text">直接赋值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D-1"><span class="nav-number">1.2.20.0.2.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-1"><span class="nav-number">1.2.20.0.3.</span> <span class="nav-text">深拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.2.21.</span> <span class="nav-text">21.内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.2.21.1.</span> <span class="nav-text">静态内部类:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.2.21.2.</span> <span class="nav-text">实例内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.2.21.3.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">1.2.21.4.</span> <span class="nav-text">&#x3D;&#x3D;匿名内部类&#x3D;&#x3D;</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lolo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/23/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java基础部分2 | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础部分2
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-23 19:30:38" itemprop="dateCreated datePublished" datetime="2024-02-23T19:30:38+08:00">2024-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-05 14:41:04" itemprop="dateModified" datetime="2024-03-05T14:41:04+08:00">2024-03-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java体系知识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Java-基础知识"><a href="#Java-基础知识" class="headerlink" title="Java 基础知识"></a>Java 基础知识</h1><h2 id="一、-package-和-import"><a href="#一、-package-和-import" class="headerlink" title="一、 package 和 import"></a>一、 package 和 import</h2><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>其实包就是把很多很多的代码进行整理，便于代码的统一管理。</p>
<p>①怎么定义包：在java源码第一行编写 package 语句。注意：package语句只能出现在java代码第一行。</p>
<p>②包名命名规范中要求是全部小写。</p>
<p>③包名命名规范：公司域名倒序 + 项目名 + 模块名 + 功能名。例如：</p>
<p>①com.powernode.oa.empgt.service</p>
<p>④如果带包编译：</p>
<p>①javac -d 编译后的存放目录 java源文件路径</p>
<p>⑥有了包机制后，完整类名是包含包名的，例如类名是：com.powernode.javase.chapter02.PackageTest</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a><strong>import</strong></h3><p>①import语句用来引入其他类。</p>
<p>②A类中使用B类，A类和B类不在同一个包下时，就需要在A类中使用import引入B类。</p>
<p>③java.lang包下的不需要手动引入。</p>
<p>④import语句只能出现在package语句之下，class定义之前。</p>
<p>⑤import语句可以编写多个。</p>
<p>⑥import语句可以模糊导入：java.util.*;</p>
<p>⑦import静态导入：import static java.lang.System.*;</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223194626584.png" alt="image-20240223194626584"><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223194657595.png" alt="image-20240223194657595"></p>
<h2 id="二、面向对象概述"><a href="#二、面向对象概述" class="headerlink" title="二、面向对象概述"></a>二、面向对象概述</h2><h3 id="1-面向对象三大特征"><a href="#1-面向对象三大特征" class="headerlink" title="1. 面向对象三大特征"></a>1. 面向对象三大特征</h3><p>面向对象三大特征</p>
<p>①封装（Encapsulation）</p>
<p>②继承（Inheritance）</p>
<p>③多态（Polymorphism）</p>
<h3 id="2-对象的创建与使用"><a href="#2-对象的创建与使用" class="headerlink" title="2.对象的创建与使用"></a>2.对象的创建与使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="comment">// 姓名</span></span><br><span class="line">String name; <span class="comment">// 实例变量</span></span><br><span class="line"><span class="comment">// 年龄</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="comment">// 性别</span></span><br><span class="line"><span class="type">boolean</span> gender;</span><br><span class="line"><span class="comment">// 学习</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123; System.out.println(“正在学习”); &#125; <span class="comment">// 实例方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="①对象的创建"><a href="#①对象的创建" class="headerlink" title="①对象的创建"></a>①对象的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>

<p>在Java中，使用class定义的类，属于引用数据类型。所以Student属于引用数据类型。类型名为：Student。</p>
<p>Student s; 表示定义一个变量。数据类型是Student。变量名是s。</p>
<h4 id="②对象的使用"><a href="#②对象的使用" class="headerlink" title="②对象的使用"></a>②对象的使用</h4><p>读取属性值：s.name</p>
<p>修改属性值：s.name &#x3D; “jackson”;</p>
<h4 id="③通过一个类可以实例化多个对象"><a href="#③通过一个类可以实例化多个对象" class="headerlink" title="③通过一个类可以实例化多个对象"></a>③通过一个类可以实例化多个对象</h4><p>Student s1 &#x3D; new Student();</p>
<p>Student s2 &#x3D; new Student();</p>
<h4 id="④-public-static-void-functionA（），直接用类名-functionA-来访问"><a href="#④-public-static-void-functionA（），直接用类名-functionA-来访问" class="headerlink" title="④ public static   void functionA（），直接用类名.functionA()来访问"></a>④ public static   void functionA（），直接用类名.functionA()来访问</h4><blockquote>
<p>这个叫做静态方法</p>
<p>如果描述对象的动作，就不加static ，这种方法叫做实例方法</p>
</blockquote>
<h3 id="3-JVM内存结构图"><a href="#3-JVM内存结构图" class="headerlink" title="3.JVM内存结构图"></a>3.JVM内存结构图</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223195906110.png" alt="image-20240223195906110"></p>
<ol>
<li><strong>元空间（mataspace）存储的是类的元信息，字节码等。</strong>元空间是在java8后面引入的。</li>
</ol>
<p>JVM java虚拟机中定义的规范叫做方法区。</p>
<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223202022775.png" alt="image-20240223202022775" style="zoom:200%;" />

<h4 id="一旦引用为NULL，表示引用不再指向对象了"><a href="#一旦引用为NULL，表示引用不再指向对象了" class="headerlink" title="&#x3D;&#x3D;一旦引用为NULL，表示引用不再指向对象了&#x3D;&#x3D;"></a>&#x3D;&#x3D;一旦引用为NULL，表示引用不再指向对象了&#x3D;&#x3D;</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223202252613.png" alt="image-20240223202252613"></p>
<h3 id="4-封装"><a href="#4-封装" class="headerlink" title="4.封装"></a>4.封装</h3><h4 id="什么是封装？"><a href="#什么是封装？" class="headerlink" title="什么是封装？"></a><strong>什么是封装</strong>？</h4><p>封装是一种将数据和方法加以包装，使之成为一个独立的实体，并且把它与外部对象隔离开来的机制。具体来说，封装是将一个对象的所有“状态（属性）”以及“行为（方法）”统一封装到一个类中，从而隐藏了对象内部的具体实现细节，向外界提供了有限的访问接口，以实现对对象的保护和隔离。</p>
<h4 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h4><p>封装通过限制外部对对象内部的直接访问和修改，保证了数据的安全性，并提高了代码的可维护性和可复用性。</p>
<h4 id="在代码上如何实现封装"><a href="#在代码上如何实现封装" class="headerlink" title="在代码上如何实现封装"></a>在代码上如何实现封装</h4><h5 id="1-属性私有化，对外提供getter和setter方法。"><a href="#1-属性私有化，对外提供getter和setter方法。" class="headerlink" title="1. 属性私有化，对外提供getter和setter方法。"></a>1. 属性私有化，对外提供getter和setter方法。</h5><p>属性私有化：使用private来进行修饰。</p>
<p>属性私有化的作用是禁止外部程序随意访问。</p>
<h5 id="2-为了保证外部程序以然可以访问age属性，还是需要提供一个公开的外部访问的入口。"><a href="#2-为了保证外部程序以然可以访问age属性，还是需要提供一个公开的外部访问的入口。" class="headerlink" title="2. 为了保证外部程序以然可以访问age属性，还是需要提供一个公开的外部访问的入口。"></a>2. 为了保证外部程序以然可以访问age属性，还是需要提供一个公开的外部访问的入口。</h5><blockquote>
<p>访问一般分为两个方法，一个负责读，一个负责修改。</p>
</blockquote>
<p>读取方法的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>改方法的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>实例方法调用实例方法</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225145941617.png" alt="image-20240225145941617"></p>
<p>还是一个this.pay()</p>
<h3 id="5-构造方法（构造器）constructor"><a href="#5-构造方法（构造器）constructor" class="headerlink" title="5.  构造方法（构造器）constructor"></a>5.  构造方法（构造器）constructor</h3><blockquote>
<p>其实就是C里面的构造函数</p>
</blockquote>
<h4 id="构造方法的作用"><a href="#构造方法的作用" class="headerlink" title="构造方法的作用"></a>构造方法的作用</h4><ol>
<li>实现对象的出啊关键，通过调用的构造方法啊可以完成对于对象的创建</li>
<li>实现对于对象的各种属性的赋值。</li>
</ol>
<h4 id="构造方法怎么定义？"><a href="#构造方法怎么定义？" class="headerlink" title="构造方法怎么定义？"></a>构造方法怎么定义？</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225150328362.png" alt="image-20240225150328362"></p>
<p>构造方法最后执行结束之后，会返回这个new出来的实例的内存地址，但是构造方法中不需要提供return语句</p>
<h5 id="构造方法名一定要和类名保持一致！"><a href="#构造方法名一定要和类名保持一致！" class="headerlink" title="构造方法名一定要和类名保持一致！"></a>构造方法名一定要和类名保持一致！</h5><p>构造方法不需要返回值，如果有返回值就变成了普通方法</p>
<h4 id="缺省构造器"><a href="#缺省构造器" class="headerlink" title="缺省构造器"></a>缺省构造器</h4><p>如果一个类中没有显示的去定义构造方法，就会提供一个默认的方法，叫做缺省构造器。</p>
<p>当在调用 new Classname的时候，其实就是在调用构造函数</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225151158129.png" alt="image-20240225151158129"></p>
<p>完成构建，属性赋默认值。 </p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225154836218.png" alt="image-20240225154836218"></p>
<p>如果一个类里面提供了构造函数，那么就不会再创建缺省的构造方法，所以最好还是写一个无参数的构造方法。</p>
<blockquote>
<p>构造方法Constructor(构造器)</p>
<p>①构造方法有什么作用？</p>
<p>1.构造方法的执行分为两个阶段：对象的创建和对象的初始化。这两个阶段不能颠倒，也不可分割。</p>
<p>2.在Java中，当我们使用关键字new时，就会在内存中创建一个新的对象，虽然对象已经被创建出来了，但还没有被初始化。而初始化则是在执行构造方法体时进行的。</p>
<p>②构造方法如何定义？</p>
<p>[修饰符列表] 构造方法名(形参){}</p>
<p>③构造方法如何调用？new 构造方法名(实参);</p>
<p>④关于无参数构造方法：如果一个类没有显示的定义任何构造方法，系统会默认提供一个无参数构造方法，也被称为缺省构造器。一旦显示的定义了构造方法，则缺省构造器将不存在。为了方便对象的创建，建议将缺省构造器显示的定义出来。</p>
<p>⑤构造方法支持重载机制。</p>
<p>⑥关于构造代码块。对象的创建和初始化过程梳理：</p>
<p>①new的时候在堆内存中开辟空间，给所有属性赋默认值</p>
<p>②执行构造代码块进行初始化</p>
<p>③执行构造方法体进行初始化</p>
<p>④构造方法执行结束，对象初始化完毕。</p>
</blockquote>
<p>注意，set是修改，构造方法是初始化</p>
<h3 id="6-this关键字"><a href="#6-this关键字" class="headerlink" title="6. this关键字"></a>6. this关键字</h3><p>this关键字</p>
<p>①this是一个关键字。</p>
<p>②this出现在实例方法中，代表当前对象。语法是：this.</p>
<p>③this本质上是一个&#x3D;&#x3D;引用&#x3D;&#x3D;，该引用保存当前对象的内存地址。</p>
<p>④通过“this.”可以访问实例变量，可以调用实例方法。</p>
<p>⑤this存储在：栈帧的局部变量表的第0个槽位上。</p>
<p>⑥this. 大部分情况下可以省略，用于区分局部变量和实例变量时不能省略。</p>
<p>⑦this不能出现在静态方法中。</p>
<blockquote>
<p>public static vois functionstatic(){}</p>
<p>这里面不可以用this，因为static方法中没有当前对象，所以不可以用this。</p>
<p>但是在静态方法中可以调用另外一个静态方法。</p>
</blockquote>
<p>⑧“this(实参)”语法：</p>
<p>①只能出现在构造方法的第一行。</p>
<p>②通过当前构造方法去调用本类中其他的构造方法。</p>
<p>③作用是：代码复用。</p>
<p>实例方法只可以引用.</p>
<h3 id="7-static关键字"><a href="#7-static关键字" class="headerlink" title="7.static关键字"></a>7.static关键字</h3><blockquote>
<p>final变量不能修改,static变量可以在这个类里头修改</p>
</blockquote>
<p>①static是一个关键字，翻译为：静态的。</p>
<p><strong>②static修饰的变量叫做静态变量。</strong>当所有对象的某个属性的值是相同的，建议将该属性定义为静态变量，来节省内存的开销。</p>
<p>③静态变量在类加载时初始化，存储在堆中。</p>
<p><strong>④static修饰的方法叫做静态方法。</strong></p>
<blockquote>
<p>所有static级别的，都是类级别的，直接用类名来访问</p>
</blockquote>
<p>⑤所有静态变量和静态方法，统一使用“类名.”调用。&#x3D;&#x3D;虽然可以使用“引用.”来调用，但实际运行时和对象无关，所以不建议这样写，因为这样写会给其他人造成疑惑。&#x3D;&#x3D;</p>
<p>⑥使用“引用.”访问静态相关的，即使引用为null，也不会出现空指针异常。</p>
<p>⑦静态方法中不能使用this关键字。因此无法直接访问实例变量和调用实例方法。</p>
<p>⑧静态代码块在类加载时执行，一个类中可以编写多个静态代码块，遵循自上而下的顺序依次执行。</p>
<p>⑨静态代码块代表了类加载时刻，如果你有代码需要在此时刻执行，可以将该代码放到静态代码块中。</p>
<h4 id="静态变量内存图"><a href="#静态变量内存图" class="headerlink" title="静态变量内存图"></a>静态变量内存图</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225194625857.png" alt="image-20240225194625857"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225194714666.png" alt="image-20240225194714666"></p>
<h4 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225195106209.png" alt="image-20240225195106209"></p>
<p>静态方法中无法直接访问实例相关的数据。</p>
<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225195527691.png" alt="image-20240225195527691"></p>
<h5 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h5><ol>
<li><p>语法格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static&#123;</span><br><span class="line">这个括号叫做静态上下文，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态代码块在类加载的时候执行，并且只执行了一次</p>
</li>
<li><p>静态代码块可以编写多个，并且遵循自上而下的顺序执行。</p>
</li>
</ol>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225212935175.png" alt="image-20240225212935175"></p>
<p>按照以上的这个代码，main方法也是最后执行的</p>
<p>此外</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225213020734.png" alt="image-20240225213020734"></p>
<p>按照这个，会报错。连main方法都没有执行，name也没有执行，</p>
<p>：在静态上下文中无法直接访问实例相关的数据，但是可以访问在这个静态代码块前面定义的静态数据。</p>
<p>在这个静态代码块之后定义的就不能访问了。因为静态的数据是按照顺序进行的。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225213131315.png" alt="image-20240225213131315"></p>
<h3 id="8-JVMjava虚拟机的体系结构"><a href="#8-JVMjava虚拟机的体系结构" class="headerlink" title="8.JVMjava虚拟机的体系结构"></a>8.JVMjava虚拟机的体系结构</h3><p>&#x3D;&#x3D;JVM对应了一套规范（Java虚拟机规范），它可以有不同的实现&#x3D;&#x3D;</p>
<p>①JVM规范是一种抽象的概念，它可以有多种不同的实现。例如：</p>
<p>1.HotSpot：HotSpot 由 Oracle 公司开发，是目前最常用的虚拟机实现，也是默认的 Java 虚拟机，默认包含在 Oracle JDK 和 OpenJDK 中</p>
<p>2.JRockit：JRockit 也是由 Oracle 公司开发。它是一款针对生产环境优化的 JVM 实现，能够提供高性能和可伸缩性</p>
<p>3.IBM JDK：IBM JDK 是 IBM 公司开发的 Java 环境，采用了与 HotSpot 不同的 J9 VM，能够提供更小的内存占用和更迅速的启动时间</p>
<p>4.Azul Zing：Azul Zing 是针对生产环境优化的虚拟机实现，能够提供高性能和实时处理能力，适合于高负载的企业应用和实时分析等场景</p>
<p>5.OpenJ9：OpenJ9 是由 IBM 开发的优化的 Java 虚拟机实现，支持高度轻量级、低时延的 GC、优化的 JIT 编译器和用于健康度测试的可观察性仪表板</p>
<p>②右图是从oracle官网上截取的Java虚拟机规范中的一部分。（大家也可以找一下oracle官方文档）</p>
<p>③我们主要研究运行时数据区。运行时数据区包括6部分：</p>
<ol>
<li><p>The pc Register（程序计数器）：下一个你要执行的字节码指令</p>
</li>
<li><p>Java Virtual Machine Stacks（Java虚拟机栈）</p>
</li>
<li><p><strong>Heap（堆）</strong></p>
</li>
<li><p><strong>Method Area（方法区）</strong></p>
</li>
<li><p>Run-Time Constant Pool（运行时常量池）</p>
</li>
<li><p>Native Method Stacks（本地方法栈）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JVM规范中的运行时数据区</span><br><span class="line">The pc Register（程序计数器）：是一块较小的内存空间，此计数器记录的是正在执行的虚拟机字节码指令的地址；</span><br><span class="line">Java Virtual Machine Stacks（Java虚拟机栈）：Java虚拟机栈用于存储栈帧。栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</span><br><span class="line">Heap（堆）：是Java虚拟机所管理的最大的一块内存。堆内存用于存放Java对象实例以及数组。堆是垃圾收集器收集垃圾的主要区域。</span><br><span class="line">Method Area（方法区）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</span><br><span class="line">这个是规范，但是在实现中有些会加到堆里</span><br><span class="line">Run-Time Constant Pool（运行时常量池）：是方法区的一部分，用于存放编译期生成的各种字面量与符号引用（类名、属性名等）。</span><br><span class="line">Native Method Stacks（本地方法栈）：在本地方法的执行过程中，会使用到本地方法栈。和 Java 虚拟机栈十分相似。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结：这些运行时数据区虽然在功能上有所区别，但在整个 Java 虚拟机启动时都需要被创建，并且在虚拟机运行期间始终存在，直到虚拟机停止运行时被销毁。同时，不同的 JVM 实现对运行时数据区的分配和管理方式也可能不同，会对性能和功能产生影响。</span><br></pre></td></tr></table></figure>

<p>**<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225214223891.png" alt="image-20240225214223891"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225214331825.png" alt="image-20240225214331825"></p>
<h3 id="9、设计模式概述"><a href="#9、设计模式概述" class="headerlink" title="9、设计模式概述"></a>9、设计模式概述</h3><p>单例模式（&#x3D;&#x3D;GoF&#x3D;&#x3D;23种设计模式之一，最简单的设计模式：&#x3D;&#x3D;如何保证某种类型的对象只创建一个）&#x3D;&#x3D;</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225220833968.png" alt="image-20240225220833968"></p>
<p>&#x2F;&#x2F;饿汉式单例模式：不管这个对象用还是不用，提前把对象给创建好了。</p>
<p><strong>step1：构造函数私有化&#x2F;&#x2F;不让new，但是又可以获得方法</strong></p>
<p><strong>step2：对外提供一个公开的静态方法，用这个方法获取单个实例</strong></p>
<p><strong>step3: 定义一个静态变量，在类加载的时候，初始化静态变量（只初始化一次）。</strong></p>
<p>&#x2F;&#x2F;懒汉式单例模式：等到用的时候再创建，不用不创建。</p>
<p>step1：构造方法私有化</p>
<p>step2：对外提供一个静态方法，可以通过这个方法获取到对象；</p>
<p><strong>这个是初步的，等到以后多线程的时候，还需要 改进</strong></p>
<h3 id="10-继承"><a href="#10-继承" class="headerlink" title="10.继承"></a>10.继承</h3><p>① 面向对象三大特征之一：继承</p>
<p>② 继承作用？</p>
<p><strong>l基本作用：代码复用</strong></p>
<p><strong>l重要作用：有了继承，才有了方法覆盖和多态机制。</strong></p>
<p>③继承在java中如何实现？</p>
<p><strong>l[修饰符列表] class 类名 extends 父类名{}</strong></p>
<p><strong>lextends翻译为扩展。表示子类继承父类后，子类是对父类的扩展。</strong></p>
<p>④继承相关的术语：当B类继承A类时</p>
<p><strong>lA类称为：父类、超类、基类、superclass</strong></p>
<p><strong>lB类称为：子类、派生类、subclass</strong></p>
<p>⑤Java只支持单继承，一个类只能直接继承一个类。</p>
<p>⑥Java不支持多继承，但支持多重继承（多层继承）。</p>
<p>⑦子类继承父类后，除私有的不支持继承、构造方法不支持继承。其它的全部会继承。</p>
<p>&#x3D;&#x3D;⑧一个类没有显示继承任何类时，默认继承java.lang.Object类。&#x3D;&#x3D;比如tostring就是object的，任何一个类都可以调用</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225221336300.png" alt="image-20240225221336300"></p>
<h3 id="11-方法覆盖"><a href="#11-方法覆盖" class="headerlink" title="11.方法覆盖"></a>11.方法覆盖</h3><p>方法覆盖&#x2F;override&#x2F;方法重写&#x2F;overwrite，是在编译器层面的功能，方法重载机制是给编译器看的</p>
<h4 id="①什么情况下考虑使用方法覆盖？"><a href="#①什么情况下考虑使用方法覆盖？" class="headerlink" title="①什么情况下考虑使用方法覆盖？"></a>①什么情况下考虑使用方法覆盖？</h4><p>1.当从父类中继承过来的方法无法满足当前子类的业务需求时。</p>
<h4 id="②发生方法覆盖的条件？"><a href="#②发生方法覆盖的条件？" class="headerlink" title="②发生方法覆盖的条件？"></a>②发生方法覆盖的条件？</h4><ol>
<li><p>具有&#x3D;&#x3D;继承关系的父子类之间&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;相同的返回值类型，相同的方法名，相同的形式参数列表&#x3D;&#x3D;</p>
</li>
<li><p>访问权限不能变低，可以变高。</p>
</li>
</ol>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225225653075.png" alt="image-20240225225653075"></p>
<p>高———————&gt;低</p>
<ol start="4">
<li>抛出异常不能变多，可以变少。</li>
</ol>
<p>父类抛了,子类不抛,比如</p>
<ol start="5">
<li>返回值类型可以是父类方法返回值类型的子类。</li>
</ol>
<h4 id="③方法覆盖的小细节："><a href="#③方法覆盖的小细节：" class="headerlink" title="③方法覆盖的小细节："></a>③方法覆盖的小细节：</h4><ol>
<li><p>@Override注解标注的方法会在编译阶段检查该方法是否重写了父类的方法。</p>
</li>
<li><p>&#x3D;&#x3D;私有方法不能继承，所以不能覆盖。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;构造方法不能继承，所以不能覆盖。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;静态方法不存在方法覆盖，方法覆盖针对的是实例方法。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;方法覆盖说的实例方法，和实例变量无关。（&#x3D;&#x3D;可以写程序测试一下）</p>
</li>
</ol>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225224843910.png" alt="image-20240225224843910"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225224915679.png" alt="image-20240225224915679"></p>
<p><strong>在java中也有个注解，在编译的时候可以检查这个方法是否是重写了父类的方法</strong>@Override</p>
<blockquote>
<p>@Override 只在编译阶段会有用,和运行期无关.</p>
<p>如果返回值类型是引用类型,那么这个返回值类型可以是原类型的子类型</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225225250788.png" alt="image-20240225225250788"></p>
<h3 id="12-多态"><a href="#12-多态" class="headerlink" title="12.多态"></a>12.多态</h3><p>多态的基础语法</p>
<h4 id="①什么是向上转型和向下转型？"><a href="#①什么是向上转型和向下转型？" class="headerlink" title="①什么是向上转型和向下转型？"></a>①什么是向上转型和向下转型？</h4><ol>
<li><p>java允许具有继承关系的父子类型之间的类型转换。</p>
</li>
<li><p>&#x3D;&#x3D;向上转型（upcasting）：子–&gt;父&#x3D;&#x3D;</p>
</li>
</ol>
<p>&#x3D;&#x3D;l子类型的对象可以赋值给一个父类型的引用。&#x3D;&#x3D;</p>
<ol start="3">
<li>&#x3D;&#x3D;向下转型（downcasting）：父–&gt;子&#x3D;&#x3D;</li>
</ol>
<blockquote>
<p>一般来说,想要调用的方法是子类当中特有的方法的时候,才会想要向下转型.</p>
</blockquote>
<p>&#x3D;&#x3D;l父类型的引用可以转换为子&#x3D;&#x3D;类型的引用。但是需要加强制类型转换符。</p>
<ol start="4">
<li>无论是向上转型还是向下转型，前提条件是：&#x3D;&#x3D;两种类型之间必须存在继承关系。这样编译器才能编译通过。&#x3D;&#x3D;</li>
</ol>
<h4 id="②什么是多态？"><a href="#②什么是多态？" class="headerlink" title="②什么是多态？"></a>②什么是多态？</h4><blockquote>
<p>编译过程中是一个形态,运行的时候又是另外一个形态.</p>
</blockquote>
<ol>
<li><p>父类型引用指向子类对象。Animal a &#x3D; new Cat(); a.move();</p>
</li>
<li><p>程序分为编译阶段和运行阶段：</p>
</li>
</ol>
<blockquote>
<p>l编译阶段：编译器只知道a是Animal类型，因此去Animal类中找move()方法，找到之后，绑定成功，编译通过。这个过程通常被称为静态绑定。</p>
</blockquote>
<blockquote>
<p>l运行阶段：运行时和JVM堆内存中的真实Java对象有关，所以运行时会自动调用真实对象的move()方法。这个过程通常被称为动态绑定。</p>
</blockquote>
<ol start="3">
<li>多态指的是：多种形态，编译阶段一种形态，运行阶段另一种形态，因此叫做多态。</li>
</ol>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225231010553.png" alt="image-20240225231010553"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225231835927.png" alt="image-20240225231835927"></p>
<h4 id="③-instanceof运算符可以解决类型转换问题"><a href="#③-instanceof运算符可以解决类型转换问题" class="headerlink" title="③ instanceof运算符可以解决类型转换问题"></a>③ instanceof运算符可以解决类型转换问题</h4><ol>
<li>instanceof运算符的结果一定是:true&#x2F;false</li>
<li>语法结构</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a instanceof cat)</span><br><span class="line">	true表示:a引用指向的对象是cat类型</span><br><span class="line">	false表示:a引用的指向的对象不是cat</span><br></pre></td></tr></table></figure>

<p>这个运算符主要就是用来进行判断.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Bird)&#123;</span><br><span class="line">	<span class="type">Bird</span> <span class="variable">y</span> <span class="operator">=</span>(Bird)x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="④-软件开发七大原则"><a href="#④-软件开发七大原则" class="headerlink" title="④ 软件开发七大原则"></a>④ 软件开发七大原则</h4><blockquote>
<p>软件开发原则旨在引导软件行业的从业者在代码设计和开发过程中，遵循一些基本原则，以达到高质量、易维护、易扩展、安全性强等目标。软件开发原则与具体的编程语言无关的，属于软件设计方面的知识。</p>
</blockquote>
<ol>
<li><p>&#x3D;&#x3D;开闭原则 (Open-Closed Principle，OCP)：一个软件实体应该对扩展开放，对修改关闭。即在不修改原有代码的基础上，通过添加新的代码来扩展功能。（最基本的原则，其它原则都是为这个原则服务的。）&#x3D;&#x3D;</p>
</li>
<li><p>单一职责原则：一个类只负责单一的职责，也就是一个类只有一个引起它变化的原因。</p>
</li>
<li><p>里氏替换原则：子类对象可以替换其基类对象出现的任何地方，并且保证原有程序的正确性。</p>
</li>
<li><p>接口隔离原则：客户端不应该依赖它不需要的接口。</p>
</li>
<li><p>依赖倒置原则：高层模块不应该依赖底层模块，它们都应该依赖于抽象接口。换言之，面向接口编程。</p>
</li>
<li><p>迪米特法则：一个对象应该对其它对象保持最少的了解。即一个类应该对自己需要耦合或调用的类知道得最少。</p>
</li>
<li><p>合成复用原则：尽量使用对象组合和聚合，而不是继承来达到复用的目的。组合和聚合可以在获取外部对象的方法中被调用，是一种运行时关联，而继承则是一种编译时关联。</p>
</li>
</ol>
<h4 id="⑤-多态在开发中的作用"><a href="#⑤-多态在开发中的作用" class="headerlink" title="⑤ 多态在开发中的作用"></a>⑤ 多态在开发中的作用</h4><ol>
<li><p>降低程序的耦合度，提高程序的扩展力。</p>
</li>
<li><p>尽量使用多态，面向抽象编程，不要面向具体编程。</p>
</li>
</ol>
<h4 id="⑥多态的基础语法"><a href="#⑥多态的基础语法" class="headerlink" title="⑥多态的基础语法"></a>⑥多态的基础语法</h4><p> <strong>向下转型我们需要注意什么？</strong></p>
<ol>
<li><p>向下转型时，使用不当，容易发生类型转换异常：ClassCastException。</p>
</li>
<li><p>在向下转型时，一般建议使用instanceof运算符进行判断来避免ClassCastException的发生。</p>
</li>
</ol>
<p><strong>instanceof运算符的使用</strong></p>
<ol>
<li><p>语法格式：(引用 instanceof 类型)</p>
</li>
<li><p>执行结果是true或者false</p>
</li>
<li><p>例如：(a instanceof Cat)</p>
</li>
</ol>
<p>l如果结果是true：表示a引用指向的对象是Cat类型的。</p>
<p>l如果结果是false：表示a引用指向的对象不是Cat类型的。</p>
<h3 id="13-抽象类"><a href="#13-抽象类" class="headerlink" title="13 . 抽象类"></a>13 . 抽象类</h3><blockquote>
<p>注意！抽象类不一定有抽象方法，但是有抽象方法的类一定是抽象类。</p>
<p>此外,public和abstract没有顺序关系</p>
</blockquote>
<h4 id="①什么时候考虑将类定义为抽象类？"><a href="#①什么时候考虑将类定义为抽象类？" class="headerlink" title="①什么时候考虑将类定义为抽象类？"></a>①什么时候考虑将类定义为抽象类？</h4><p>如果类中有些方法无法实现或者没有意义，可以将方法定义为抽象方法。类定义为抽象类。这样在抽象类中只提供<strong>公共代码</strong>，具体的实现<strong>强行</strong>交给子类去做。比如一个Person类有一个问候的方法greet()，但是不同国家的人问候的方式不同，因此greet()方法具体实现应该交给子类。再比如主人喂养宠物的例子中的宠物Pet，Pet中的eat()方法的方法体就是没有意义的。</p>
<h4 id="②抽象类如何定义？"><a href="#②抽象类如何定义？" class="headerlink" title="②抽象类如何定义？"></a>②抽象类如何定义？</h4><p>abstract class 类名{}</p>
<h4 id="③抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。"><a href="#③抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。" class="headerlink" title="③抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。"></a>③抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。</h4><h4 id="④抽象方法如何定义？"><a href="#④抽象方法如何定义？" class="headerlink" title="④抽象方法如何定义？"></a>④抽象方法如何定义？</h4><p>abstract 方法返回值类型 方法名(形参);</p>
<blockquote>
<p>没有方法体 </p>
</blockquote>
<h4 id="⑤抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。"><a href="#⑤抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。" class="headerlink" title="⑤抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。"></a>⑤抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。</h4><h4 id="⑥一个非抽象的类继承extend抽象类，要求必须将抽象方法进行实现-重写。"><a href="#⑥一个非抽象的类继承extend抽象类，要求必须将抽象方法进行实现-重写。" class="headerlink" title="&#x3D;&#x3D;⑥一个非抽象的类继承extend抽象类，要求必须将抽象方法进行实现&#x2F;重写。&#x3D;&#x3D;"></a>&#x3D;&#x3D;⑥一个非抽象的类继承extend抽象类，要求必须将抽象方法进行实现&#x2F;重写。&#x3D;&#x3D;</h4><blockquote>
<p>需要把全部的抽象方法全部给实现了</p>
</blockquote>
<h4 id="⑦abstract关键字不能和private，final，static关键字共存。"><a href="#⑦abstract关键字不能和private，final，static关键字共存。" class="headerlink" title="⑦abstract关键字不能和private，final，static关键字共存。"></a>⑦abstract关键字不能和private，final，static关键字共存。</h4><blockquote>
<p>private: private是不能被继承覆盖的,而abstract修饰的是一定要被继承实现的,存在冲突.</p>
<p>final: 不能继承</p>
<p>static:不能被覆盖</p>
</blockquote>
<h4 id="⑧抽象类需要构造方法-但是无法实现实例化-这个构造方法是给其子类使用的"><a href="#⑧抽象类需要构造方法-但是无法实现实例化-这个构造方法是给其子类使用的" class="headerlink" title="⑧抽象类需要构造方法,但是无法实现实例化,这个构造方法是给其子类使用的."></a>⑧抽象类需要构造方法,但是无法实现实例化,这个构造方法是给其子类使用的.</h4><h3 id="14-super关键字"><a href="#14-super关键字" class="headerlink" title="14. super关键字"></a>14. super关键字</h3><p>①super关键字和this关键字对比来学习。this代表的是当前对象。<strong>super代表的是当前对象中的父类型特征。</strong></p>
<p><strong>②super不能使用在静态上下文中。</strong>就是在编写</p>
<p>③“super.”大部分情况下是可以省略的。什么时候不能省略？</p>
<p>&#x3D;&#x3D;<strong>当父类和子类中定义了相同的属性（实例变量）或者相同方法（实例方法）时，如果需要在子类中访问父类的属性或方法时，super.不能省略。</strong>&#x3D;&#x3D;</p>
<p><strong>④this可以单独输出，super不能单独输出。</strong></p>
<blockquote>
<p>this本身是一个引用,所以可以直接输出,super不是引用,不能直接输出</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">system.out.println(this);//√</span><br><span class="line">System.out.println(super);//×</span><br></pre></td></tr></table></figure>

<p>⑤super(实参); 通过子类的构造方法调用父类的构造方法，目的是为了完成父类型特征的初始化。</p>
<p>⑥当一个构造方法第一行没有显示的调用“super(实参);”，也没有显示的调用“this(实参)”，系统会自动调用super()。因此一个类中的无参数构造方法建议显示的定义出来。</p>
<p>⑦super(实参); 这个语法只能出现在构造方法第一行。</p>
<blockquote>
<p>this()和super()</p>
</blockquote>
<p>⑧在Java语言中只要new对象，Object的无参数构造方法一定会执行。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226111210195.png" alt="image-20240226111210195"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226112229142.png" alt="image-20240226112229142"></p>
<p>子类的构造方法中,就算没有写super();,也是会跑这个代码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>();</span><br><span class="line">会跑父类的构造方法.也会给父类的字段赋值.</span><br><span class="line">当一个构造方法,没有显示的写<span class="built_in">this</span>(),也没有显示的写<span class="built_in">super</span>(),系统会自动的调用<span class="built_in">super</span>()     </span><br><span class="line">当然也可以是:<span class="built_in">super</span>(actno , balance); </span><br><span class="line">    调用父类的方法: <span class="built_in">super</span>.doSome();</span><br><span class="line">				</span><br></pre></td></tr></table></figure>

<h3 id="15-final关键字"><a href="#15-final关键字" class="headerlink" title="15.final关键字"></a>15.final关键字</h3><blockquote>
<p>这个关键字表示是最终的,被final所修饰的类不能被 继承</p>
</blockquote>
<p>①final修饰的类不能被继承</p>
<p>②final修饰的方法不能被覆盖</p>
<p>③final修饰的变量，一旦赋值不能重新赋值</p>
<p>④final修饰的实例变量必须&#x3D;&#x3D;在对象初始化时&#x3D;&#x3D;手动赋值</p>
<blockquote>
<p>必须在构造方法执行完之前,手动附上值.不允许采用系统的默认值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final class Mystring&#123;</span><br><span class="line">	public final void m()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//比如String就是不能被继承</span><br><span class="line"></span><br><span class="line">final String name;//×</span><br><span class="line">或者 </span><br><span class="line">final String name;</span><br><span class="line">public User(String name , int age)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤final修饰的实例变量一般和static联合使用：&#x3D;&#x3D;称为常量&#x3D;&#x3D;</p>
<blockquote>
<p>因为类中定义的final 修饰的变量不能修改,最直接的理解就是所有的实例变量的这个变量都是一个值,因此,假设new出来了100个,那么这100个类的这个字段也都是同一个,所以可以直接加上static,设置成一个静态的,更方便,也更省堆空间. </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MATH_PAI</span> <span class="operator">=</span> <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<p>⑥final修饰的引用，一旦指向某个对象后，不能再指向其它对象。但指向的对象内部的数据是可以修改的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 修饰对象,内存地址不能改,但是内存地址里面的东西还是可以修改的</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226150228776.png" alt="image-20240226150228776"></p>
<h3 id="16-接口"><a href="#16-接口" class="headerlink" title="16.接口"></a>16.接口</h3><h4 id="接口的基础语法"><a href="#接口的基础语法" class="headerlink" title="接口的基础语法"></a>接口的基础语法</h4><p><strong>&#x3D;&#x3D;①接口（interface）在Java中表示一种规范或契约，它定义了一组抽象方法和常量，用来描述一些实现这个接口的类应该具有哪些行为和属性&#x3D;&#x3D;<strong>。</strong>接口和类一样，也是一种引用数据类型</strong>。</p>
<p>②接口怎么定义？[修饰符列表] interface 接口名{}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Myinterface&#123;</span><br><span class="line">	里面的方法可不能有方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③抽象类是半抽象的(抽象类可以定义抽象方法也可以定义非抽象方法 ,有构造方法不能new对象)，</p>
<p>​	接口是完全抽象的。&#x3D;&#x3D;<strong>接口没有构造方法，也无法实例化。</strong>&#x3D;&#x3D;</p>
<p><strong>④接口中只能定义：常量+抽象方法。&#x3D;&#x3D;接口中的常量的static final可以省略&#x3D;&#x3D;。接口中的抽象方法的abstract可以省略。接口中所有的方法和变量都是public修饰的。</strong>(JDK8)</p>
<p><strong>⑤接口和接口之间可以多继承。</strong></p>
<p>⑥类和接口的关系我们叫做实现（**&#x3D;&#x3D;这里的实现也可以等同看做继承&#x3D;&#x3D;<strong>）。使用</strong>&#x3D;&#x3D;implements&#x3D;&#x3D;**关键字进行接口的实现。</p>
<p><strong>⑦一个非抽象的类实现接口必须将接口中所有的抽象方法全部实现。</strong></p>
<p><strong>⑧一个类可以实现多个接口。语法是：class 类 implements 接口A,接口B{}</strong></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226161310540.png" alt="image-20240226161310540"></p>
<p>⑨Java8之后，接口中允许出现默认方法和静态方法(JDK8新特性)</p>
<p>​        <strong>引入默认方式是为了解决接口演变问题：接口可以定义抽象方法，但是不能实现这些方法。所有实现接口的类都必须实现这些抽象方法。这会导致接口升级的问题：当我们向接口添加或删除一个抽象方法时，这会破坏该接口的所有实现，并且所有该接口的用户都必须修改其代码才能适应更改。这就是所谓的”接口演变”问题。</strong></p>
<blockquote>
<p>如果还是按照之前的,那么如果需要在接口中加入一个新的方法,按照接口的实现类需要把借口中的全部都给实现了这一个要求,这个接口的所有实现类都需要实现这个接口,这太麻烦了.</p>
<p>加入默认方法后,实现该接口的实现类中都有这个默认方法,但是不需要去实现</p>
</blockquote>
<p>​        <strong>引入的静态方法只能使用本接口名来访问，无法使用实现类的类名访问。</strong></p>
<blockquote>
<p>原因:接口也可以当工具使用,渐渐变成了工具类</p>
</blockquote>
<p>默认方法:</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226162231265.png" alt="image-20240226162231265"></p>
<p>静态方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticmethod</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">MyInterface.staticmethod();</span><br><span class="line"><span class="comment">//不可以</span></span><br><span class="line">MyInterfaceImpl.staticmethod();</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226162707551.png" alt="image-20240226162707551"><strong>⑩JDK9之后允许接口中定义私有private的实例方法（为默认方法服务的）和私有的静态方法（为静态方法服务的)。</strong></p>
<p>⑪所有的接口隐式的继承Object。因此接口也可以调用Object类的相关方法。</p>
<h4 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h4><p>①面向接口调用的称为：接口调用者</p>
<p>②面向接口实现的称为：接口实现者</p>
<p>③调用者和实现者通过接口达到了解耦合。也就是说调用者不需要关心具体的实现者，实现者也不需要关心具体的调用者，双方都遵循规范，面向接口进行开发。</p>
<p>④<strong>面向抽象编程，面向接口编程，可以降低程序的耦合度，提高程序的&#x3D;&#x3D;扩展力&#x3D;&#x3D;。</strong></p>
<p>⑤例如定义一个Usb接口，提供read()和write()方法，通过read()方法读，通过write()方法写：</p>
<p>①定义一个电脑类Computer，它是调用者，面向Usb接口来调用。</p>
<p>②Usb接口的实现可以有很多，例如：打印机（Printer），硬盘（HardDrive）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conn</span><span class="params">(Usb usb)</span>&#123;</span><br><span class="line"></span><br><span class="line">usb.read();</span><br><span class="line"></span><br><span class="line">usb.write();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑦再想想，我们平时去饭店吃饭，这个场景中有没有接口呢？食谱菜单就是接口。顾客是调用者。厨师是实现者。</p>
<h4 id="接口与抽象类如何选择"><a href="#接口与抽象类如何选择" class="headerlink" title="接口与抽象类如何选择"></a>接口与抽象类如何选择</h4><p>①抽象类和接口虽然在代码角度都能达到同样的效果，但适用场景不同：</p>
<p>​        抽象类主要适用于公共代码的提取。当多个类中有共同的属性和方法时，为了达到代码的复用，建议为这几个类提取出来一个父类，在该父类中编写公共的代码。如果有一些方法无法在该类中实现，可以延迟到子类中实现。这样的类就应该使用抽象类。</p>
<p>​       <strong>接口主要用于功能的扩展</strong>。例如有很多类，一些类需要这个方法，另外一些类不需要这个方法时，可以将该方法定义到接口中。需要这个方法的类就去实现这个接口，不需要这个方法的就可以不实现这个接口。接口主要规定的是行为。</p>
<p>注意：一个类继承某个类的同时可以实现多个接口：class 类 extends 父类 implements 接口A,接口B{}</p>
<p>注意：当某种类型向下转型为某个接口类型时，接口类型和该类之间可以没有继承关系，编译器不会报错的。</p>
<h3 id="17-UML-统一建模语言概述"><a href="#17-UML-统一建模语言概述" class="headerlink" title="17. UML(统一建模语言概述)"></a>17. UML(统一建模语言概述)</h3><h4 id="考虑一下类之间的关系"><a href="#考虑一下类之间的关系" class="headerlink" title="考虑一下类之间的关系."></a>考虑一下类之间的关系.</h4><p>①UML（Unified Modeling Language，统一建模语言）是一种用于面向对象软件开发的图形化的建模语言。它由Grady Booch、James Rumbaugh和Ivar Jacobson等三位著名的软件工程师所开发，并于1997年正式发布。UML提供了一套通用的图形化符号和规范，帮助开发人员以图形化的形式表达软件设计和编写的所有关键方面，从而更好地展示软件系统的设计和实现过程。</p>
<p>②UML是一种图形化的语言，类似于现实生活中建筑工程师画的建筑图纸，图纸上有特定的符号代表特殊的含义。</p>
<p>③UML不是专门为java语言准备的。只要是面向对象的编程语言，开发前的设计，都需要画UML图进行系统设计。（设计模式、软件开发七大原则等同样也不是只为java语言准备的。）</p>
<p>④UML图包括：</p>
<ul>
<li>类图（Class Diagram）：描述软件系统中的类、接口、关系和其属性等；</li>
<li>用例图（Use Case Diagram）：描述系统的功能需求和用户与系统之间的关系；</li>
<li>序列图（Sequence Diagram）：描述对象之间的交互、消息传递和时序约束等；</li>
<li>状态图（Statechart Diagram）：描述类或对象的生命周期以及状态之间的转换；</li>
<li>对象图（Object Diagram）：表示特定时间的系统状态，并显示其包含的对象及其属性；</li>
<li>协作图（Collaboration Diagram）：描述对象之间的协作，表示对象之间相互合作来完成任务的关系；</li>
<li>活动图（Activity Diagram）：描述系统的动态行为和流程，包括控制流和对象流；</li>
<li>部署图（Deployment Diagram）：描述软件或系统在不同物理设备上部署的情况，包括计算机、网络、中间件、应用程序等。</li>
</ul>
<p>⑤常见的UML建模工具有：StarUML，Rational Rose等。</p>
<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><ol>
<li>泛化关系（is a）&#x2F;&#x2F;继承关系</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">泛化关系（继承关系）is a关系。Cat is a Animal</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226173319940.png" alt="image-20240226173319940"></p>
<ol start="2">
<li>实现关系（is like a）&#x2F;&#x2F;定义一个接口,然后有一个实现接口类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实现关系 is like a 关系。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Usb</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HardDrive</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226173405538.png" alt="image-20240226173405538"></p>
<ol start="3">
<li>关联关系（has a）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">关联关系 has a</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Course</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量（属性）</span></span><br><span class="line">    Course course;</span><br><span class="line">&#125;</span><br><span class="line">A里面有B</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226173521101.png" alt="image-20240226173521101"></p>
<ol start="4">
<li>聚合关系</li>
</ol>
<blockquote>
<p>聚合关系指的是一个类包含、合成或者拥有另一个类的实例，而这个实例是可以独立存在的。聚合关系是一种弱关联关系，表示整体与部分之间的关系。例如一个教室有多个学生</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226174835150.png" alt="image-20240226174835150"></p>
<blockquote>
<p><strong>&#x3D;&#x3D;生命不绑定在一起&#x3D;&#x3D;</strong></p>
</blockquote>
<ol start="5">
<li>组合关系（Composition）</li>
</ol>
<blockquote>
<p><strong>组合关系是聚合关系的一种特殊情况，表示整体与部分之间的关系更加强烈</strong>。组合关系指的是一个类包含、合成或者拥有另一个类的实例，而这个实例只能同时存在于一个整体对象中。如果整体对象被销毁，那么部分对象也会被销毁。&#x3D;&#x3D;<strong>例如一个人对应四个肢体</strong>&#x3D;&#x3D;。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Limbs</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    List&lt;Limbs&gt; limbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175009462.png" alt="image-20240226175009462"></p>
<ol start="6">
<li>依赖关系（Dependency）</li>
</ol>
<blockquote>
<p>依赖关系是一种临时性的关系，**&#x3D;&#x3D;当一个类使用另一个类的功能时&#x3D;&#x3D;**，就会产生依赖关系。如果一个类的改变会影响到另一个类的功能，那么这两个类之间就存在依赖关系。依赖关系是一种较弱的关系，可以存在多个依赖于同一个类的对象。&#x3D;&#x3D;<strong>例如A类中使用了B类，但是B类作为A类的方法参数或者局部变量等</strong>。&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175047202.png" alt="image-20240226175047202"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">(A a)</span>&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">          A a;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-访问控制权限"><a href="#18-访问控制权限" class="headerlink" title="&#x3D;&#x3D;18. 访问控制权限&#x3D;&#x3D;"></a>&#x3D;&#x3D;18. 访问控制权限&#x3D;&#x3D;</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175206352.png" alt="image-20240226175206352"></p>
<p>①private：私有的，只能在本类中访问。</p>
<p>②缺省：默认的，同一个包下可以访问。</p>
<p>③protected：受保护的，子类中可以访问。（&#x3D;&#x3D;受保护的通常就是给子孙用的。&#x3D;&#x3D;）clone就是protected的</p>
<p>④public：公共的，在任何位置都可以访问。</p>
<p>&#x3D;&#x3D;①类中的属性和方法访问权限共有四种：private、缺省、protected和public。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;②类的访问权限只有两种：public和 缺省。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">只有以上两种是正确的</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="comment">//这个就是错误的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③访问权限控制符不能修饰局部变量。</p>
<blockquote>
<p>注意:class里面的属性,方法的访问权限是四个;但是对于定义类,是只有两种访问权限的.!</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175919594.png" alt="image-20240226175919594"></p>
<h3 id="19-Object类"><a href="#19-Object类" class="headerlink" title="19.Object类"></a>19.Object类</h3><h4 id="①java-lang-Object是所有类的超类。java中所有类都实现了这个类中的方法。"><a href="#①java-lang-Object是所有类的超类。java中所有类都实现了这个类中的方法。" class="headerlink" title="①java.lang.Object是所有类的超类。java中所有类都实现了这个类中的方法。"></a>①java.lang.Object是所有类的超类。java中所有类都实现了这个类中的方法。</h4><h4 id="②Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。"><a href="#②Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。" class="headerlink" title="②Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。"></a>②Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。</h4><h4 id="③现阶段Object类中需要掌握的方法："><a href="#③现阶段Object类中需要掌握的方法：" class="headerlink" title="③现阶段Object类中需要掌握的方法："></a>③现阶段Object类中需要掌握的方法：</h4><p> toString：将java对象转换成字符串。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226180456350.png" alt="image-20240226180456350"></p>
<p> equals：判断两个对象是否相等。&#x2F;&#x2F;返回一个布尔类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">== 的作用：</span><br><span class="line"></span><br><span class="line">　　基本类型：比较的就是值是否相同</span><br><span class="line"></span><br><span class="line">　　引用类型：比较的就是地址值是否相同</span><br><span class="line">　　</span><br><span class="line">equals 的作用:</span><br><span class="line"></span><br><span class="line">　　引用类型：默认情况下，比较的是地址值。</span><br><span class="line"></span><br><span class="line">注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同</span><br><span class="line">String类中被复写的equals()方法其实是比较两个字符串的内容</span><br></pre></td></tr></table></figure>



<h4 id="④现阶段Object类中需要了解的方法："><a href="#④现阶段Object类中需要了解的方法：" class="headerlink" title="④现阶段Object类中需要了解的方法："></a>④现阶段Object类中需要了解的方法：</h4><p> hashCode：返回一个对象的哈希值，通常作为在哈希表中查找该对象的键值。Object类的默认实现是根据对象的内存地址生成一个哈希码（即将对象的内存地址转换为整数作为哈希值）。hashCode()方法是为了HashMap、Hashtable、HashSet等集合类进行优化而设置的，以便更快地查找和存储对象。</p>
<p> finalize：当java对象被回收时，由GC自动调用被回收对象的finalize方法，通常在该方法中完成销毁前的准备。</p>
<h5 id="clone：对象的拷贝。（浅拷贝，深拷贝）"><a href="#clone：对象的拷贝。（浅拷贝，深拷贝）" class="headerlink" title="&#x3D;&#x3D;clone：对象的拷贝。（浅拷贝，深拷贝）&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;clone：对象的拷贝。（浅拷贝，深拷贝）&#x3D;&#x3D;</strong></h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/87217229">Java深入理解深拷贝和浅拷贝区别_java深拷贝浅拷贝-CSDN博客</a></p>
<h6 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝:"></a>浅拷贝:</h6><blockquote>
<p>Object的默认方法,专门给子类使用的,受保护的,c++实现的</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226181415375.png" alt="image-20240226181415375"></p>
<blockquote>
<p>user和usertest不符合三个要求,不能进行clone,那么怎么实现呢?</p>
<p>重写!</p>
<p>1.<strong>&#x3D;&#x3D;建议把重写的修饰符改为public&#x3D;&#x3D;</strong></p>
<p>2.要实现接口 <strong>&#x3D;&#x3D;implements Cloneable&#x3D;&#x3D;</strong>(这是一个标志接口,给java虚拟机看的)</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226181815569.png" alt="image-20240226181815569"></p>
<p>  protected修饰的只能在同一个包下或者子类中访问。</p>
<p> 只有实现了Cloneable接口的对象才能被克隆。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226182500898.png" alt="image-20240226182500898"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226182936458.png" alt="image-20240226182936458"></p>
<h6 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝:"></a>深拷贝:</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是浅拷贝</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">       <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">super</span>.clone();</span><br><span class="line">       <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//这是深拷贝</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">       <span class="comment">// 浅复制时：</span></span><br><span class="line">       <span class="comment">// Object object = super.clone();</span></span><br><span class="line">       <span class="comment">// return object;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 改为深复制：</span></span><br><span class="line">       <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">       <span class="comment">// 本来是浅复制，现在将Teacher对象复制一份并重新set进来</span></span><br><span class="line">       student.setTeacher((Teacher) student.getTeacher().clone());</span><br><span class="line">       <span class="keyword">return</span> student;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-clone"><a href="#20-clone" class="headerlink" title="20.clone"></a>20.clone</h3><h5 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h5><blockquote>
<p>直接赋值的方式没有生产新的对象，只是生新增了一个对象引用**，直接赋值在 Java 内存中的模型大概是这样的</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226184438712.png" alt="image-20240226184438712"></p>
<h5 id="浅拷贝-1"><a href="#浅拷贝-1" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><blockquote>
<p>如果原型对象的成员变量是值类型，将复制一份给克隆对象，也就是说在堆中拥有独立的空间；</p>
<p>如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p>
<p>换句话说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226184739067.png" alt="image-20240226184739067"></p>
<p>也就是新开一个空间,放克隆的对象,但是这个地址里放的还是原来的引用地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 重写 clone 方法，需要将权限改成 public ，直接调用父类的 clone 方法就好了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略...</span><br><span class="line">&#125;\\</span><br><span class="line">    ***************</span><br><span class="line">person对象：Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">20</span>, email=<span class="string">&#x27;123456@qq.com&#x27;</span>, desc=<span class="string">&#x27;我是张三&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">person1对象：Person&#123;name=<span class="string">&#x27;我是张三的克隆对象&#x27;</span>, age=<span class="number">22</span>, email=<span class="string">&#x27;123456@qq.com&#x27;</span>, desc=<span class="string">&#x27;我是张三&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化一个对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="string">&quot;123456@qq.com&quot;</span>,<span class="string">&quot;我是张三&quot;</span>);</span><br><span class="line">        <span class="comment">// 复制对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person) person.clone();</span><br><span class="line">        <span class="comment">// 改变 person1 的属性值</span></span><br><span class="line">        person1.setName(<span class="string">&quot;我是张三的克隆对象&quot;</span>);</span><br><span class="line">        <span class="comment">// 修改 person age 的值</span></span><br><span class="line">        person1.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person对象：&quot;</span>+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;person1对象：&quot;</span>+person1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String、Integer 等包装类都是不可变的对象，当需要修改不可变对象的值时，需要在内存中生成一个新的对象来存放新的值，然后将原来的引用指向新的地址，所以在这里我们修改了 person1 对象的 name 属性值，person1 对象的 name 字段指向了内存中新的 name 对象，</p>
<p>但是我们并没有改变 person 对象的 name 字段的指向，所以 person 对象的 name 还是指向内存中原来的 name 地址，也就没有变化</p>
<h5 id="深拷贝-1"><a href="#深拷贝-1" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>深拷贝也是对象克隆的一种方式，相对于浅拷贝，<strong>深拷贝是一种完全拷贝，无论是值类型还是引用类型都会完完全全的拷贝一份，在内存中生成一个新的对象</strong>，简单点说就是拷贝对象和被拷贝对象没有任何关系，互不影响。深拷贝的通用模型如下</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/v2-cb4cb526cc8a637848ad2ad176d50d40_720w.webp" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDesc</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    ...省略...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * clone 方法不是简单的调用super的clone 就好，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)<span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">// 需要将引用对象也克隆一次</span></span><br><span class="line">        person.personDesc = (PersonDesc) personDesc.clone();</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-内部类"><a href="#21-内部类" class="headerlink" title="21.内部类"></a>21.内部类</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226185936183.png" alt="image-20240226185936183"></p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类:"></a>静态内部类:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于静态内部类来说：访问控制权限修饰符在这里都可以使用。</span><br><span class="line">private static class InnerClass&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//怎么创建内部类对象</span><br><span class="line">OuterClass.InnerClass innerClass = new OuterClass.InnerClass();</span><br><span class="line">OuterClass.InnerClass.m4();</span><br><span class="line">innerClass.m3();</span><br></pre></td></tr></table></figure>

<p>由于在创建静态内部类的时候,不用创建外部的那个类,所以不能访问外部类所定义的实例变量和实例方法,但是可以访问静态变量和静态方法,因为静态的(static)是刚开始运行的时候就会跑的,写入编译文件中的</p>
<h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 实例内部类：等同可以看做实例变量。</span><br><span class="line">* 结论：实例内部类中可以直接访问外部类中实例成员和静态成员。</span><br><span class="line">就是在创建这个实例内部类中,会创建外部类//自己的理解</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的实例方法m1执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的静态方法m2执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例内部类</span></span><br><span class="line">    <span class="comment">// 也可以使用访问权限修饰符修饰。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">x</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(j);</span><br><span class="line">            m1();</span><br><span class="line">            m2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        System.out.println(outerClass.i);</span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.x();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><blockquote>
<p>①局部内部类：和局部变量一个级别</p>
<p>局部内部类方外类外部的局部变量时，局部变量需要被final修饰。</p>
<p>从JDK8开始，不需要手动添加final了，但JVM会自动添加。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">            <span class="comment">// 实例方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">x</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(k);</span><br><span class="line">                System.out.println(f);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new对象</span></span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.x();</span><br><span class="line">        <span class="comment">//这两行执行了,这个内部类就要执行,内部类执行就需要这个实例方法执行,这个实例方法执行,就要这个外部类创建,所以在不受限制的情况下,实例变量/方法和静态变量/方法是都可以访问的,但是不可以改,是默认加final的 </span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 局部内部类：等同于局部变量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：局部内部类能不能访问外部类的数据，取决于局部内部类所在的方法。</span></span><br><span class="line"><span class="comment"> * 如果这个方法是静态的：只能访问外部类中静态的。</span></span><br><span class="line"><span class="comment"> * 如果这个方法是实例的：可以都访问。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 局部内部类不能使用访问权限修饰符修饰。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 局部内部类在访问外部的局部变量时，这个局部变量必须是final的。只不过从JDK8开始。这个final关键字不需要提供了。系统自动提供。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="&#x3D;&#x3D;匿名内部类&#x3D;&#x3D;"></a>&#x3D;&#x3D;匿名内部类&#x3D;&#x3D;</h4><p><strong>特殊的局部内部类，没有名字，只能用一次。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.javase.oop45;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匿名内部类：没有名字的类。只能使用一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建电脑对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">//computer.conn(new Printer());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下conn方法参数上的代码做了两件事：</span></span><br><span class="line">        <span class="comment">// 第一：完成了匿名内部类的定义。</span></span><br><span class="line">        <span class="comment">// 第二：同时实例化了一个匿名内部类的对象。</span></span><br><span class="line">        computer.conn(<span class="keyword">new</span> <span class="title class_">Usb</span>()&#123;</span><br><span class="line">            <span class="comment">// 接口的实现</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;read.....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;write.....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conn</span><span class="params">(Usb usb)</span>&#123;</span><br><span class="line">        usb.read();</span><br><span class="line">        usb.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个接口的实现类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Printer implements Usb &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void read() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;打印机开始读取数据&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void write() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;打印机开始打印&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/02/23/SpringBoot/" rel="prev" title="SpringBoot">
                  <i class="fa fa-angle-left"></i> SpringBoot
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/02/26/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/" rel="next" title="Java基础部分3">
                  Java基础部分3 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">lolo</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
