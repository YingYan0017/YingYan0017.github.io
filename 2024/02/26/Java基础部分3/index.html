<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="数组数组概述①什么是数组？1.在Java中，数组是一种用于存储多个相同数据类型元素的容器。 2.例如一个存储整数的数组：int[] nums &#x3D; {100, 200, 300}; 3.例如一个存储字符串的数组：String[] names &#x3D; {“jack”,“lucy”,“lisi”}; 4.数组是一种引用数据类型，隐式继承Object。因此数组也可以调用Object类中的方">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础部分3">
<meta property="og:url" content="http://example.com/2024/02/26/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/index.html">
<meta property="og:site_name" content="Loloooo">
<meta property="og:description" content="数组数组概述①什么是数组？1.在Java中，数组是一种用于存储多个相同数据类型元素的容器。 2.例如一个存储整数的数组：int[] nums &#x3D; {100, 200, 300}; 3.例如一个存储字符串的数组：String[] names &#x3D; {“jack”,“lucy”,“lisi”}; 4.数组是一种引用数据类型，隐式继承Object。因此数组也可以调用Object类中的方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227110419147.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227111451718.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227111729307.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227112624635.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227112947509.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122020670.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122031704.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122037930.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122045388.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122051856.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122056862.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227123624933.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227123922794.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227133137828.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227133302806.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227140425131.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227140431623.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227141452414.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227141713987.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227143030302.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227152502694.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227152745145.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227153843258.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227154130653.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227213044733.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227213351296.png">
<meta property="og:image" content="http://example.com/2024/02/26/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227213539958.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227214002828.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227214340480.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227215936922.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227154550203.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227193208940.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227195325953.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227202458188.png">
<meta property="og:image" content="http://example.com/2024/02/26/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204034015.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204118497.png">
<meta property="og:image" content="http://example.com/2024/02/26/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204222677.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204622761.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204749867.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227210701818.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227210824500.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227211247488.png">
<meta property="og:image" content="http://example.com/2024/02/26/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227211841286.png">
<meta property="og:image" content="http://example.com/2024/02/26/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227212157813.png">
<meta property="og:image" content="http://example.com/2024/02/26/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227220453859.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227222910252.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228101346290.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228101801236.png">
<meta property="og:image" content="http://example.com/2024/02/26/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228102517804.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228102834512.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228111527964.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228111945428.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228112019609.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228112206054.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228113359145.png">
<meta property="article:published_time" content="2024-02-26T11:42:11.000Z">
<meta property="article:modified_time" content="2024-02-28T03:53:36.949Z">
<meta property="article:author" content="lolo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227110419147.png">


<link rel="canonical" href="http://example.com/2024/02/26/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/02/26/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/","path":"2024/02/26/Java基础部分3/","title":"Java基础部分3"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java基础部分3 | Loloooo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Loloooo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">数组概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">①什么是数组？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">②数组的分类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2Java%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">③Java数组存储元素的特点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E6%95%B0%E7%BB%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">①数组优点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E6%95%B0%E7%BB%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">②数组缺点？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.</span> <span class="nav-text">一维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%98%AF%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E3%80%82%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%8C%E4%B8%89%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E6%98%AF%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E3%80%82"><span class="nav-number">1.2.1.</span> <span class="nav-text">①一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%A6%82%E4%BD%95%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">②如何静态初始化一维数组？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">③如何访问数组中的元素？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">④如何遍历数组？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="nav-number">1.2.5.</span> <span class="nav-text">⑤如何动态初始化一维数组？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A5%E6%96%B9%E6%B3%95%E5%9C%A8%E8%B0%83%E7%94%A8%E6%97%B6%E5%A6%82%E4%BD%95%E7%BB%99%E6%96%B9%E6%B3%95%E4%BC%A0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">1.2.6.</span> <span class="nav-text">⑥方法在调用时如何给方法传一个数组对象？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A6%E5%BD%93%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AD%98%E5%82%A8%E5%BC%95%E7%94%A8%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE%EF%BC%9F"><span class="nav-number">1.2.7.</span> <span class="nav-text">⑦当一维数组中存储引用时的内存图？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A7%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%9F"><span class="nav-number">1.2.8.</span> <span class="nav-text">⑧如何获取数组中的最大值？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A8%E5%A6%82%E6%9E%9C%E7%9F%A5%E9%81%93%E5%80%BC%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%80%BC%E6%89%BE%E5%AE%83%E7%9A%84%E4%B8%8B%E6%A0%87%EF%BC%9F"><span class="nav-number">1.2.9.</span> <span class="nav-text">⑨如果知道值，如何通过值找它的下标？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A9%E5%A6%82%E4%BD%95%E5%B0%86%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%8F%8D%E8%BD%AC%EF%BC%9F"><span class="nav-number">1.2.10.</span> <span class="nav-text">⑩如何将数组中的所有元素反转？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%95%B0%E7%BB%84%E3%80%82"><span class="nav-number">1.2.10.1.</span> <span class="nav-text">第一种方式：创建一个新的数组。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E9%A6%96%E5%B0%BE%E4%BA%A4%E6%8D%A2%E3%80%82"><span class="nav-number">1.2.10.2.</span> <span class="nav-text">第二种方式：首尾交换。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%BE%E5%85%B3%E4%BA%8Emain%E6%96%B9%E6%B3%95%E7%9A%84%E5%BD%A2%E5%8F%82args%EF%BC%9F"><span class="nav-number">1.2.11.</span> <span class="nav-text">⑾关于main方法的形参args？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%BF%E5%85%B3%E4%BA%8E%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-number">1.2.12.</span> <span class="nav-text">⑿关于方法的可变长度参数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%92%80%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="nav-number">1.2.13.</span> <span class="nav-text">⒀一维数组的扩容</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.</span> <span class="nav-text">二维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%98%AF%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%8C%E7%89%B9%E6%AE%8A%E5%9C%A8%EF%BC%9A%E8%BF%99%E4%B8%AA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E4%B8%80%E4%B8%AA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%88%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%AD%98%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%98%AF%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%A6%96%E4%BD%8D%E5%9C%B0%E5%9D%80%EF%BC%89%E3%80%82"><span class="nav-number">1.3.1.</span> <span class="nav-text">①二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组（相当于存的还是一个地址，是一维数组的首位地址）。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.2.</span> <span class="nav-text">②二维数组的静态初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%AD%89%E9%95%BF"><span class="nav-number">1.3.3.</span> <span class="nav-text">③二维数组的动态初始化(等长)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%B8%8D%E7%AD%89%E9%95%BF%EF%BC%89"><span class="nav-number">1.3.4.</span> <span class="nav-text">④二维数组的动态初始化（不等长）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">1.3.5.</span> <span class="nav-text">⑤二维数组中元素的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A5%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">1.3.6.</span> <span class="nav-text">⑥二维数组中元素的遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IDEA%E7%9A%84Debug"><span class="nav-number">1.4.</span> <span class="nav-text">IDEA的Debug</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">1.5.</span> <span class="nav-text">单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="nav-number">1.5.1.</span> <span class="nav-text">①什么是单元测试，为什么要进行单元测试？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%81%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5JUnit%E6%A1%86%E6%9E%B6%EF%BC%8CJUnit%E6%A1%86%E6%9E%B6%E5%9C%A8JDK%E4%B8%AD%E6%B2%A1%E6%9C%89%EF%BC%8C%E9%9C%80%E8%A6%81%E9%A2%9D%E5%A4%96%E5%BC%95%E5%85%A5%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%BC%95%E5%85%A5JUnit%E6%A1%86%E6%9E%B6%E7%9A%84class%E6%96%87%E4%BB%B6%EF%BC%88jar%E5%8C%85%EF%BC%89"><span class="nav-number">1.5.2.</span> <span class="nav-text">②做单元测试需要引入JUnit框架，JUnit框架在JDK中没有，需要额外引入，也就是引入JUnit框架的class文件（jar包）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%B1%BB%EF%BC%88%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%EF%BC%89%E6%80%8E%E4%B9%88%E5%86%99%EF%BC%9F"><span class="nav-number">1.5.3.</span> <span class="nav-text">③单元测试类（测试用例）怎么写？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%80%8E%E4%B9%88%E5%86%99%EF%BC%9F"><span class="nav-number">1.5.4.</span> <span class="nav-text">④单元测试方法怎么写？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%9F%E6%9C%9B%E5%80%BC%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9E%E9%99%85%E5%80%BC%EF%BC%9F"><span class="nav-number">1.5.5.</span> <span class="nav-text">⑤什么是期望值，什么是实际值？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A5%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="nav-number">1.5.6.</span> <span class="nav-text">⑥常见注解：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A6%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E4%BD%BF%E7%94%A8Scanner%E5%A4%B1%E6%95%88%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">1.5.7.</span> <span class="nav-text">⑦单元测试中使用Scanner失效怎么办？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.7.</span> <span class="nav-text">Arrays工具类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8Exception"><span class="nav-number">2.</span> <span class="nav-text">异常Exception</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">异常概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">2.1.1.</span> <span class="nav-text">①什么是异常？有什么用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%BC%82%E5%B8%B8%E5%9C%A8Java%E4%B8%AD%E4%BB%A5%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%9C%A8%E3%80%82"><span class="nav-number">2.1.2.</span> <span class="nav-text">②异常在Java中以类和对象的形式存在。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">异常继承结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0%E6%89%80%E6%9C%89%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E9%83%BD%E6%98%AF%E5%8F%AF%E6%8A%9B%E5%87%BA%E7%9A%84%E3%80%82%E9%83%BD%E7%BB%A7%E6%89%BF%E4%BA%86Throwable%E7%B1%BB%E3%80%82"><span class="nav-number">2.2.1.</span> <span class="nav-text">①所有的异常和错误都是可抛出的。都继承了Throwable类。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1Error%E6%98%AF%E6%97%A0%E6%B3%95%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%8C%E5%87%BA%E7%8E%B0%E5%90%8E%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%9C%EF%BC%9AJVM%E7%BB%88%E6%AD%A2%E3%80%82"><span class="nav-number">2.2.2.</span> <span class="nav-text">②Error是无法处理的，出现后只有一个结果：JVM终止。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2Exception%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%A4%84%E7%90%86%E7%9A%84%E3%80%82"><span class="nav-number">2.2.3.</span> <span class="nav-text">③Exception是可以处理的。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A3Exception%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="nav-number">2.2.4.</span> <span class="nav-text">④Exception的分类：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A4%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">2.2.5.</span> <span class="nav-text">⑤编译时异常和运行时异常区别：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">2.3.</span> <span class="nav-text">自定义异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#step1%EF%BC%9A%E7%BB%A7%E6%89%BFException%EF%BC%88%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%EF%BC%89-RuntimeException"><span class="nav-number">2.3.1.</span> <span class="nav-text">step1：继承Exception（编译时异常）&#x2F;RuntimeException</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#step2-%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E5%86%8D%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E5%B8%A6String-msg%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E5%9C%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-number">2.3.2.</span> <span class="nav-text">step2:   提供一个无参数构造方法，再提供一个带String msg参数的构造方法，在构造方法中调用父类的构造方法。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E5%8C%85%E6%8B%AC%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">2.4.</span> <span class="nav-text">异常的处理包括两种方式：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%A3%B0%E6%98%8E%E5%BC%82%E5%B8%B8%EF%BC%9A%E7%B1%BB%E4%BC%BC%E4%BA%8E%E6%8E%A8%E5%8D%B8%E8%B4%A3%E4%BB%BB%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">1.声明异常：类似于推卸责任的处理方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8%EF%BC%9A%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%A4%84%E7%90%86%E6%8D%95%E6%8D%89%E5%BC%82%E5%B8%B8%EF%BC%88%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-try%E2%80%A6catch%E2%80%A6%E5%85%B3%E9%94%AE%E5%AD%97-%EF%BC%89"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.捕捉异常：真正的处理捕捉异常（真正的处理异常 (try…catch…关键字)）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%9C%A8%E5%A4%84%E7%90%86%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%BA%94%E8%AF%A5%E6%98%AF%EF%BC%9A%E5%A3%B0%E6%98%8E%E5%92%8C%E6%8D%95%E6%8D%89%E8%81%94%E5%90%88%E4%BD%BF%E7%94%A8%E3%80%82"><span class="nav-number">2.4.3.</span> <span class="nav-text">异常在处理的整个过程中应该是：声明和捕捉联合使用。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%8D%95%E6%8D%89%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%A3%B0%E6%98%8E%EF%BC%9F"><span class="nav-number">2.4.4.</span> <span class="nav-text">什么时候捕捉？什么时候声明？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.5.</span> <span class="nav-text">异常的常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finally%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="nav-number">2.5.</span> <span class="nav-text">finally语句块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#finally%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C%E7%9A%84%E3%80%82"><span class="nav-number">2.5.1.</span> <span class="nav-text">finally语句块中的代码是一定会执行的。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finally%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%8D%E8%83%BD%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E9%85%8D%E5%90%88try%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="nav-number">2.5.2.</span> <span class="nav-text">finally语句块不能单独使用，至少需要配合try语句块一起使用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E5%B8%B8%E5%9C%A8finally%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%AD%E5%AE%8C%E6%88%90%E8%B5%84%E6%BA%90%E7%9A%84%E9%87%8A%E6%94%BE"><span class="nav-number">2.5.3.</span> <span class="nav-text">通常在finally语句块中完成资源的释放</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final%E3%80%81finally%E3%80%81finalize%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.5.4.</span> <span class="nav-text">final、finally、finalize分别是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%85%B8%E9%A2%98"><span class="nav-number">2.5.5.</span> <span class="nav-text">面试经典题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1"><span class="nav-number">2.5.5.1.</span> <span class="nav-text">1.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2"><span class="nav-number">2.5.5.2.</span> <span class="nav-text">2.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3"><span class="nav-number">2.5.5.3.</span> <span class="nav-text">3.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4"><span class="nav-number">2.5.5.4.</span> <span class="nav-text">4.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5"><span class="nav-number">2.5.5.5.</span> <span class="nav-text">5.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6"><span class="nav-number">2.5.5.6.</span> <span class="nav-text">6.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="nav-number">2.6.</span> <span class="nav-text">方法覆盖与异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E7%B1%BB-%E6%B3%A8%E6%84%8F-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">String类(注意:引用数据类型)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E5%88%9D%E8%AF%86"><span class="nav-number">3.1.1.</span> <span class="nav-text">String初识</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84String%E5%B1%9E%E4%BA%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BB%A3%E8%A1%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">Java中的String属于引用数据类型，代表字符串。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java%E4%B8%93%E9%97%A8%E5%9C%A8-%E5%A0%86-%E4%B8%AD%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%86%E5%A4%87%E4%BA%86%E4%B8%80%E4%B8%AA-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0-%E3%80%82-JDK8"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">Java专门在&#x3D;&#x3D;堆&#x3D;&#x3D;中为字符串准备了一个&#x3D;&#x3D;字符串常量池&#x3D;&#x3D;。(JDK8)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Java8%E4%B9%8B%E5%90%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%9C%A8%E5%A0%86%E4%B8%AD%E3%80%82Java8%E4%B9%8B%E5%89%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%9C%A8%E6%B0%B8%E4%B9%85%E4%BB%A3%E3%80%82"><span class="nav-number">3.1.1.3.</span> <span class="nav-text">Java8之后字符串常量池在堆中。Java8之前字符串常量池在永久代。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%80%E6%97%A6%E5%88%9B%E5%BB%BA%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E3%80%82%EF%BC%88%E5%BA%95%E5%B1%82String%E6%BA%90%E7%A0%81%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%EF%BC%9Aprivate-final-byte-value-%EF%BC%89"><span class="nav-number">3.1.1.4.</span> <span class="nav-text">字符串字面量一旦创建是不可变的。（底层String源码中有一个属性：private final byte[] value;）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%9A%84%E6%8B%BC%E6%8E%A5"><span class="nav-number">3.1.2.</span> <span class="nav-text">String的拼接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%91%A0%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5%E4%B9%8B%E5%90%8E%E7%9A%84%E6%96%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%94%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%EF%BC%9A"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">①动态拼接之后的新字符串不会自动放到字符串常量池中：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%91%A1%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E6%8B%BC%E6%8E%A5%E4%BC%9A%E5%81%9A%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%8C%E5%9C%A8%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E5%B0%B1%E4%BC%9A%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5%E3%80%82"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">②两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%B1%BB%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%EF%BC%9A"><span class="nav-number">3.1.3.</span> <span class="nav-text">String类常用的构造方法有以下几种：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.4.</span> <span class="nav-text">String的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.1.5.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">3.1.6.</span> <span class="nav-text">&#x3D;&#x3D;String的正则表达式相关的方法：&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">3.1.7.</span> <span class="nav-text">String的面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1"><span class="nav-number">3.1.7.1.</span> <span class="nav-text">1.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1"><span class="nav-number">3.1.7.2.</span> <span class="nav-text">2.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1"><span class="nav-number">3.1.7.3.</span> <span class="nav-text">3.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1"><span class="nav-number">3.1.7.4.</span> <span class="nav-text">4.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1"><span class="nav-number">3.1.7.5.</span> <span class="nav-text">5.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1"><span class="nav-number">3.1.7.6.</span> <span class="nav-text">6.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7"><span class="nav-number">3.1.7.7.</span> <span class="nav-text">7.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8"><span class="nav-number">3.1.7.8.</span> <span class="nav-text">8.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9"><span class="nav-number">3.1.7.9.</span> <span class="nav-text">9.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10"><span class="nav-number">3.1.7.10.</span> <span class="nav-text">10.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer%E4%B8%8EStringBuilder"><span class="nav-number">3.2.</span> <span class="nav-text">StringBuffer与StringBuilder</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer%E5%92%8CStringBuilder%EF%BC%9A%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.2.1.</span> <span class="nav-text">StringBuffer和StringBuilder：可变长度字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer%E5%92%8CStringBuilder%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">StringBuffer和StringBuilder构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer%E5%92%8CStringBuilder%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.3.</span> <span class="nav-text">StringBuffer和StringBuilder常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">3.3.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">3.3.1.</span> <span class="nav-text">什么是包装类？有什么用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%AD%E7%9A%846%E4%B8%AA%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E9%83%BD%E7%BB%A7%E6%89%BF%E4%BA%86Number%E7%B1%BB"><span class="nav-number">3.3.2.</span> <span class="nav-text">包装类中的6个数字类型都继承了Number类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Integer%E7%9A%84%E5%B8%B8%E9%87%8F%EF%BC%88%E4%B8%BA%E4%BE%8B%E5%AD%90%EF%BC%89"><span class="nav-number">3.3.3.</span> <span class="nav-text">Integer的常量（为例子）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Integer%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.4.</span> <span class="nav-text">Integer的构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%91%A0Integer-int-value"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">①Integer(int value)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%91%A1Integer-String-s"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">②Integer(String s)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Integer%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.5.</span> <span class="nav-text">Integer的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java5%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1"><span class="nav-number">3.3.6.</span> <span class="nav-text">Java5新特性：自动装箱和自动拆箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%9E%8B%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">3.3.7.</span> <span class="nav-text">整数型常量池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E5%AD%97"><span class="nav-number">3.4.</span> <span class="nav-text">大数字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A0java%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E7%A7%8D%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9A-java-math-BigInteger-%E3%80%82%E5%AE%83%E7%9A%84%E7%88%B6%E7%B1%BB%E6%98%AF-Number%E3%80%82"><span class="nav-number">3.4.1.</span> <span class="nav-text">①java中提供了一种引用数据类型来解决这个问题：**&#x3D;&#x3D;java.math.BigInteger&#x3D;&#x3D;。它的父类是&#x3D;&#x3D;Number。&#x3D;&#x3D;**</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A1%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9ABigInteger-String-val"><span class="nav-number">3.4.2.</span> <span class="nav-text">②常用构造方法：BigInteger(String val)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%91%A2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">3.4.3.</span> <span class="nav-text">③常用方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%B5%AE%E7%82%B9%E5%9E%8B%E6%95%B0%E6%8D%AE%E8%B6%85%E8%BF%87double%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">3.4.4.</span> <span class="nav-text">如果浮点型数据超过double的最大值怎么办？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">3.4.5.</span> <span class="nav-text">数字格式化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86"><span class="nav-number">3.5.</span> <span class="nav-text">日期处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3API"><span class="nav-number">3.5.1.</span> <span class="nav-text">日期相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E2%91%A0java-util-Calendar-%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">①java.util.Calendar 日历类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java8%E7%9A%84%E6%96%B0%E6%97%A5%E6%9C%9FAPI"><span class="nav-number">3.6.</span> <span class="nav-text">Java8的新日期API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Math"><span class="nav-number">3.7.</span> <span class="nav-text">Math</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">3.8.</span> <span class="nav-text">枚举</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lolo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/26/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java基础部分3 | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础部分3
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-26 19:42:11" itemprop="dateCreated datePublished" datetime="2024-02-26T19:42:11+08:00">2024-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-28 11:53:36" itemprop="dateModified" datetime="2024-02-28T11:53:36+08:00">2024-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java体系知识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h3><h4 id="①什么是数组？"><a href="#①什么是数组？" class="headerlink" title="①什么是数组？"></a>①什么是数组？</h4><p>1.在Java中，数组是一种用于存储多个相同数据类型元素的容器。</p>
<p>2.例如一个存储整数的数组：int[] nums &#x3D; {100, 200, 300};</p>
<p>3.例如一个存储字符串的数组：String[] names &#x3D; {“jack”,“lucy”,“lisi”};</p>
<p>4.数组是一种引用数据类型，隐式继承Object。因此数组也可以调用Object类中的方法。</p>
<p>5.数组对象存储在堆内存中。</p>
<h4 id="②数组的分类？"><a href="#②数组的分类？" class="headerlink" title="②数组的分类？"></a>②数组的分类？</h4><p>1.根据维数进行分类：一维数组，二维数组，三维数组，多维数组。</p>
<p>2.根据数组中存储的元素类型分类：基本类型数组，引用类型数组。</p>
<p>3.根据数组初始化方式不同分类：静态数组，动态数组。</p>
<h4 id="③Java数组存储元素的特点？"><a href="#③Java数组存储元素的特点？" class="headerlink" title="③Java数组存储元素的特点？"></a>③Java数组存储元素的特点？</h4><p>1.数组长度一旦确定不可变。</p>
<p>2.数组中元素数据类型一致，每个元素占用空间大小相同。</p>
<p>3.数组中每个元素在空间存储上，内存地址是连续的。</p>
<p>4.每个元素有索引，首元素索引0，以1递增。</p>
<p>5.以首元素的内存地址作为数组对象在堆内存中的地址。</p>
<p>6.所有数组对象都有length属性用来获取数组元素个数。末尾元素下标：length-1</p>
<h4 id="①数组优点？"><a href="#①数组优点？" class="headerlink" title="①数组优点？"></a>①数组优点？</h4><p><strong>1.根据下标查询某个元素的效率极高。</strong>数组中有100个元素和有100万个元素，查询效率相同。时间复杂度O(1)。也就是说在数组中根据下标查询某个元素时，不管数组的长短，耗费时间是固定不变的。</p>
<p> 原因：<strong>知道首元素内存地址，元素在空间存储上内存地址又是连续的</strong>，每个元素占用空间大小相同，只要知道下标，就可以通过数学表达式计算出来要查找元素的内存地址。直接通过内存地址定位元素。</p>
<h4 id="②数组缺点？"><a href="#②数组缺点？" class="headerlink" title="②数组缺点？"></a>②数组缺点？</h4><p><strong>1.随机增删元素的效率较低。因为随机增删元素时，为了保证数组中元素的内存地址连续，就需要涉及到后续元素的位移问题。时间复杂度O(n)。O(n)表示的是线性阶，随着问题规模n的不断增大，时间复杂度不断增大，算法的执行效率越低。（不过需要注意的是：对数组末尾元素的增删效率是不受影响的。）</strong></p>
<p><strong>2.无法存储大量数据，因为很难在内存上找到非常大的一块连续的内存。</strong></p>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="①一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。"><a href="#①一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。" class="headerlink" title="①一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。"></a>①一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。</h4><h4 id="②如何静态初始化一维数组？"><a href="#②如何静态初始化一维数组？" class="headerlink" title="②如何静态初始化一维数组？"></a>②如何静态初始化一维数组？</h4><p>1.第一种：int[] arr &#x3D; {55,67,22}; 或者 int arr[] &#x3D; {55,67,22};</p>
<p>2.第二种：int[] arr &#x3D; new int[]{55,67,22};</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal[] animals = &#123;a1,a2,<span class="keyword">new</span> <span class="title class_">Animal</span>()&#125;;</span><br><span class="line"><span class="comment">//静态初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="③如何访问数组中的元素？"><a href="#③如何访问数组中的元素？" class="headerlink" title="③如何访问数组中的元素？"></a>③如何访问数组中的元素？</h4><p>1.通过下标来访问。</p>
<p>2.注意ArrayIndexOutOfBoundsException异常的发生。</p>
<h4 id="④如何遍历数组？"><a href="#④如何遍历数组？" class="headerlink" title="④如何遍历数组？"></a>④如何遍历数组？</h4><p>1.普通for循环遍历</p>
<p>2.for-each遍历（优点是代码简洁。缺点是没有下标。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; citys.length;i++)&#123;</span><br><span class="line">	System.out.println(citys[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for each</span></span><br><span class="line"><span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">	System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="⑤如何动态初始化一维数组？"><a href="#⑤如何动态初始化一维数组？" class="headerlink" title="⑤如何动态初始化一维数组？"></a>⑤如何动态初始化一维数组？</h4><blockquote>
<p>在创建数组的时候，不确定具体存储那些数据，但是确定长度（就是开辟空间）</p>
<p>数据类型[] 变量名 &#x3D; new 数据类型[长度]</p>
</blockquote>
<p>1.int[] arr &#x3D; new int[4];</p>
<p>2.Object[] objs &#x3D; new Object[5];</p>
<p>3.数组动态初始化的时候，确定长度，并且数组中每个元素采用默认值。</p>
<h4 id="⑥方法在调用时如何给方法传一个数组对象？"><a href="#⑥方法在调用时如何给方法传一个数组对象？" class="headerlink" title="⑥方法在调用时如何给方法传一个数组对象？"></a>⑥方法在调用时如何给方法传一个数组对象？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   display(a);</span><br><span class="line">display(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)<span class="comment">//error</span></span><br><span class="line">   display(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);<span class="comment">//静态初始化</span></span><br><span class="line">display(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]);<span class="comment">//动态初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="⑦当一维数组中存储引用时的内存图？"><a href="#⑦当一维数组中存储引用时的内存图？" class="headerlink" title="⑦当一维数组中存储引用时的内存图？"></a>⑦当一维数组中存储引用时的内存图？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Animals[] animals = new Animals[5];</span><br><span class="line"></span><br><span class="line">Object[] test = &#123;new Bird(),new Cat()&#125;</span><br><span class="line">public class Animal &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227110419147.png" alt="image-20240227110419147"></p>
<blockquote>
<p>数组中存储的每个元素的空间大小都是一样的，所以空间是不可能一样的，所以是不可能存储引用对象的，所以是存储的是引用（对象在堆内存中的地址）</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227111451718.png" alt="image-20240227111451718"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227111729307.png" alt="image-20240227111729307"></p>
<h4 id="⑧如何获取数组中的最大值？"><a href="#⑧如何获取数组中的最大值？" class="headerlink" title="⑧如何获取数组中的最大值？"></a>⑧如何获取数组中的最大值？</h4><p>​	假设首元素是最大的，然后遍历数组中所有元素，只要有更大的，就将其作为最大值。</p>
<p>​	思考：找出最大值的下标怎么做？</p>
<h4 id="⑨如果知道值，如何通过值找它的下标？"><a href="#⑨如果知道值，如何通过值找它的下标？" class="headerlink" title="⑨如果知道值，如何通过值找它的下标？"></a>⑨如果知道值，如何通过值找它的下标？</h4><h4 id="⑩如何将数组中的所有元素反转？"><a href="#⑩如何将数组中的所有元素反转？" class="headerlink" title="⑩如何将数组中的所有元素反转？"></a>⑩如何将数组中的所有元素反转？</h4><h5 id="第一种方式：创建一个新的数组。"><a href="#第一种方式：创建一个新的数组。" class="headerlink" title="第一种方式：创建一个新的数组。"></a>第一种方式：创建一个新的数组。</h5><p>就是倒着遍历第一个，然后赋值过去</p>
<h5 id="第二种方式：首尾交换。"><a href="#第二种方式：首尾交换。" class="headerlink" title="第二种方式：首尾交换。"></a>第二种方式：首尾交换。</h5><p>就是第一个和倒数第一个交换，以此类推</p>
<h4 id="⑾关于main方法的形参args？"><a href="#⑾关于main方法的形参args？" class="headerlink" title="⑾关于main方法的形参args？"></a>⑾关于main方法的形参args？</h4><p>​	接收命令行参数，</p>
<p>​	JVM 负责调用这个类名.main()方法的</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227112624635.png" alt="image-20240227112624635"></p>
<blockquote>
<p>JVM会把以上字符串以“空格”进行拆分，生成一个新的数组对象</p>
<p>最后这个数组对象是String[] args &#x3D; {“abc”,”def”,”xyz”}</p>
</blockquote>
<p>​	在DOS命令窗口中怎么传？在IDEA中怎么传？</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227112947509.png" alt="image-20240227112947509"></p>
<h4 id="⑿关于方法的可变长度参数？"><a href="#⑿关于方法的可变长度参数？" class="headerlink" title="⑿关于方法的可变长度参数？"></a>⑿关于方法的可变长度参数？</h4><p>​	可变长参数只能出现在形参列表中的最后一个位置。</p>
<p>​	可变长参数可以当做数组来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mi</span><span class="params">(<span class="type">int</span>... nums)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m0; i &lt; nums;i++)&#123;</span><br><span class="line">		System.out.println(nums[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="⒀一维数组的扩容"><a href="#⒀一维数组的扩容" class="headerlink" title="⒀一维数组的扩容"></a>⒀一维数组的扩容</h4><p>①数组长度一旦确定不可变。</p>
<p>②那数组应该如何扩容？</p>
<p>​		<strong>&#x3D;&#x3D;只能创建一个更大的数组将原数组中的数据全部拷贝到新数组中&#x3D;&#x3D;</strong></p>
<p>​		<strong>&#x3D;&#x3D;可以使用System.arraycopy()方法完成数组的拷贝。&#x3D;&#x3D;</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(src,srcpos:<span class="number">0</span>,dest,destpos:<span class="number">0</span>,src.length)<span class="comment">//注意越界问题</span></span><br></pre></td></tr></table></figure>

<p>③数组扩容会影响程序的执行效率，因此尽可能预测数据量，创建一个接近数量的数组，减少扩容次数。</p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="①二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组（相当于存的还是一个地址，是一维数组的首位地址）。"><a href="#①二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组（相当于存的还是一个地址，是一维数组的首位地址）。" class="headerlink" title="①二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组（相当于存的还是一个地址，是一维数组的首位地址）。"></a>①二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组（相当于存的还是一个地址，是一维数组的首位地址）。</h4><h4 id="②二维数组的静态初始化"><a href="#②二维数组的静态初始化" class="headerlink" title="②二维数组的静态初始化"></a>②二维数组的静态初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="③二维数组的动态初始化-等长"><a href="#③二维数组的动态初始化-等长" class="headerlink" title="③二维数组的动态初始化(等长)"></a>③二维数组的动态初始化(等长)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h4 id="④二维数组的动态初始化（不等长）"><a href="#④二维数组的动态初始化（不等长）" class="headerlink" title="④二维数组的动态初始化（不等长）"></a>④二维数组的动态初始化（不等长）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br></pre></td></tr></table></figure>

<h4 id="⑤二维数组中元素的访问"><a href="#⑤二维数组中元素的访问" class="headerlink" title="⑤二维数组中元素的访问"></a>⑤二维数组中元素的访问</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一个元素：arr[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">最后一个元素：arr[arr.length-<span class="number">1</span>][arr[arr.length-<span class="number">1</span>].length-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="⑥二维数组中元素的遍历"><a href="#⑥二维数组中元素的遍历" class="headerlink" title="⑥二维数组中元素的遍历"></a>⑥二维数组中元素的遍历</h4><h3 id="IDEA的Debug"><a href="#IDEA的Debug" class="headerlink" title="IDEA的Debug"></a>IDEA的Debug</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122020670.png" alt="image-20240227122020670"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122031704.png" alt="image-20240227122031704"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122037930.png" alt="image-20240227122037930"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122045388.png" alt="image-20240227122045388"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122051856.png" alt="image-20240227122051856"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122056862.png" alt="image-20240227122056862"></p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227123624933.png" alt="image-20240227123624933"></p>
<h4 id="①什么是单元测试，为什么要进行单元测试？"><a href="#①什么是单元测试，为什么要进行单元测试？" class="headerlink" title="①什么是单元测试，为什么要进行单元测试？"></a>①什么是单元测试，为什么要进行单元测试？</h4><p>1.一个项目是巨大的，只有保证你写的每一块都是正确的，最后整个项目才能正常运行。这里所谓的每一块就是一个单元。</p>
<h4 id="②做单元测试需要引入JUnit框架，JUnit框架在JDK中没有，需要额外引入，也就是引入JUnit框架的class文件（jar包）"><a href="#②做单元测试需要引入JUnit框架，JUnit框架在JDK中没有，需要额外引入，也就是引入JUnit框架的class文件（jar包）" class="headerlink" title="②做单元测试需要引入JUnit框架，JUnit框架在JDK中没有，需要额外引入，也就是引入JUnit框架的class文件（jar包）"></a>②做单元测试需要引入JUnit框架，JUnit框架在JDK中没有，需要额外引入，也就是引入JUnit框架的class文件（jar包）</h4><p>step1：文件目录下新建lib文件夹；</p>
<p>step2：将三个jar包复制进去，</p>
<p>step3：全选右键，Add as library</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227123922794.png" alt="image-20240227123922794"></p>
<h4 id="③单元测试类（测试用例）怎么写？"><a href="#③单元测试类（测试用例）怎么写？" class="headerlink" title="③单元测试类（测试用例）怎么写？"></a>③单元测试类（测试用例）怎么写？</h4><p>1.单元测试类名：XxxTest</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227133137828.png" alt="image-20240227133137828"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227133302806.png" alt="image-20240227133302806"></p>
<h4 id="④单元测试方法怎么写？"><a href="#④单元测试方法怎么写？" class="headerlink" title="④单元测试方法怎么写？"></a>④单元测试方法怎么写？</h4><p>1.单元测试方法需要使用@Test注解标注。</p>
<p>2.单元测试方法返回值类型必须是void</p>
<p>3.单元测试方法形参个数为0 </p>
<p>4.建议单元测试方法名：testXxx</p>
<h4 id="⑤什么是期望值，什么是实际值？"><a href="#⑤什么是期望值，什么是实际值？" class="headerlink" title="⑤什么是期望值，什么是实际值？"></a>⑤什么是期望值，什么是实际值？</h4><p>1.期望值就是在程序执行之前，你觉得正确的输出结果应该是多少</p>
<p>2.实际值就是程序在实际运行之后得到的结果</p>
<h4 id="⑥常见注解："><a href="#⑥常见注解：" class="headerlink" title="⑥常见注解："></a>⑥常见注解：</h4><p>1.@BeforeAll @AfterAll 主要用于在测试开始之前&#x2F;之后执行必要的代码。被标注的方法需要是静态的。</p>
<p>2.@BeforeEach @AfterEach 主要用于在每个测试方法执行前&#x2F;后执行必要的代码。</p>
<h4 id="⑦单元测试中使用Scanner失效怎么办？"><a href="#⑦单元测试中使用Scanner失效怎么办？" class="headerlink" title="⑦单元测试中使用Scanner失效怎么办？"></a>⑦单元测试中使用Scanner失效怎么办？</h4><p>1.选中导航栏的“Help”，然后选中“Edit Custom VM Options…”，接着在“IDEA64.exe.vmoptions”文件中添加内容“-Deditable.java.test.console&#x3D;true”，最后在重启IDEA即可解决</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>跳过</p>
<h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><blockquote>
<p>java.util</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Arrays.toString()方法：将数组转换成字符串</span><br><span class="line"></span><br><span class="line">这个和Object.toString不同，</span><br><span class="line"><span class="comment">/*************************************************/</span></span><br><span class="line">Object.toString()</span><br><span class="line">Arrays.toString(att)<span class="comment">//很显然，这个是一个静态数组</span></span><br><span class="line"><span class="comment">/*************************************************/</span></span><br><span class="line">    </span><br><span class="line">Arrays.deepToString()方法：可以将二维数组转换成字符串</span><br><span class="line"></span><br><span class="line">Arrays.equals(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)方法：判断两个数组是否相等</span><br><span class="line"></span><br><span class="line">Arrays.equals(Object[] arr1, Object[] arr2)方法</span><br><span class="line"></span><br><span class="line">Arrays.deepEquals(Object[] arr1, Object[] arr2)方法：判断两个二维数组是否相等</span><br><span class="line"></span><br><span class="line">Arrays.sort(<span class="type">int</span>[] arr)方法：基于快速排序算法，适合小型数据量排序。</span><br><span class="line"></span><br><span class="line">Arrays.sort(String[] arr)方法</span><br><span class="line"></span><br><span class="line">Arrays.parallelSort(<span class="type">int</span>[] arr)方法：基于分治的归并排序算法，支持多核CPU排序，适合大数据量排序。<span class="comment">//多个线程</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> elt)</span>方法：二分法查找 </span><br><span class="line"></span><br><span class="line">Arrays.fill(<span class="type">int</span>[] arr, <span class="type">int</span> data)方法：填充数组</span><br><span class="line"></span><br><span class="line">Arrays.fill(<span class="type">int</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> val)方法</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] Arrays.copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength)方法：数组拷贝</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="type">int</span>[] arr2 = Arrays.copyOf(arr,newLength:<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝一个范围内的数组，to不包含</span></span><br><span class="line"><span class="type">int</span>[] Arrays.copyOfRange(<span class="type">int</span>[] original, <span class="type">int</span> from, <span class="type">int</span> to)</span><br><span class="line">    </span><br><span class="line">Arrays.asList(T... data)方法：将一组数据转换成List集合。    </span><br></pre></td></tr></table></figure>

<h2 id="异常Exception"><a href="#异常Exception" class="headerlink" title="异常Exception"></a>异常Exception</h2><h3 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h3><h4 id="①什么是异常？有什么用？"><a href="#①什么是异常？有什么用？" class="headerlink" title="①什么是异常？有什么用？"></a>①什么是异常？有什么用？</h4><p>1.Java中的异常是指程序运行时出现了错误或异常情况，导致程序无法继续正常执行的现象。例如，数组下标越界、空指针异常、类型转换异常等都属于异常情况。</p>
<p>2.Java提供了异常处理机制，即在程序中对可能出现的异常情况进行捕捉和处理。异常机制可以帮助程序员更好地管理程序的错误和异常情况，避免程序崩溃或出现不可预测的行为。</p>
<p>3.没有异常机制的话，程序中就可能会出现一些难以调试和预测的异常行为，可能导致程序崩溃，甚至可能造成数据损失或损害用户利益。因此，异常机制是一项非常重要的功能，是编写可靠程序的基础。</p>
<h4 id="②异常在Java中以类和对象的形式存在。"><a href="#②异常在Java中以类和对象的形式存在。" class="headerlink" title="②异常在Java中以类和对象的形式存在。"></a>②异常在Java中以类和对象的形式存在。</h4><p>1.现实生活中也有异常，比如地震，火灾就是异常。也可以提取出类和对象，例如：</p>
<p>1.地震是类：512大地震、唐山大地震就是对象。</p>
<p>2.空指针异常是类：发生在第52行的空指针异常、发生在第100行的空指针异常就是对象。</p>
<p>2.也就是说：在第52行和第100行发生空指针异常的时候，底层一定分别new了一个NullPointerException对象。在程序中异常是如何发生的？</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227140425131.png" alt="image-20240227140425131"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227140431623.png" alt="image-20240227140431623"></p>
<h3 id="异常继承结构"><a href="#异常继承结构" class="headerlink" title="异常继承结构"></a>异常继承结构</h3><h4 id="①所有的异常和错误都是可抛出的。都继承了Throwable类。"><a href="#①所有的异常和错误都是可抛出的。都继承了Throwable类。" class="headerlink" title="①所有的异常和错误都是可抛出的。都继承了Throwable类。"></a>①所有的异常和错误都是可抛出的。都继承了Throwable类。</h4><h4 id="②Error是无法处理的，出现后只有一个结果：JVM终止。"><a href="#②Error是无法处理的，出现后只有一个结果：JVM终止。" class="headerlink" title="②Error是无法处理的，出现后只有一个结果：JVM终止。"></a>②Error是无法处理的，出现后只有一个结果：JVM终止。</h4><h4 id="③Exception是可以处理的。"><a href="#③Exception是可以处理的。" class="headerlink" title="③Exception是可以处理的。"></a>③Exception是可以处理的。</h4><h4 id="④Exception的分类："><a href="#④Exception的分类：" class="headerlink" title="④Exception的分类："></a>④Exception的分类：</h4><p>1.所有的RuntimeException的子类：运行时异常&#x2F;未检查异常(UncheckedException)&#x2F;非受控异常</p>
<p>2.Exception的子类（除RuntimeException之外）：编译时异常&#x2F;检查异常(CheckedException)&#x2F;受控异常</p>
<h4 id="⑤编译时异常和运行时异常区别："><a href="#⑤编译时异常和运行时异常区别：" class="headerlink" title="⑤编译时异常和运行时异常区别："></a>⑤编译时异常和运行时异常区别：</h4><ul>
<li>1.编译时异常特点：在编译阶段必须提前处理，如果不处理编译器报错。</li>
<li>2.运行时异常特点：在编译阶段可以选择处理，也可以不处理，没有硬性要求。</li>
<li>3.编译时异常一般是由外部环境或外在条件引起的，如网络故障、磁盘空间不足、文件找不到等</li>
<li>4.运行时异常一般是由程序员的错误引起的，并且不需要强制进行异常处理</li>
</ul>
<p>注意：编译时异常并不是在编译阶段发生的异常，所有的异常发生都是在运行阶段的，因为每个异常发生都是会new异常对象的，new异常对象只能在运行阶段完成。那为什么叫做编译时异常呢？这是因为这种异常必须在编译阶段提前预处理，如果不处理编译器报错，因此而得名编译时异常。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227141452414.png" alt="image-20240227141452414"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227141713987.png" alt="image-20240227141713987"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NullPointerException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br></pre></td></tr></table></figure>



<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h4 id="step1：继承Exception（编译时异常）-RuntimeException"><a href="#step1：继承Exception（编译时异常）-RuntimeException" class="headerlink" title="step1：继承Exception（编译时异常）&#x2F;RuntimeException"></a>step1：继承Exception（编译时异常）&#x2F;RuntimeException</h4><h4 id="step2-提供一个无参数构造方法，再提供一个带String-msg参数的构造方法，在构造方法中调用父类的构造方法。"><a href="#step2-提供一个无参数构造方法，再提供一个带String-msg参数的构造方法，在构造方法中调用父类的构造方法。" class="headerlink" title="step2:   提供一个无参数构造方法，再提供一个带String msg参数的构造方法，在构造方法中调用父类的构造方法。"></a>step2:   提供一个无参数构造方法，再提供一个带String msg参数的构造方法，在构造方法中调用父类的构造方法。</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227143030302.png" alt="image-20240227143030302"></p>
<h3 id="异常的处理包括两种方式："><a href="#异常的处理包括两种方式：" class="headerlink" title="异常的处理包括两种方式："></a>异常的处理包括两种方式：</h3><h4 id="1-声明异常：类似于推卸责任的处理方式"><a href="#1-声明异常：类似于推卸责任的处理方式" class="headerlink" title="1.声明异常：类似于推卸责任的处理方式"></a>1.声明异常：类似于推卸责任的处理方式</h4><p>在方法定义时使用throws关键字声明异常，**&#x3D;&#x3D;告知调用者，调用这个方法可能会出现异常&#x3D;&#x3D;**。这种处理方式的态度是：如果出现了异常则会抛给调用者来处理。</p>
<p>如果一个异常发生后希望调用者来处理的，使用声明异常（俗话说：交给上级处理）</p>
<p><strong>&#x3D;&#x3D;注意这里是throws，然后在后面需要throw e的时候是没有s的&#x3D;&#x3D;</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> <span class="keyword">throws</span> AException, BException... &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果Exception和Exception都继承了Exception，那么也可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> <span class="keyword">throws</span> XException&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&#x3D;&#x3D;调用者在调用m()方法时，编译器会检测到该方法上用throws声明了异常，表示可能会抛出异常，编译器会继续检测该异常是否为编译时异常，如果为编译时异常则必须在编译阶段进行处理，如果不处理编译器就会报错。&#x3D;&#x3D;</strong></p>
<p><strong>如果所有位置都采用throws，包括main方法的处理态度也是throws，如果运行时出现了异常，最终异常是抛给了main方法的调用者（JVM），JVM则会终止程序的执行。</strong>&#x3D;&#x3D;<strong>因此为了保证程序在出现异常后不被中断，至少main方法不要再使用throws进行声明了。</strong>&#x3D;&#x3D;</p>
<p>发生异常后，在发生异常的位置上，往下的代码是不会执行的，除非进行了异常的捕捉。</p>
<h4 id="2-捕捉异常：真正的处理捕捉异常（真正的处理异常-try…catch…关键字-）"><a href="#2-捕捉异常：真正的处理捕捉异常（真正的处理异常-try…catch…关键字-）" class="headerlink" title="2.捕捉异常：真正的处理捕捉异常（真正的处理异常 (try…catch…关键字)）"></a>2.捕捉异常：真正的处理捕捉异常（真正的处理异常 (try…catch…关键字)）</h4><p>在可能出现异常的代码上使用try..catch进行捕捉处理。这种处理方式的态度是：把异常抓住。其它方法如果调用这个方法，对于调用者来说是不知道这个异常发生的。因为这个异常被抓住并处理掉了。</p>
<p>如果一个异常发生后，不需要调用者知道，也不需要调用者来处理，选择使用捕捉方式处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 尝试执行可能会出现异常的代码</span></span><br><span class="line"><span class="comment">// try块中的代码如果执行出现异常，出现异常的位置往下的代码是不会执行的，直接进入catch块执行</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(AException e)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到AException类型的异常，在这里处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(BException e)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到BException类型的异常，在这里处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XException e)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到XException类型的异常，在这里处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当try..catch..将所有发生的异常捕捉后，这里的代码是会继续往下执行的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 尝试执行可能会出现异常的代码</span></span><br><span class="line"><span class="comment">// try块中的代码如果执行出现异常，出现异常的位置往下的代码是不会执行的，直接进入catch块执行</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(AException e|BException e2)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到AException类型的异常，在这里处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XException e)&#123;</span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure>

<p>catch可以写多个。并且遵循自上而下，从小到大。</p>
<p>因为，如果最大的在上面，后面的小的异常都不会抛出了，就会导致异常抛出的不够精确</p>
<h4 id="异常在处理的整个过程中应该是：声明和捕捉联合使用。"><a href="#异常在处理的整个过程中应该是：声明和捕捉联合使用。" class="headerlink" title="异常在处理的整个过程中应该是：声明和捕捉联合使用。"></a>异常在处理的整个过程中应该是：声明和捕捉联合使用。</h4><h4 id="什么时候捕捉？什么时候声明？"><a href="#什么时候捕捉？什么时候声明？" class="headerlink" title="什么时候捕捉？什么时候声明？"></a>什么时候捕捉？什么时候声明？</h4><p>如果**&#x3D;&#x3D;异常发生后需要调用者来处理的，需要调用者知道的，则采用声明方式。&#x3D;&#x3D;**否则采用捕捉。</p>
<h4 id="异常的常用方法"><a href="#异常的常用方法" class="headerlink" title="异常的常用方法"></a>异常的常用方法</h4><p> 获取异常的简单描述信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	exception.getMessage();</span><br><span class="line">	</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 尝试执行可能会出现异常的代码</span></span><br><span class="line"><span class="comment">// try块中的代码如果执行出现异常，出现异常的位置往下的代码是不会执行的，直接进入catch块执行</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(AException e)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到AException类型的异常，在这里处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(BException e)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到BException类型的异常，在这里处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XException e)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line">    System.out.println(message);</span><br><span class="line"><span class="comment">// 如果捕捉到XException类型的异常，在这里处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>         获取的message是通过构造方法创建异常对象时传递过去的message。
</code></pre>
<p> 打印异常堆栈信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception.printStackTrace();</span><br></pre></td></tr></table></figure>

<p> 要会看异常的堆栈信息：</p>
<p>​			异常信息的打印是符合栈数据结构的。</p>
<p>​			看异常信息主要看最开始的描述信息。看栈顶信息。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227152502694.png" alt="image-20240227152502694"></p>
<h3 id="finally语句块"><a href="#finally语句块" class="headerlink" title="finally语句块"></a>finally语句块</h3><h4 id="finally语句块中的代码是一定会执行的。"><a href="#finally语句块中的代码是一定会执行的。" class="headerlink" title="finally语句块中的代码是一定会执行的。"></a>finally语句块中的代码是一定会执行的。</h4><h4 id="finally语句块不能单独使用，至少需要配合try语句块一起使用："><a href="#finally语句块不能单独使用，至少需要配合try语句块一起使用：" class="headerlink" title="finally语句块不能单独使用，至少需要配合try语句块一起使用："></a>finally语句块不能单独使用，至少需要配合try语句块一起使用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>...<span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span></span><br></pre></td></tr></table></figure>

<h4 id="通常在finally语句块中完成资源的释放"><a href="#通常在finally语句块中完成资源的释放" class="headerlink" title="通常在finally语句块中完成资源的释放"></a>通常在finally语句块中完成资源的释放</h4><p>资源释放的工作比较重要，如果资源没有释放会一直占用内存。</p>
<p>为了保证资源的关闭，也就是说：不管程序是否出现异常，关闭资源的代码一定要保证执行。</p>
<p>因此在finally语句块中通常进行资源的释放。</p>
<h4 id="final、finally、finalize分别是什么？"><a href="#final、finally、finalize分别是什么？" class="headerlink" title="final、finally、finalize分别是什么？"></a>final、finally、finalize分别是什么？</h4><p>final是一个关键字，修饰的类无法继承，修饰的方法无法覆盖，修饰的变量不能修改。</p>
<p>finally是一个关键字，和try一起使用，finally语句块中的代码一定会执行。\</p>
<p>finalize是一个标识符，它是Object类中的一个方法名。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227152745145.png" alt="image-20240227152745145"></p>
<blockquote>
<p>innotnull</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227153843258.png" alt="image-20240227153843258"></p>
<h4 id="面试经典题"><a href="#面试经典题" class="headerlink" title="面试经典题"></a>面试经典题</h4><h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227154130653.png" alt="image-20240227154130653"></h5><blockquote>
<p>i为多少? 答:100</p>
<p>原因: </p>
<p>两个原则,(1)程序是自上而下执行的,(2)finally肯定是要执行的</p>
<p>所以,i返回的是100,但是会新建一个临时变量去执行i++</p>
<p>执行流程是先用一个临时变量做i++;然后做return,所以如果是return true;返回的就是true</p>
</blockquote>
<h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227213044733.png" alt="image-20240227213044733"></h5><blockquote>
<p>false:从上往下,finally一定会在最后执行</p>
</blockquote>
<h5 id="3"><a href="#3" class="headerlink" title="3."></a>3.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227213351296.png" alt="image-20240227213351296"></h5><blockquote>
<p>执行下一个</p>
<p>原则:就近原则(从继承关系的角度上讲)</p>
<p>null引用类型,距离String更近,String是Object的子类</p>
</blockquote>
<h5 id="4"><a href="#4" class="headerlink" title="4."></a>4.<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227213539958.png" alt="image-20240227213539958" style="zoom:200%;" /></h5><h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227214002828.png" alt="image-20240227214002828"></h5><blockquote>
<p>常理来说:a&#x3D;&#x3D;10;</p>
<p>因为static块是在类加载的时候运行的,最先运行的,按照顺序运行的.</p>
<p>在创建static int a的时候,(method这个方法还没有运行到???运行到了吗),b还没有赋值,默认值0.所以a没有被这个方法成功赋值,此外,由于静态变量即使不赋值也会赋值默认值,所以赋值了0</p>
</blockquote>
<h5 id="6"><a href="#6" class="headerlink" title="6."></a>6.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227214340480.png" alt="image-20240227214340480"></h5><blockquote>
<p>代码的执行顺序</p>
<p>我答:答不出来一点</p>
<p>答案:</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227215936922.png" alt="image-20240227215936922"></p>
</blockquote>
<p>所以static不是一定要在这个B使用之前就跑了,就想B的静态代码就是最后跑的,但是此刻已经实现了new B()</p>
<h3 id="方法覆盖与异常"><a href="#方法覆盖与异常" class="headerlink" title="方法覆盖与异常"></a>方法覆盖与异常</h3><p>方法重写之后，不能比父类方法抛出更多的异常，可以更少。</p>
<p>就比如父类抛的是一个RuntimeExceptipn ,子类不能抛Exception</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227154550203.png" alt="image-20240227154550203"></p>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="String类-注意-引用数据类型"><a href="#String类-注意-引用数据类型" class="headerlink" title="String类(注意:引用数据类型)"></a>String类(注意:引用数据类型)</h3><h4 id="String初识"><a href="#String初识" class="headerlink" title="String初识"></a>String初识</h4><blockquote>
<p>String类是无法继承的;</p>
<p>jdk9 之后引入了一种字符串压缩机制</p>
</blockquote>
<h5 id="Java中的String属于引用数据类型，代表字符串。"><a href="#Java中的String属于引用数据类型，代表字符串。" class="headerlink" title="Java中的String属于引用数据类型，代表字符串。"></a>Java中的String属于引用数据类型，代表字符串。</h5><h5 id="Java专门在-堆-中为字符串准备了一个-字符串常量池-。-JDK8"><a href="#Java专门在-堆-中为字符串准备了一个-字符串常量池-。-JDK8" class="headerlink" title="Java专门在&#x3D;&#x3D;堆&#x3D;&#x3D;中为字符串准备了一个&#x3D;&#x3D;字符串常量池&#x3D;&#x3D;。(JDK8)"></a>Java专门在&#x3D;&#x3D;堆&#x3D;&#x3D;中为字符串准备了一个&#x3D;&#x3D;字符串常量池&#x3D;&#x3D;。(JDK8)</h5><blockquote>
<p>因为字符串使用比较频繁，放在字符串常量池中省去了对象的创建过程，从而提高程序的执行效率。（常量池属于一种缓存技术，缓存技术是提高程序执行效率的重要手段。）</p>
</blockquote>
<p>在编译阶段,就会把” “起来的字符串全部创建到字符串常量池里面(必须要有一份),然后用的时候直接拿</p>
<p>JVM在启动的时候,会进行一系列的初始化,其中就包括字符串常量池的初始化会在类加载的过程中就初始化出来了,程序在真正运行中,是不用创建字符串对象的&#x2F;&#x2F; <em>一种缓存技术</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> “hello”; </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> “hello”;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true 说明s1和s2指向了字符串常量池中的同一个字符串对象。</span></span><br><span class="line">注意：字符串字面量在编译的时候就已经确定了将其放到字符串常量池中。JVM启动时会立即程序中带有双引号的字符串全部放入字符串常量池。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Java8之后字符串常量池在堆中。Java8之前字符串常量池在永久代。"><a href="#Java8之后字符串常量池在堆中。Java8之前字符串常量池在永久代。" class="headerlink" title="Java8之后字符串常量池在堆中。Java8之前字符串常量池在永久代。"></a>Java8之后字符串常量池在堆中。Java8之前字符串常量池在永久代。</h5><h5 id="字符串字面量一旦创建是不可变的。（底层String源码中有一个属性：private-final-byte-value-）"><a href="#字符串字面量一旦创建是不可变的。（底层String源码中有一个属性：private-final-byte-value-）" class="headerlink" title="字符串字面量一旦创建是不可变的。（底层String源码中有一个属性：private final byte[] value;）"></a>字符串字面量一旦创建是不可变的。（底层String源码中有一个属性：private final byte[] value;）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> “hello”; 其中“hello”存储在字符串常量池中。</span><br></pre></td></tr></table></figure>

<p>“hello”不可变。不能变成“hello123”。如果进行字符串拼接，必然创建新的字符串对象。<br>是 “hello”不可变，不是s不可变，s可以指向其它的字符串对象：s &#x3D; “xyz”;</p>
<blockquote>
<p>从底层源码看,底层String源码中有一个属性：private final byte[] value;底层是个byte[]数组,数组长度不可变,所以长度不可变,</p>
<p>此外,这个数组是用private final修饰的,所以这个变量不可以被访问和继承修改</p>
<p>所以String的字面量一旦创建不可变</p>
<p>StringBuilder是可变的字符串数组,它的底层是byte[] value,所以可以改变,可以创建一个更大的数组,然后这个value就可以指向新的数组</p>
</blockquote>
<h4 id="String的拼接"><a href="#String的拼接" class="headerlink" title="String的拼接"></a>String的拼接</h4><h5 id="①动态拼接之后的新字符串不会自动放到字符串常量池中："><a href="#①动态拼接之后的新字符串不会自动放到字符串常量池中：" class="headerlink" title="①动态拼接之后的新字符串不会自动放到字符串常量池中："></a>①动态拼接之后的新字符串不会自动放到字符串常量池中：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> “abc”;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> “def”;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> “abcdef”;</span><br></pre></td></tr></table></figure>

<p><strong>&#x3D;&#x3D;5.System.out.println(s3 &#x3D;&#x3D; s4); &#x2F;&#x2F; false 说明拼接后的字符串并没有放到字符串常量池&#x3D;&#x3D;</strong></p>
<p>&#x3D;&#x3D;<strong>6.以上程序中字符串常量中有三个： “abc” “def” “abcdef”</strong>&#x3D;&#x3D; </p>
<p>&#x3D;&#x3D;<strong>7.以上程序中除了字符串常量池的字符串之外，在堆中还有一个字符串对象 “abcdef”</strong>&#x3D;&#x3D;</p>
<h5 id="②两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。"><a href="#②两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。" class="headerlink" title="②两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。"></a>②两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> “aaa” + “bbb”;</span><br></pre></td></tr></table></figure>

<p>以上程序会在编译阶段进行拼接，因此以上程序在字符串常量池中只有一个： “aaabbb”</p>
<blockquote>
<p>常量池可以改变吗?</p>
<p>可以,语句:s3.intern()</p>
<p>但是我们不能去删除常量池中的内容,系统自己有一些调整的操作</p>
<p>此时,s4和s5都在字符串常量池中</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227193208940.png" alt="image-20240227193208940"></p>
<h4 id="String类常用的构造方法有以下几种："><a href="#String类常用的构造方法有以下几种：" class="headerlink" title="String类常用的构造方法有以下几种："></a>String类常用的构造方法有以下几种：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="type">char</span>[] value)：<span class="comment">//根据字符数组创建一个新的字符串对象。</span></span><br><span class="line">String(<span class="type">char</span>[] value, <span class="type">int</span> offset, <span class="type">int</span> count)：<span class="comment">//根据字符数组的指定部分创建一个新的字符串对象。</span></span><br><span class="line">String(<span class="type">byte</span>[] bytes)：<span class="comment">//根据字节数组创建一个新的字符串对象，默认使用平台默认的字符集进行解码。</span></span><br><span class="line">String(<span class="type">byte</span>[] bytes, <span class="type">int</span> offset, <span class="type">int</span> length)：<span class="comment">//根据字节数组的指定部分创建一个新的字符串对象，默认使用平台默认的字符集进行解码。</span></span><br><span class="line">String(<span class="type">byte</span>[] bytes, Charset charset)：</span><br><span class="line"><span class="comment">//根据字节数组和指定的字符集创建一个新的字符串对象。</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(bytes, Charset.defaultCharset());</span><br><span class="line">String(<span class="type">byte</span>[] bytes, String charsetName)：</span><br><span class="line"><span class="comment">//根据字节数组和指定的字符集名称创建一个新的字符串对象。</span></span><br><span class="line"><span class="comment">//这是一个解码的过程。你需要提前知道“byte[] bytes”是通过哪个编码方式进行编码得到的。</span></span><br><span class="line"><span class="comment">//如果通过GBK的方式进行编码得到的“byte[] bytes”，调用以上构造方法时采用UTF-8的方式进行解码。就会出现乱码。</span></span><br><span class="line">String(String original)：</span><br><span class="line"><span class="comment">//通过复制现有字符串创建一个新的字符串对象。</span></span><br><span class="line"><span class="comment">//这个方法被@IntrinsicCandidate标注，这个注解的作用是告诉编译器,该方法或构造函数是一个内在的候选方法,可以被优化和替换为更高效的代码。因此它是不建议使用的。</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(“hello”); 这个代码会让常量池中有一个 “hello”，并且在堆中也有有一个String对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[](<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars,offset=<span class="number">1</span>,count=<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">//这是一个解码的过程,也是采用的平台默认的字符集.</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bs2 = <span class="string">&quot;sssssfda&quot;</span>.getBytes(Charset.defaultCharset());</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs2,Charset.defaultCharset());</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs2,StanderCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227195325953.png" alt="image-20240227195325953"></p>
<blockquote>
<p>这样会乱码</p>
</blockquote>
<h4 id="String的常用方法"><a href="#String的常用方法" class="headerlink" title="String的常用方法"></a>String的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>; <span class="comment">//返回索引处的char值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>; <span class="comment">//获取字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; <span class="comment">//判断字符串是否为空字符串，如果length()是0就是空字符串。//</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span>; <span class="comment">//判断两个字符串是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span>; <span class="comment">//判断两个字符串是否相等，忽略大小写。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(CharSequence s)</span>; <span class="comment">//判断当前字符串中是否包含某个子字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span>; <span class="comment">//判断当前字符串是否以某个字符串开头</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span>; <span class="comment">//判断当前字符串是否以某个字符串结尾</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span>; <span class="comment">//两个字符串按照字典顺序比较大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareToIgnoreCase</span><span class="params">(String str)</span>; <span class="comment">//两个字符串按照字典顺序比较大小，比较时忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>;<span class="comment">// 获取当前字符串中str字符串的第一次出现处的下标。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>; <span class="comment">//从当前字符串的fromIndex下标开始往右搜索，获取当前字符串中str字符串的第一次出现处的下标。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span>; <span class="comment">//获取当前字符串中str字符串的最后一次出现处的下标。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>; <span class="comment">//从当前字符串的fromIndex下标开始往左搜索，获取当前字符串中str字符串的最后一次出现处的下标。</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">stripLeading</span><span class="params">()</span>; 去除前空白</span><br><span class="line">String <span class="title function_">stripTrailing</span><span class="params">()</span>; 去除后空白</span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line">String <span class="title function_">intern</span><span class="params">()</span>; 获取字符串常量池中的字符串，如果常量池中没有，则将字符串加入常量池并返回。</span><br><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;; <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// 将字符串 “abcd”放入字符串常量池并返回常量池中的字符串 “abcd”</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">join</span><span class="params">(CharSequence d, CharSequence... elements)</span>; <span class="comment">//将多个字符串以某个分隔符连接（Java8新增）</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">join</span><span class="params">(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span>; <span class="comment">//以下所有的静态方法valueOf作用是将非字符串类型的数据转换为字符串形式。</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span>[] data)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">double</span> d)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">float</span> f)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="type">byte</span>[] getBytes(); <span class="comment">//将字符串转换成字节数组。其实就是对字符串进行编码。默认按照系统默认字符集。</span></span><br><span class="line"><span class="type">byte</span>[] getBytes(String charsetName); <span class="comment">//将字符串按照指定字符集的方式进行编码。</span></span><br><span class="line"><span class="type">byte</span>[] getBytes(Charset charset);</span><br><span class="line"><span class="type">char</span>[] toCharArray(); <span class="comment">//将字符串转换字符数组。</span></span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span>; <span class="comment">//转小写</span></span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span>; <span class="comment">//转大写</span></span><br><span class="line">String <span class="title function_">concat</span><span class="params">(String str)</span>; <span class="comment">//进行字符串的拼接操作。和 + 的区别？</span></span><br><span class="line"><span class="comment">//+ 既可以进行求和，也可以进行字符串的拼接，底层拼接时会创建StringBuilder对象进行拼接。+ 拼接null时不会出现空指针异常。</span></span><br><span class="line"><span class="comment">//concat方法参数只能时字符串类型，拼接时不会创建StringBuilder对象，拼接完成后返回一个新的String对象。拼接null会出现空指针异常。</span></span><br><span class="line"><span class="comment">//+ 使用较多。如果进行大量字符串拼接，这两个都不合适。</span></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>; <span class="comment">//从指定下标beginIndex开始截取子字符串</span></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span>;</span><br><span class="line">String <span class="title function_">trim</span><span class="params">()</span>; <span class="comment">//去除字符串前后空白（只能去除ASCII码中的空格和制表符）</span></span><br><span class="line">String <span class="title function_">strip</span><span class="params">()</span>; <span class="comment">//去除字符串前后空白（支持所有的编码形式的空白，可以将全角空格去除，\u3000是全角空格，Java11新增）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227202458188.png" alt="image-20240227202458188"></p>
<p>前&gt;后;负</p>
<p>前&lt;后;正</p>
<p>相等;0</p>
<blockquote>
<p>右键 show Diagram</p>
</blockquote>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>①正则表达式（regular expression），简称为regex或regexp，是一种用于描述特定模式的表达式。它可以匹配、查找、替换文本中与该模式匹配的内容，被广泛应用于各种文本处理和匹配相关的应用中。</p>
<p>②正则表达式的应用:</p>
<blockquote>
<p>1.验证输入内容的格式是否正确。例如，邮箱，手机号，密码等</p>
<p>2.在文本编辑器中进行搜索和替换。例如，在代码编辑器中查找指定字符串或替换错误的代码成为正确的代码块</p>
<p>3.数据挖掘和信息提取。正则表达式可以从HTML、XML、JSON等格式的数据中提取所需的信息</p>
<p>4.用于编写脚本语言，如awk，grep和sed</p>
<p>5.服务器端编程。正则表达式在处理数据和字符串时具有高效的性能，可以在开发Web应用程序时被广泛应用</p>
</blockquote>
<p>③正则表达式和Java语言的关系？</p>
<p>Java语言中可以使用正则表达式。C语言以及其它大部分编程语言都是支持正则表达式的。</p>
<h4 id="String的正则表达式相关的方法："><a href="#String的正则表达式相关的方法：" class="headerlink" title="&#x3D;&#x3D;String的正则表达式相关的方法：&#x3D;&#x3D;"></a>&#x3D;&#x3D;String的正则表达式相关的方法：&#x3D;&#x3D;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前字符串中所有的target替换成replacement，返回一个新的字符串。</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前字符串中所有符合正则表达式的regex替换成replacement。</span></span><br><span class="line"></span><br><span class="line">String[] split(String regex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前字符串以某个正则表达式表示的子字符串进行分割，返回一个字符串数组。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前字符串是否符合正则表达式regex。</span></span><br></pre></td></tr></table></figure>

<h4 id="String的面试题"><a href="#String的面试题" class="headerlink" title="String的面试题"></a>String的面试题</h4><h5 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h5><img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204034015.png" alt="image-20240227204034015" style="zoom:150%;" />

<blockquote>
<p>false;</p>
<p>true</p>
</blockquote>
<h5 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204118497.png" alt="image-20240227204118497"></h5><blockquote>
<p>true;因为这种拼接会在编译阶段完成，编译器优化策略</p>
<p>true</p>
</blockquote>
<h5 id="3-1"><a href="#3-1" class="headerlink" title="3."></a>3.<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204222677.png" alt="image-20240227204222677" style="zoom:200%;" /></h5><blockquote>
<p>false:yin_yang:这个和上面那个不一样，上面那个是字面量相加，是可以在编译阶段实现，这个是变量，不在编译阶段实现，是存放在堆里的字符串变量；</p>
<p>如果s3.intern（），那就是一样了</p>
<p>true</p>
</blockquote>
<h5 id="4-1"><a href="#4-1" class="headerlink" title="4."></a>4.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204622761.png" alt="image-20240227204622761"></h5><blockquote>
<p>3个对象，a一个b一个，s一个，放在字符串常量区里</p>
</blockquote>
<h5 id="5-1"><a href="#5-1" class="headerlink" title="5."></a>5.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204749867.png" alt="image-20240227204749867"></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串常量池中一个&quot;a&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串常量池中一个&quot;b&quot;,堆中一个s2</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s3--&gt;堆中两个，一个StringBuilder(在拼接的时候自动创建的)，一个string(StringBuilder调用toString转换的)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1+s2</span><br></pre></td></tr></table></figure>

<h5 id="6-1"><a href="#6-1" class="headerlink" title="6."></a>6.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227210701818.png" alt="image-20240227210701818"></h5><blockquote>
<p>字符串常量区：“a”,”b”</p>
<p>堆：new的a一个，new的b一个，拼接生成的StringBuilder一个，调用toString生成的一个String一个</p>
<p>一共6个对象</p>
</blockquote>
<h5 id="7"><a href="#7" class="headerlink" title="7."></a>7.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227210824500.png" alt="image-20240227210824500"></h5><blockquote>
<p>答案：不会出现异常，底层会默认调用valueOf，将非字符串类型的数据转换为字符串形式。结果null</p>
</blockquote>
<h5 id="8"><a href="#8" class="headerlink" title="8."></a>8.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227211247488.png" alt="image-20240227211247488"></h5><blockquote>
<p>没有final的话，false，s3不在字符串常量池里</p>
<p>&#x2F;&#x2F;&#x2F;*********************</p>
<p>true</p>
<p>final修饰后，s2不可变，就是个常量，所以这个拼接是在编译时候完成的，没有创建StringBuilder对象</p>
<p>所以是true</p>
</blockquote>
<h5 id="9"><a href="#9" class="headerlink" title="9."></a>9.<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227211841286.png" alt="image-20240227211841286" style="zoom: 67%;" /></h5><blockquote>
<p>false;</p>
<p>因为getB()是一个方法，只能在运行阶段，不能在编译阶段，所以虽然s2是个常量，但是他不在字符串常量区，在堆里面。</p>
<p>所以s3这个拼接操作也是在运行时候执行的，地址不一样，所以是false</p>
</blockquote>
<h5 id="10"><a href="#10" class="headerlink" title="10."></a>10.<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227212157813.png" alt="image-20240227212157813" style="zoom:67%;" /></h5><blockquote>
<p>false</p>
<p>equals 的前提，两种类型要一样，这俩类型不一样</p>
</blockquote>
<h3 id="StringBuffer与StringBuilder"><a href="#StringBuffer与StringBuilder" class="headerlink" title="StringBuffer与StringBuilder"></a>StringBuffer与StringBuilder</h3><h4 id="StringBuffer和StringBuilder：可变长度字符串"><a href="#StringBuffer和StringBuilder：可变长度字符串" class="headerlink" title="StringBuffer和StringBuilder：可变长度字符串"></a>StringBuffer和StringBuilder：可变长度字符串</h4><img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227220453859.png" alt="image-20240227220453859" style="zoom: 25%;" />

<ul>
<li><p><strong>使用情况：这两个类是专门为频繁进行字符串拼接而准备</strong>。</p>
</li>
<li><p><strong>二者差别：</strong>StringBuffer先出现的，Java5的时候新增了StringBuilder。StringBuffer是线程安全的。在不需要考虑线程安全问题的情况下优先选择StringBuilder，效率较高一些。</p>
</li>
<li><p><strong>底层:</strong>       	是 byte[] 数组，并且这个 byte[] 数组没有被final修饰，这说明如果byte[]数组满了，可以创建一个更大的新数组来达到扩容，然后它可以重新指向这个新的数组对象。</p>
</li>
<li><p><strong>优化策略：</strong>&#x3D;&#x3D;创建StringBuilder对象时，预估计字符串的长度，给定一个合适的初始化容量，减少底层数组的扩容。&#x3D;&#x3D;</p>
</li>
<li><p>StringBuilder默认初始化容量：16</p>
</li>
<li><p>StringBuilder一次扩容多少？可以通过Debug跟踪一下append方法。扩容策略是：从当前容量开始，**&#x3D;&#x3D;每次扩容为原来的2倍再加上2&#x3D;&#x3D;**</p>
</li>
</ul>
<blockquote>
<p>原来是i，扩容后就是2i+2，如果是默认的，就开始2*16+2 ，然后2*（2+16）+2</p>
<p>如果拼接的字符串很大，大于了预期增长值，就会增大到拼接的字符串长度</p>
<p>假如是初始化len:50的字符串：</p>
<p>l16+minCapacity(34)&#x3D;&#x3D;50</p>
<p>34&gt;16+2,所以扩容大小为34</p>
</blockquote>
<p>count 目前真实的存储数量</p>
<h4 id="StringBuffer和StringBuilder构造方法"><a href="#StringBuffer和StringBuilder构造方法" class="headerlink" title="StringBuffer和StringBuilder构造方法"></a>StringBuffer和StringBuilder构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder() <span class="comment">//构造一个字符串生成器，其中不包含任何字符，初始容量为16个字符。</span></span><br><span class="line"></span><br><span class="line">StringBuilder(<span class="type">int</span> capacity) <span class="comment">//构造一个字符串生成器，其中不包含任何字符，并且具有由容量参数指定的初始容量。</span></span><br><span class="line"></span><br><span class="line">StringBuilder(String str)<span class="comment">// 构造初始化为指定字符串内容的字符串生成器</span></span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227222910252.png" alt="image-20240227222910252"></p>
<h4 id="StringBuffer和StringBuilder常用方法"><a href="#StringBuffer和StringBuilder常用方法" class="headerlink" title="StringBuffer和StringBuilder常用方法"></a>StringBuffer和StringBuilder常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder <span class="title function_">append</span><span class="params">(Type data)</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder <span class="title function_">deleteCharAt</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, String str)</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder <span class="title function_">replace</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, String str)</span></span><br><span class="line"></span><br><span class="line">StringBuilder <span class="title function_">reverse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> index, <span class="type">char</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">int</span> newLength)</span>;<span class="comment">//会把已有的数据抹掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start)</span>;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>long begin &#x3D; System.current.TimeMills();</p>
<p>从1970年1月1日 0时0分0秒开始 的总毫秒数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下这种写法尽量避免，效率太低：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> “”;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 优化策略：底层会新建一个StringBuilder对象</span></span><br><span class="line">    <span class="comment">// 然后调用StringBuilder的append(i)方法进行追加</span></span><br><span class="line">    <span class="comment">// 然后再调用StringBuilder toString()方法转成String类型</span></span><br><span class="line">    <span class="comment">// 也就是说：这里会频繁的创建String对象，导致效率很低</span></span><br><span class="line">    <span class="comment">// 同时给GC带来巨大压力。</span></span><br><span class="line">    s += i;</span><br><span class="line">&#125;</span><br><span class="line">因此建议使用下面的方式，只创建一个StringBuilder对象</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228101346290.png" alt="image-20240228101346290"></p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="什么是包装类？有什么用？"><a href="#什么是包装类？有什么用？" class="headerlink" title="什么是包装类？有什么用？"></a>什么是包装类？有什么用？</h4><blockquote>
<p>我的理解，将基础类型进行包装，形成一个引用类型，方便编程</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228101801236.png" alt="image-20240228101801236"></p>
<p>比如在一个函数中，其接受的参数是引用类型(Object)，实际应用起来是对于数字操作的，直接传进去数字是不行的，是会报错的，所以我们把这个int的10，包装成引用类型的10.</p>
<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228102517804.png" alt="image-20240228102517804" style="zoom: 33%;" />

<h4 id="包装类中的6个数字类型都继承了Number类"><a href="#包装类中的6个数字类型都继承了Number类" class="headerlink" title="包装类中的6个数字类型都继承了Number类"></a>包装类中的6个数字类型都继承了Number类</h4><blockquote>
<p>boolean 和character没有继承</p>
</blockquote>
<p>①Byte、Short、Integer、Long、Float、Double都继承了Number类，因此这些类中都有以下这些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">byteValue()</span><br><span class="line">shortValue()</span><br><span class="line">intValue()</span><br><span class="line">longValue()</span><br><span class="line">floatValue()</span><br><span class="line">doubleValue()</span><br></pre></td></tr></table></figure>

<p><strong>&#x3D;&#x3D;这些方法的作用就是将包装类型的数据转换为基本数据类型。&#x3D;&#x3D;</strong></p>
<p>包装类转换成基本数据类型的过程我们称为：&#x3D;&#x3D;<strong>拆箱</strong> <strong>unboxing</strong>&#x3D;&#x3D;</p>
<p><strong>Boolean的拆箱方法：booleanValue();</strong></p>
<p><strong>Character的拆箱方法：charValue();</strong></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228102834512.png" alt="image-20240228102834512"></p>
<h4 id="Integer的常量（为例子）"><a href="#Integer的常量（为例子）" class="headerlink" title="Integer的常量（为例子）"></a>Integer的常量（为例子）</h4><p>①通过Integer提供的常量可以获取int的最大值和最小值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①最大值：Integer.MAX_VALUE</span><br><span class="line"></span><br><span class="line">②最小值：Integer.MIN_VALUE</span><br></pre></td></tr></table></figure>

<p>②当然，其它5个数字包装类也有对应的常量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">①byte最大值：Byte.MAX_VALUE</span><br><span class="line"></span><br><span class="line">②byte最小值：Byte.MIN_VALUE</span><br><span class="line"></span><br><span class="line">③short最大值：Short.MAX_VALUE</span><br><span class="line"></span><br><span class="line">④short最小值：Short.MIN_VALUE</span><br><span class="line"></span><br><span class="line">⑤......</span><br></pre></td></tr></table></figure>

<h4 id="Integer的构造方法"><a href="#Integer的构造方法" class="headerlink" title="Integer的构造方法"></a>Integer的构造方法</h4><h5 id="①Integer-int-value"><a href="#①Integer-int-value" class="headerlink" title="①Integer(int value)"></a>①Integer(int value)</h5><p>1.Java9之后标记已过时，不建议使用。</p>
<p>2.该构造方法可以将基本数据类型转换成包装类。这个过程我们称为<strong>装箱boxing</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(s);</span><br></pre></td></tr></table></figure>



<h5 id="②Integer-String-s"><a href="#②Integer-String-s" class="headerlink" title="②Integer(String s)"></a>②Integer(String s)</h5><p>1.Java9之后标记已过时，不建议使用。</p>
<p>2.该构造方法可以将字符串数字转换成包装类。但字符串必须是整数数字，如果不是会出现异常：<strong>NumberFormatException</strong></p>
<h4 id="Integer的常用方法"><a href="#Integer的常用方法" class="headerlink" title="Integer的常用方法"></a>Integer的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>; <span class="comment">//比较大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">//最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">//最小值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s)</span>; <span class="comment">//将字符串数字转换成数字类型。其它包装类也有这个方法：</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    Double.parseDouble(String s)**</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toBinaryString</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">//获取数字二进制的字符串表示形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toHexString</span><span class="params">(<span class="type">int</span> i)</span>;<span class="comment">// 获取数字十六进制的字符串表示形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toOctalString</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">//获取数字八进制的字符串表示形式</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer anotherInteger)</span>; <span class="comment">//比较大小，可见实现了Comparable接口</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>; <span class="comment">//包装类已经重写了equals()方法。</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>; <span class="comment">//包装类已经重写了toString()方法。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span>; <span class="comment">//将包装类拆箱为基本数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">//将基本数据类型转换成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">//将基本数据类型转换成Integer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(String s)</span> /将字符串转换成Integer（这个字符串必须是数字字符串才行，不然出现NumberFormatException）</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228111527964.png" alt="image-20240228111527964"></p>
<h4 id="Java5新特性：自动装箱和自动拆箱"><a href="#Java5新特性：自动装箱和自动拆箱" class="headerlink" title="Java5新特性：自动装箱和自动拆箱"></a>Java5新特性：自动装箱和自动拆箱</h4><blockquote>
<p>编译阶段的功能</p>
</blockquote>
<p>①Java5之后为了开发方便，引入了新特性：自动拆箱和自动装箱。</p>
<p>②自动装箱：auto boxing</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<p>③自动拆箱：auto unboxing</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"></span><br><span class="line">System.out.println(a + <span class="number">1</span>); 这里的a也会做自动拆箱。</span><br></pre></td></tr></table></figure>

<p>⑤注意空指针异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码出现空指针异常的原因是a在进行自动拆箱时，会调用 a.intValue()方法。</p>
<p>因为a是null，访问实例方法会出现空指针异常，因此使用时应注意。<br><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228111945428.png" alt="image-20240228111945428"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228112019609.png" alt="image-20240228112019609"></p>
<h4 id="整数型常量池"><a href="#整数型常量池" class="headerlink" title="整数型常量池"></a>整数型常量池</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228112206054.png" alt="image-20240228112206054"></p>
<p>①**&#x3D;&#x3D;[-128 ~ 127] Java为这个区间的Integer对象创建了整数型常量池。&#x3D;&#x3D;**</p>
<p>②也就是说如果整数没有超出范围的话，直接从整数型常量池获取Integer对象。</p>
<p>③以下是一个面试题：请说出它的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer x = 128;</span><br><span class="line"></span><br><span class="line">Integer y = 128;</span><br><span class="line"></span><br><span class="line">System.out.println(x == y); // false</span><br><span class="line"></span><br><span class="line">Integer a = 127;</span><br><span class="line"></span><br><span class="line">Integer b = 127;</span><br><span class="line"></span><br><span class="line">System.out.println(a == b); // true</span><br></pre></td></tr></table></figure>

<h3 id="大数字"><a href="#大数字" class="headerlink" title="大数字"></a>大数字</h3><blockquote>
<p>如果整数超过long的最大值怎么办？</p>
<p>这个是引用数据类型</p>
</blockquote>
<h4 id="①java中提供了一种引用数据类型来解决这个问题：-java-math-BigInteger-。它的父类是-Number。"><a href="#①java中提供了一种引用数据类型来解决这个问题：-java-math-BigInteger-。它的父类是-Number。" class="headerlink" title="①java中提供了一种引用数据类型来解决这个问题：**&#x3D;&#x3D;java.math.BigInteger&#x3D;&#x3D;。它的父类是&#x3D;&#x3D;Number。&#x3D;&#x3D;**"></a>①java中提供了一种引用数据类型来解决这个问题：**&#x3D;&#x3D;java.math.BigInteger&#x3D;&#x3D;<strong>。它的父类是</strong>&#x3D;&#x3D;Number。&#x3D;&#x3D;**</h4><h4 id="②常用构造方法：BigInteger-String-val"><a href="#②常用构造方法：BigInteger-String-val" class="headerlink" title="②常用构造方法：BigInteger(String val)"></a>②常用构造方法：BigInteger(String val)</h4><h4 id="③常用方法："><a href="#③常用方法：" class="headerlink" title="③常用方法："></a>③常用方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BigInteger <span class="title function_">add</span><span class="params">(BigInteger val)</span>; 求和</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">subtract</span><span class="params">(BigInteger val)</span>; 相减</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">multiply</span><span class="params">(BigInteger val)</span>; 乘积</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">divide</span><span class="params">(BigInteger val)</span>; 商</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(BigInteger val)</span>; 比较</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">abs</span><span class="params">()</span>; 绝对值</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">max</span><span class="params">(BigInteger val)</span>; 最大值</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">min</span><span class="params">(BigInteger val)</span>; 最小值</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">pow</span><span class="params">(<span class="type">int</span> exponent)</span>; 次幂</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">sqrt</span><span class="params">()</span>; 平方根</span><br></pre></td></tr></table></figure>

<h4 id="如果浮点型数据超过double的最大值怎么办？"><a href="#如果浮点型数据超过double的最大值怎么办？" class="headerlink" title="如果浮点型数据超过double的最大值怎么办？"></a>如果浮点型数据超过double的最大值怎么办？</h4><p>①java中提供了一种引用数据类型来解决这个问题**&#x3D;&#x3D;：java.math.BigDecimal&#x3D;&#x3D;<strong>（</strong>经常用在财务软件中<strong>）。它的父类是</strong>&#x3D;&#x3D;Number。&#x3D;&#x3D;**</p>
<p>②构造方法：**&#x3D;&#x3D;BigDecimal(String val)&#x3D;&#x3D;**</p>
<p>③常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal augend)</span>; 求和</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal subtrahend)</span>; 相减</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal multiplicand)</span>; 乘积</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor)</span>; 商</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">max</span><span class="params">(BigDecimal val)</span>; 最大值</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">min</span><span class="params">(BigDecimal val)</span>; 最小值</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">movePointLeft</span><span class="params">(<span class="type">int</span> n)</span>; 向左移动小数点</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">movePointRight</span><span class="params">(<span class="type">int</span> n)</span>; 向右移动小数点</span><br></pre></td></tr></table></figure>

<h4 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228113359145.png" alt="image-20240228113359145"></p>
<h3 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h3><h4 id="日期相关API"><a href="#日期相关API" class="headerlink" title="日期相关API"></a>日期相关API</h4><p>①**&#x3D;&#x3D;long l &#x3D; System.currentTimeMillis();&#x3D;&#x3D;** &#x2F;&#x2F; 获取自1970年1月1日0时0分0秒到系统当前时间的总毫秒数。</p>
<p>②java.util.Date 日期类</p>
<p>​		①构造方法：Date()</p>
<p>​		②构造方法：Date(long 毫秒)</p>
<p>③java.util.SimpleDateFormat 日期格式化类</p>
<p>​		①日期转换成字符串（java.util.Date -&gt; java.lang.String）</p>
<p>​		②字符串转换成日期（java.lang.String -&gt; java.util.Date）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Date ---》string  format</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sdf.format(now);</span><br><span class="line"></span><br><span class="line"><span class="comment">//string--》Date parse</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> <span class="string">&quot;2008-08-08 08:08:08 888&quot;</span>;<span class="comment">//字符串格式和下面这个format格式要对上，不然就会报解析异常</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf2.parse(strDate)</span><br></pre></td></tr></table></figure>

<p>④java.util.Calendar 日历类</p>
<p>​		①获取当前时间的日历对象：Calendar c &#x3D; Calendar.getInstance();</p>
<p>​		②获取日历中的某部分：int year &#x3D; c.get(Calendar.YEAR);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Calendar.YEAR <span class="comment">//获取年份 Calendar.MONTH 获取月份，0表示1月，1表示2月，...，11表示12月</span></span><br><span class="line"></span><br><span class="line">Calendar.DAY_OF_MONTH <span class="comment">//获取本月的第几天 Calendar.DAY_OF_YEAR 获取本年的第几天</span></span><br><span class="line"></span><br><span class="line">Calendar.HOUR_OF_DAY <span class="comment">//小时，24小时制 Calendar.HOUR 小时，12小时制</span></span><br><span class="line"></span><br><span class="line">Calendar.MINUTE <span class="comment">//获取分钟 Calendar.SECOND 获取秒</span></span><br><span class="line"></span><br><span class="line">Calendar.MILLISECOND <span class="comment">//获取毫秒 Calendar.DAY_OF_WEEK 获取星期几，1表示星期日，...，7表示星期六</span></span><br></pre></td></tr></table></figure>



<h5 id="①java-util-Calendar-日历类"><a href="#①java-util-Calendar-日历类" class="headerlink" title="①java.util.Calendar 日历类"></a>①java.util.Calendar 日历类</h5><p>​	1.日历的set方法：设置日历</p>
<p>​			1.calendar.set(Calendar.YEAR, 2023); </p>
<p>​			2.calendar.set(2008, Calendar.SEPTEMBER,8);</p>
<p>​	2.日历的add方法（日历中各个部分的加减）：</p>
<p>​			1.calendar.add(Calendar.YEAR, 1);</p>
<p>​	3.日历对象的setTime()让日历关联具体的时间</p>
<p>​			1.calendar.setTime(new Date());</p>
<p>​	4.日历对象的getTime()方法获取日历的具体时间：</p>
<p>​			1.Date time &#x3D; calendar.getTime();</p>
<h3 id="Java8的新日期API"><a href="#Java8的新日期API" class="headerlink" title="Java8的新日期API"></a>Java8的新日期API</h3><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/02/23/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/" rel="prev" title="Java基础部分2">
                  <i class="fa fa-angle-left"></i> Java基础部分2
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">lolo</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
