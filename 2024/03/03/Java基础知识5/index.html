<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="线程概述（线程安全和线程通信）①什么是进程？什么是线程？它们的区别？1.进程是指操作系统中的一段程序，它是一个正在执行中的程序实例，具有独立的内存空间和系统资源，如文件、网络端口等。在计算机程序执行时，先创建进程，再在进程中进行程序的执行。一般来说，一个进程可以包含多个线程。  可以理解为是一个软件  2.线程是指进程中的一个执行单元，是进程的一部分，它负责在进程中执行程序代码。每个线程都有自">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础知识5">
<meta property="og:url" content="http://example.com/2024/03/03/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/index.html">
<meta property="og:site_name" content="Loloooo">
<meta property="og:description" content="线程概述（线程安全和线程通信）①什么是进程？什么是线程？它们的区别？1.进程是指操作系统中的一段程序，它是一个正在执行中的程序实例，具有独立的内存空间和系统资源，如文件、网络端口等。在计算机程序执行时，先创建进程，再在进程中进行程序的执行。一般来说，一个进程可以包含多个线程。  可以理解为是一个软件  2.线程是指进程中的一个执行单元，是进程的一部分，它负责在进程中执行程序代码。每个线程都有自">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303154755001.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/%E8%B7%AF%E7%BA%BF%E5%9B%BE.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303155758392.png">
<meta property="og:image" content="http://example.com/2024/03/03/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303161755250.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303172013923.png">
<meta property="og:image" content="http://example.com/2024/03/03/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303172736672.png">
<meta property="og:image" content="http://example.com/2024/03/03/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303175456466.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303193011256.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240304094727010.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240304144429743.png">
<meta property="og:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240304153614044.png">
<meta property="article:published_time" content="2024-03-03T07:03:05.000Z">
<meta property="article:modified_time" content="2024-03-04T08:27:05.607Z">
<meta property="article:author" content="lolo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303154755001.png">


<link rel="canonical" href="http://example.com/2024/03/03/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/03/03/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/","path":"2024/03/03/Java基础知识5/","title":"Java基础知识5"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java基础知识5 | Loloooo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Loloooo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">线程概述（线程安全和线程通信）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%AE%83%E4%BB%AC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">①什么是进程？什么是线程？它们的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%91%A1%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">②多线程的作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%91%A2JVM%E8%A7%84%E8%8C%83%E4%B8%AD%E8%A7%84%E5%AE%9A%EF%BC%9A"><span class="nav-number">1.3.</span> <span class="nav-text">③JVM规范中规定：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%91%A3%E5%85%B3%E4%BA%8EJava%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.</span> <span class="nav-text">④关于Java程序的运行原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-number">2.</span> <span class="nav-text">并发与并行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%88concurrency%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">并发（concurrency）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%EF%BC%88parallellism%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">并行（parallellism）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">并发编程与并行编程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">线程的调度模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%91%A1%E5%88%86%E6%97%B6%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">②分时调度模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%91%A2%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">③抢占式调度模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">实现线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%BB%A7%E6%89%BFThread"><span class="nav-number">4.1.</span> <span class="nav-text">第一种方式：继承Thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.2.</span> <span class="nav-text">第二种方式：实现Runnable接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#t-start-%E5%92%8Ct-run-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">t.start()和t.run()的本质区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#run"><span class="nav-number">4.3.1.</span> <span class="nav-text">run()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#start"><span class="nav-number">4.3.2.</span> <span class="nav-text">start</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">4.4.</span> <span class="nav-text">线程常用的三个方法：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">5.</span> <span class="nav-text">线程生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0%E4%B8%8E%E7%BB%88%E6%AD%A2%EF%BC%88Thread-sleep%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">线程的休眠与终止（Thread.sleep）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Esleep%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">6.1.</span> <span class="nav-text">关于sleep的面试题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%96%AD%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0"><span class="nav-number">6.2.</span> <span class="nav-text">如何中断一个线程的休眠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%B8%AD%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0"><span class="nav-number">6.3.</span> <span class="nav-text">如何中止一个线程的休眠</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%96%B9%E6%B3%951%EF%BC%9At-stop"><span class="nav-number">6.3.1.</span> <span class="nav-text">1.方法1：t.stop()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%96%B9%E5%BC%8F2%EF%BC%9A%E6%89%93%E6%A0%87%E8%AE%B0"><span class="nav-number">6.3.2.</span> <span class="nav-text">2.方式2：打标记</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">守护线程(后台线程)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="nav-number">8.</span> <span class="nav-text">定时任务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%88%E5%B9%B6join"><span class="nav-number">9.</span> <span class="nav-text">线程的合并join</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="nav-number">10.</span> <span class="nav-text">线程的调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">10.1.</span> <span class="nav-text">设置优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%AE%A9%E4%BD%8D"><span class="nav-number">10.2.</span> <span class="nav-text">线程让位</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">11.</span> <span class="nav-text">线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%A6%81%E8%80%83%E8%99%91%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">11.1.</span> <span class="nav-text">1. 什么情况下要考虑线程的安全问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%9A"><span class="nav-number">11.2.</span> <span class="nav-text">2.一般情况下：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%EF%BC%9A%E6%95%88%E7%8E%87%E9%AB%98%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E9%9A%90%E6%82%A3"><span class="nav-number">11.2.1.</span> <span class="nav-text">异步：效率高，但是可能存在一个安全的隐患</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%EF%BC%9A%E6%95%88%E7%8E%87%E4%BD%8E%EF%BC%8C%E9%9C%80%E8%A6%81%E6%8E%92%E9%98%9F%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">11.2.2.</span> <span class="nav-text">同步：效率低，需要排队，但是可以保证线程的安全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">11.2.3.</span> <span class="nav-text">线程不安全操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">11.2.4.</span> <span class="nav-text">线程同步机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">11.3.</span> <span class="nav-text">线程同步机制面试题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">12.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">13.</span> <span class="nav-text">线程间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-wait"><span class="nav-number">13.1.</span> <span class="nav-text">1.wait()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-notify-%E5%92%8Cnotify"><span class="nav-number">13.2.</span> <span class="nav-text">2.notify()和notify()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">14.</span> <span class="nav-text">单例模式的线程安全问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">15.</span> <span class="nav-text">可重入锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Callable%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B"><span class="nav-number">16.</span> <span class="nav-text">Callable实现线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8BExecutorService"><span class="nav-number">17.</span> <span class="nav-text">线程池实现线程ExecutorService</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lolo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/03/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java基础知识5 | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础知识5
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-03 15:03:05" itemprop="dateCreated datePublished" datetime="2024-03-03T15:03:05+08:00">2024-03-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-04 16:27:05" itemprop="dateModified" datetime="2024-03-04T16:27:05+08:00">2024-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java体系知识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/java%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303154755001.png" alt="image-20240303154755001"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/%E8%B7%AF%E7%BA%BF%E5%9B%BE.png" alt="路线图"></p>
<h1 id="线程概述（线程安全和线程通信）"><a href="#线程概述（线程安全和线程通信）" class="headerlink" title="线程概述（线程安全和线程通信）"></a>线程概述（线程安全和线程通信）</h1><h2 id="①什么是进程？什么是线程？它们的区别？"><a href="#①什么是进程？什么是线程？它们的区别？" class="headerlink" title="①什么是进程？什么是线程？它们的区别？"></a>①<strong>什么是进程？什么是线程？它们的区别？</strong></h2><p><strong>1.进程是指操作系统中的一段程序，</strong>它是一个正在执行中的程序实例，具有独立的内存空间和系统资源，如文件、网络端口等。在计算机程序执行时，先创建进程，再在进程中进行程序的执行。一般来说，一个进程可以包含多个线程。</p>
<blockquote>
<p>可以理解为是一个软件</p>
</blockquote>
<p><strong>2.线程是指进程中的一个执行单元，是进程的一部分，</strong>它负责在进程中执行程序代码。每个线程都有自己的栈和程序计数器，并且可以共享进程的资源。多个线程可以在同一时刻执行不同的操作，从而提高了程序的执行效率。</p>
<p>3.现代的操作系统是支持多进程的，也就是可以启动多个软件，一个软件就是一个进程。称为：多进程并发。</p>
<p><strong>4.通常一个进程都是可以启动多个线程的。称为：多线程并发。</strong></p>
<h2 id="②多线程的作用？"><a href="#②多线程的作用？" class="headerlink" title="②多线程的作用？"></a>②<strong>多线程的作用？</strong></h2><p>1.提高处理效率。（多线程的优点之一是能够使 CPU 在处理一个任务时同时处理多个线程，这样可以充分利用 CPU 的资源，提高 CPU 的利用效率。）</p>
<h2 id="③JVM规范中规定："><a href="#③JVM规范中规定：" class="headerlink" title="③JVM规范中规定："></a>③<strong>JVM</strong>规范中规定：</h2><p>1.堆内存、方法区 是线程共享的。</p>
<p>2.虚拟机栈、本地方法栈、程序计数器 是每个线程私有的。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303155758392.png" alt="image-20240303155758392"></p>
<p>堆和方法区都是线程共享的，Java虚拟机栈是每个线程都有的，如果有10个线程，就有10个jvmstacks，还有一个主线程的方法，一共11个。</p>
<p>10个线程 ，每个线程也都有一个属于自己的本地方法栈。</p>
<p>局部变量，独立的，</p>
<h2 id="④关于Java程序的运行原理"><a href="#④关于Java程序的运行原理" class="headerlink" title="④关于Java程序的运行原理"></a>④<strong>关于Java程序的运行原理</strong></h2><p>1.“java HelloWorld”执行后，会启动JVM，JVM的启动表示一个进程启动了。</p>
<p>2.JVM进程会首先启动一个主线程（main-thread），主线程负责调用main方法。因此main方法是在主线程中运行的。</p>
<p><strong>3.除了主线程之外，还启动了一个垃圾回收线程。因此启动JVM，至少启动了两个线程。</strong></p>
<p>4.在main方法的执行过程中，程序员可以手动创建其他线程对象并启动。</p>
<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303161755250.png" alt="image-20240303161755250" style="zoom:33%;" />

<p>这个除了GC（垃圾回收线程之外）只有一个主线程</p>
<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><h2 id="并发（concurrency）"><a href="#并发（concurrency）" class="headerlink" title="并发（concurrency）"></a>并发（concurrency）</h2><p>①使用单核CPU的时候，同一时刻只能有一条指令执行，但多个指令被快速的轮换执行，使得在宏观上具有多个指令同时执行的效果，<strong>但在微观上并不是同时执行的，只是把时间分成若干端，使多个指令快速交替的执行</strong>。</p>
<p>②如上图所示，假设只有一个CPU资源，线程之间要竞争得到执行机会。图中的第一个阶段，在A执行的过程中，B、C不会执行，因为这段时间内这个CPU资源被A竞争到了，同理，第二阶段只有B在执行，第三阶段只有C在执行。其实，并发过程中，A、B、C并不是同时进行的（微观角度），但又是同时进行的（宏观角度）。</p>
<p>③在同一个时间点上，一个CPU只能支持一个线程在执行。因为CPU运行的速度很快，CPU使用抢占式调度模式在多个线程间进行着高速的切换，因此我们看起来的感觉就像是多线程一样，也就是看上去就是在同一时刻运行。</p>
<h2 id="并行（parallellism）"><a href="#并行（parallellism）" class="headerlink" title="并行（parallellism）"></a>并行（parallellism）</h2><p>①使用多核CPU的时候，同一时刻，有多条指令在多个CPU上同时执行。</p>
<p>②如图所示，在同一时刻，ABC都是同时执行（微观、宏观）。</p>
<h2 id="并发编程与并行编程"><a href="#并发编程与并行编程" class="headerlink" title="并发编程与并行编程"></a>并发编程与并行编程</h2><p><strong>①在CPU比较繁忙（假设为单核CPU），如果开启了很多个线程，则只能为一个线程分配仅有的CPU资源，这些线程就会为自己尽量多抢时间片，这就是通过多线程实现并发，线程之间会竞争CPU资源争取执行机会。</strong></p>
<p>②在CPU资源比较充足的时候，一个进程内的多个线程，可以被分配到不同的CPU资源，这就是通过多线程实现并行。</p>
<p>③至于<strong>多线程实现的是并发还是并行</strong>？上面所说，所写多线程可能被分配到一个CPU内核中执行，也可能被分配到不同CPU执行，分配过程是操作系统所为，不可人为控制。所以，<strong>如果有人问我我所写的多线程是并发还是并行的？我会说，都有可能。</strong></p>
<p>④总结：单核CPU上的多线程，只是由操作系统来完成多任务间对CPU的运行切换，并非真正意义上的并发。随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行，故而多线程技术得到广泛应用。</p>
<p>⑤不管并发还是并行，都提高了程序对CPU资源的利用率，最大限度地利用CPU资源，而我们使用多线程的目的就是为了提高CPU资源的利用率。</p>
<h1 id="线程的调度模型"><a href="#线程的调度模型" class="headerlink" title="线程的调度模型"></a>线程的调度模型</h1><blockquote>
<p>时间片就是执行权</p>
</blockquote>
<p>①如果<strong>多个线程被分配到一个CPU内核中执行，则同一时刻只能允许有一个线程能获得CPU的执行权</strong>，那么进程中的多个线程就会抢夺CPU的执行权，这就是涉及到线程调度策略。</p>
<h2 id="②分时调度模型"><a href="#②分时调度模型" class="headerlink" title="②分时调度模型"></a>②分时调度模型</h2><p>所有线程轮流使用CPU的执行权，并且平均的分配每个线程占用的CPU的时间。</p>
<h2 id="③抢占式调度模型"><a href="#③抢占式调度模型" class="headerlink" title="③抢占式调度模型"></a>③抢占式调度模型</h2><p><strong>&#x3D;&#x3D;让优先级高的线程以较大的概率优先获得CPU的执行权，如果线程的优先级相同，那么就会随机选择一个线程获得CPU的执行权，而Java采用的就是抢占式调用。&#x3D;&#x3D;</strong></p>
<h1 id="实现线程"><a href="#实现线程" class="headerlink" title="实现线程"></a>实现线程</h1><h2 id="第一种方式：继承Thread"><a href="#第一种方式：继承Thread" class="headerlink" title="第一种方式：继承Thread"></a>第一种方式：继承Thread</h2><p>①编写一个类继承Thread，重写run方法。</p>
<p>②创建线程对象：Thread t &#x3D; new MyThread();</p>
<p>③启动线程：t.start();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.CollectionTest.ThreadTest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1 编写一个类继承java.lang.Thread</span></span><br><span class="line"><span class="comment"> * 2 重写run方法</span></span><br><span class="line"><span class="comment"> * 3 new线程对象</span></span><br><span class="line"><span class="comment"> * 4 调用线程对象的start方法来启动线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里编写的代码是在main方法中，因此这里的代码是属于主线程中进行的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303172013923.png" alt="image-20240303172013923"></p>
<blockquote>
<p>铁律：自上而下的执行，在大括号中，上面执行不完，下面也不会执行</p>
<p>mt.start()是启动代码，瞬间就结束</p>
</blockquote>
<h2 id="第二种方式：实现Runnable接口"><a href="#第二种方式：实现Runnable接口" class="headerlink" title="第二种方式：实现Runnable接口"></a>第二种方式：实现Runnable接口</h2><p>①编写一个类实现Runnable接口，实现run方法。</p>
<p>②创建线程对象：Thread t &#x3D; new Thread(new MyRunnable());</p>
<p>③启动线程：t.start();</p>
<blockquote>
<p>Runnable和线程没有任何的关系，只是一个实现了runnable接口的普通类。</p>
</blockquote>
<p><strong>推荐使用这种方式，在实现接口的同时，保留了类的继承</strong></p>
<p>优先选择第二种方式：因为实现接口的同时，保留了类的继承。</p>
<p>第二种方式也可以使用匿名内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t----》&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main--&gt;&quot;</span>+i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="t-start-和t-run-的本质区别？"><a href="#t-start-和t-run-的本质区别？" class="headerlink" title="t.start()和t.run()的本质区别？"></a>t.start()和t.run()的本质区别？</h2><p>①本质上没有区别，都是普通方法调用。只不过两个方法完成的任务不同。</p>
<p>②t.run()是调用run方法。执行run方法中的业务代码。</p>
<p>③t.start()是启动线程，只要线程启动了，start()方法就执行结束了。</p>
<h3 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h3><img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303172736672.png" alt="image-20240303172736672" style="zoom:200%;" />

<blockquote>
<p>这个说白了还是个单线程</p>
</blockquote>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303175456466.png" alt="image-20240303175456466" style="zoom:200%;" />

<blockquote>
<p>相当于，start会进入栈，然后启动一个新进程之后，弹出栈，在另外一个线程栈里面继续跑。有两个栈互不干扰。然后两个开始抢cpu的运行权</p>
</blockquote>
<h2 id="线程常用的三个方法："><a href="#线程常用的三个方法：" class="headerlink" title="线程常用的三个方法："></a>线程常用的三个方法：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">①实例方法：</span><br><span class="line">String <span class="title function_">getName</span><span class="params">()</span>; </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">②静态方法：</span><br><span class="line"><span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>;<span class="comment">//获取当前线程的对象</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.CollectionTest.Thread01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">maintest</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程的名字&quot;</span>+maintest.getName());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        super.run();</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(<span class="string">&quot;分支线程的名字:&quot;</span>+thread.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p>①线程生命周期指的是：从线程对象新建，到最终线程死亡的整个过程。</p>
<p>②线程生命周期包括七个重要阶段：</p>
<blockquote>
<p>1.新建状态（NEW）</p>
<p>运行状态</p>
<p>​	2.就绪状态（RUNNABLE）</p>
<p>​	3.运行状态（RUNNABLE）</p>
<p>4.超时等待状态（TIMED_WAITING）</p>
<p>5.等待状态（WAITING）</p>
<p>6.阻塞状态（BLOCKED）</p>
<p>7.死亡状态（TERMINATED）</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240303193011256.png" alt="image-20240303193011256"></p>
<h1 id="线程的休眠与终止（Thread-sleep）"><a href="#线程的休眠与终止（Thread-sleep）" class="headerlink" title="线程的休眠与终止（Thread.sleep）"></a>线程的休眠与终止（Thread.sleep）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>*<span class="number">5</span>);<span class="comment">// 出现在哪里阻塞哪个线程</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于sleep的面试题"><a href="#关于sleep的面试题" class="headerlink" title="关于sleep的面试题"></a>关于sleep的面试题</h2><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240304094727010.png" alt="image-20240304094727010"></p>
<blockquote>
<p>这个t.sleep其实等同于是Thread.sleep(1000*5)，</p>
<p>所以这个其实是阻塞主线程的，不是让t线程睡眠，让当前线程睡眠。</p>
<p>结果：5s足够run()跑完，所以是0-99输出出来，然后等完5s后，跑主线程</p>
</blockquote>
<h2 id="如何中断一个线程的休眠"><a href="#如何中断一个线程的休眠" class="headerlink" title="如何中断一个线程的休眠"></a>如何中断一个线程的休眠</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.interrupt();</span><br></pre></td></tr></table></figure>

<p>利用哪个线程，就中止哪个线程的睡眠，这是一个实例方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Thread-0起来干活了。</span><br><span class="line">// 这行代码的作用是终止 t 线程的睡眠。</span><br><span class="line">// interrupt方法是一个实例方法。</span><br><span class="line">// 以下代码含义：t线程别睡了。</span><br><span class="line">// 底层实现原理是利用了：异常处理机制。</span><br><span class="line">// 当调用这个方法的时候，如果t线程正在睡眠，必然会抛出：InterruptedException，然后捕捉异常，终止睡眠。</span><br><span class="line">t.interrupt();</span><br></pre></td></tr></table></figure>

<h2 id="如何中止一个线程的休眠"><a href="#如何中止一个线程的休眠" class="headerlink" title="如何中止一个线程的休眠"></a>如何中止一个线程的休眠</h2><h3 id="1-方法1：t-stop"><a href="#1-方法1：t-stop" class="headerlink" title="1.方法1：t.stop()"></a>1.方法1：t.stop()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.stop()//这个已经废除了1.2</span><br></pre></td></tr></table></figure>

<p>这种方式是强行终止线程，容易导致数据的丢失；没有保存的数据在内存中的数据一定会因此而丢失</p>
<h3 id="2-方式2：打标记"><a href="#2-方式2：打标记" class="headerlink" title="2.方式2：打标记"></a>2.方式2：打标记</h3><p>在run()设置局部变量： boolean run &#x3D; true;</p>
<p>并在主函数中设置中止线程： mr.run &#x3D; false;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ljy.CollectionTest.Thread03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Thread t = new Thread(new MyRunnable());</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// 5秒之后终止线程t的执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//终止线程t的执行。</span></span><br><span class="line">        mr.run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(run)&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span>+i);</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    Thread.sleep(1000*5);</span></span><br><span class="line"><span class="comment">//                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//                    throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="守护线程-后台线程"><a href="#守护线程-后台线程" class="headerlink" title="守护线程(后台线程)"></a>守护线程(后台线程)</h1><blockquote>
<p>线程一共分为两大类：用户线程与守护线程</p>
<p>所谓用户线程就是非守护线程，垃圾回收线程GC就是守护线程</p>
<p>守护线程的特点 ，所有的用户线程结束之后，守护线程会自动的退出&#x2F;结束</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myThread.setDaemon(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.javase.thread07;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 在Java语言中，线程被分为两大类：</span></span><br><span class="line"><span class="comment"> *      第一类：用户线程（非守护线程）</span></span><br><span class="line"><span class="comment"> *      第二类：守护线程（后台线程）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 在JVM当中，有一个隐藏的守护线程一直在守护者，它就是GC线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 守护线程的特点：所有的用户线程结束之后，守护线程自动退出/结束。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 如何将一个线程设置为守护线程？</span></span><br><span class="line"><span class="comment"> *      t.setDaemon(true);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在启动线程之前，设置线程为守护线程</span></span><br><span class="line">        myThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10s结束！</span></span><br><span class="line">        <span class="comment">// main线程中，main线程是一个用户线程。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;===&gt;&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;===&gt;&quot;</span> + (++i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>守护线程会在用户线程结束后结束，也就是在JVM结束后结束，</p>
<p>这段代码的主线程是一个运行5s会结束的代码，分线程是一个死循环，如果不停止会一直 的运行下去。</p>
<p>但是在这个代码的实际结果中，主线程在运行5s后就会结束，分线程设置为一个守护线程，所以这个线程也会在主线程结束后结束，所以这个死循环的线程会在5s之后结束。</p>
<h1 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h1><blockquote>
<p>JDK中提供的定时任务</p>
<p>java.util.Timer	定时器</p>
<p>java.util,TimerTask	定时任务</p>
</blockquote>
<ol>
<li><p>定时器 + 定时任务，可以帮助我们在程序中完成，每间隔多久执行一次某段程序。</p>
</li>
<li><p>Timer的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Timer()</span><br><span class="line">Timer(<span class="type">boolean</span> isDaemon) isDaemon是<span class="literal">true</span>表示该定时器是一个守护线程</span><br></pre></td></tr></table></figure>

<p>Timer本身就是继承了Runnable的，所以本质上可以理解为是一个线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="线程的合并join"><a href="#线程的合并join" class="headerlink" title="线程的合并join"></a>线程的合并join</h1><p>1.t.join（）实现的效果喝Thread.sleep()差不多，但是t.join()会把这个线程合并到当前线程，并且阻塞当前线程。</p>
<p>​		直到t线程结束了，才会接触当前线程的阻塞状态，就是把这个线程插入，跑完，再让主线程跑</p>
<p>2.join是一个实例方法，不是静态方法</p>
<p>3.假设在main方法中，调用了t.join(),后果是什么？</p>
<p>​	t线程合并到主线程中，主线程进入到了阻塞状态，直到t线程执行结束之后，主线程阻塞解除。</p>
<p>4.t.join方法其实是让当前线程进入阻塞状态，直到t线程结束，当前线程阻塞状态接触。</p>
<p>5.和sleep方法很像，但是不一样</p>
<p>​		第一：sleep方法是静态方法，join是实例方法</p>
<p>​		第二：sleep方法可以指定睡眠的时长，join方法不能保证阻塞的时长</p>
<p>​		第三：sleep和join方法都是让当前线程进入到了一个阻塞的状态；</p>
<p>​		第四：sleep方法的阻塞解除条件？时间过去了，join的方法的阻塞解除条件？调用join方法的那个线程结束了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main begin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并线程</span></span><br><span class="line">        <span class="comment">// t合并到main线程中。</span></span><br><span class="line">        <span class="comment">// main线程受到阻塞（当前线程受到阻塞）</span></span><br><span class="line">        <span class="comment">// t线程继续执行，直到t线程结束。main线程阻塞解除（当前线程阻塞解除）。</span></span><br><span class="line">        <span class="comment">//t.join();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// join方法也可以有参数，参数是毫秒。</span></span><br><span class="line">        <span class="comment">// 以下代码表示 t 线程合并到 当前线程，合并时长 10 毫秒</span></span><br><span class="line">        <span class="comment">// 阻塞当前线程 10 毫秒</span></span><br><span class="line">        <span class="comment">//t.join(10);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用这个方法，是想让当前线程受阻10秒</span></span><br><span class="line">        <span class="comment">// 但不一定，如果在指定的阻塞时间内，t线程结束了。当前线程阻塞也会解除。</span></span><br><span class="line">        t.join(<span class="number">1000</span> * <span class="number">10</span>); </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程休眠10秒。</span></span><br><span class="line">        <span class="comment">//Thread.sleep(1000 * 10);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h1><ol>
<li><p>优先级</p>
</li>
<li><p>线程是可以设置优先级的，优先级较高的，获得CPU时间片的总体概率会高一些</p>
</li>
<li><p>JVM采用的是抢占式调度模型，谁的优先级高，获取CPU时间片的总体概率就高。</p>
</li>
<li><p>默认情况下，一个线程的优先级是5</p>
</li>
<li><p>最低是1，最高是10</p>
</li>
</ol>
<h2 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainThread.setPriority(Thread.MAX_PRIORITY)</span><br></pre></td></tr></table></figure>

<h2 id="线程让位"><a href="#线程让位" class="headerlink" title="线程让位"></a>线程让位</h2><p>yield，静态方法，这个代码出现在哪里，就是当前线程让位，当前线程把占领的cpu的时间片放弃掉，直接回到就绪状态，继续抢夺CPU时间片的状态，不会进入阻塞状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于JVM的调度：</span></span><br><span class="line"><span class="comment"> *      1. 让位</span></span><br><span class="line"><span class="comment"> *      2. 静态方法：Thread.yield()</span></span><br><span class="line"><span class="comment"> *      3. 让当前线程让位。</span></span><br><span class="line"><span class="comment"> *      4. 注意：让位不会让其进入阻塞状态。只是放弃目前占有的CPU时间片，进入就绪状态，继续抢夺CPU时间片。</span></span><br><span class="line"><span class="comment"> *      5. 只能保证大方向上的，大概率，到了某个点让位一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于JVM的调度：</span></span><br><span class="line"><span class="comment"> *      1. 让位</span></span><br><span class="line"><span class="comment"> *      2. 静态方法：Thread.yield()</span></span><br><span class="line"><span class="comment"> *      3. 让当前线程让位。</span></span><br><span class="line"><span class="comment"> *      4. 注意：让位不会让其进入阻塞状态。只是放弃目前占有的CPU时间片，进入就绪状态，继续抢夺CPU时间片。</span></span><br><span class="line"><span class="comment"> *      5. 只能保证大方向上的，大概率，到了某个点让位一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t1&quot;</span>) &amp;&amp; i % <span class="number">10</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;让位了，此时的i下标是：&quot;</span> + i);</span><br><span class="line">                <span class="comment">// 当前线程让位，这个当前线程一定是t1</span></span><br><span class="line">                <span class="comment">// t1会让位一次</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><h2 id="1-什么情况下要考虑线程的安全问题？"><a href="#1-什么情况下要考虑线程的安全问题？" class="headerlink" title="1. 什么情况下要考虑线程的安全问题？"></a>1. 什么情况下要考虑线程的安全问题？</h2><p>条件1：多线程的并发环境下</p>
<p>条件2：有共享的数据</p>
<p>条件3：共享数据涉及到修改的操作</p>
<h2 id="2-一般情况下："><a href="#2-一般情况下：" class="headerlink" title="2.一般情况下："></a>2.一般情况下：</h2><ol>
<li><p>局部变量不存在线程的安全问题（尤其是基本数据类型，如果是引用数据类型就另外说了），局部变量是在栈里面的</p>
</li>
<li><p>实例变量可能会出现线程安全问题，因为实例变量是堆共享的</p>
</li>
<li><p>静态变量容易出现线程安全问题，静态变量是在堆中的，堆是多线程共享的</p>
</li>
</ol>
<p>我们把线程排队执行，叫做线程的同步机制，（t1和t2线程，t1线程在执行的时候必须等待t2线程执行到某个位置之后，t1线程才开始执行。）</p>
<p>如果不排队，我们将其称为：线程的异步机制。（t1和t2各自执行各自的，谁也不需要等待对方，并发的，就认为是一个异步的）</p>
<h3 id="异步：效率高，但是可能存在一个安全的隐患"><a href="#异步：效率高，但是可能存在一个安全的隐患" class="headerlink" title="异步：效率高，但是可能存在一个安全的隐患"></a>异步：效率高，但是可能存在一个安全的隐患</h3><h3 id="同步：效率低，需要排队，但是可以保证线程的安全问题"><a href="#同步：效率低，需要排队，但是可以保证线程的安全问题" class="headerlink" title="同步：效率低，需要排队，但是可以保证线程的安全问题"></a>同步：效率低，需要排队，但是可以保证线程的安全问题</h3><h3 id="线程不安全操作"><a href="#线程不安全操作" class="headerlink" title="线程不安全操作"></a>线程不安全操作</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240304144429743.png" alt="image-20240304144429743"></p>
<p>以上的操作是线程不安全的，如果要保证线程安全，就要让读取操作和写操作是不可分的</p>
<h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><blockquote>
<p>要使用线程的同步机制，来保证多线程并发环境下的数据安全问题</p>
<p>线程同步的本质：线程排队执行就是同步机制</p>
</blockquote>
<ol>
<li>语法格式：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(必须是需要排队的这几个线程共享共享的对象)</span><br><span class="line">&#123;</span><br><span class="line">	需要同步的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用线程同步机制，来保证多线程并发环境下的数据安全问题：</span></span><br><span class="line"><span class="comment"> *      1. 线程同步的本质是：线程排队执行就是同步机制。</span></span><br><span class="line"><span class="comment"> *      2. 语法格式：</span></span><br><span class="line"><span class="comment"> *          synchronized(必须是需要排队的这几个线程共享的对象)&#123;</span></span><br><span class="line"><span class="comment"> *              // 需要同步的代码</span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          “必须是需要排队的这几个线程共享的对象” 这个必须选对了。</span></span><br><span class="line"><span class="comment"> *          这个如果选错了，可能会无故增加同步的线程数量，导致效率降低。</span></span><br><span class="line"><span class="comment"> *      3. 原理是什么？</span></span><br><span class="line"><span class="comment"> *          synchronized(obj)&#123;</span></span><br><span class="line"><span class="comment"> *              // 同步代码块</span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment"> *          假设obj是t1 t2两个线程共享的。</span></span><br><span class="line"><span class="comment"> *          t1和t2执行这个代码的时候，一定是有一个先抢到了CPU时间片。一定是有先后顺序的。</span></span><br><span class="line"><span class="comment"> *          假设t1先抢到了CPU时间片。t1线程找共享对象obj的对象锁，找到之后，则占有这把锁。只要能够占有obj对象的对象锁，就有权利进入同步代码块执行代码。</span></span><br><span class="line"><span class="comment"> *          当t1线程执行完同步代码块之后，会释放之前占有的对象锁（归还锁）。</span></span><br><span class="line"><span class="comment"> *          同样，t2线程抢到CPU时间片之后，也开始执行，也会去找共享对象obj的对象锁，但由于t1线程占有这把锁，t2线程只能在同步代码块之外等待。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      4. 注意同步代码块的范围，不要无故扩大同步的范围，同步代码块范围越小，效率越高。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void withdraw(double money)&#123;</span><br><span class="line">    // this是当前账户对象</span><br><span class="line">    // 当前账户对象act，就是t1和t2共享的对象。</span><br><span class="line">    synchronized (this)&#123;</span><br><span class="line">    //synchronized (obj) &#123;</span><br><span class="line">        // 第一步：读取余额</span><br><span class="line">        double before = this.getBalance();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;线程正在取款&quot;+money+&quot;，当前&quot;+this.getActNo()+&quot;账户余额&quot; + before);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第二步：修改余额</span><br><span class="line">        this.setBalance(before - money);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + &quot;线程取款成功，当前&quot;+this.getActNo()+&quot;账户余额&quot; + this.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键是找共享对象</p>
<p>加到实例代码块中，锁的就是this</p>
<p>比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> money)</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照上面的操作，同步代码块就是这个大的整体，</p>
<p>如果写的是普通的同步代码块，可以保证这个同步的范围，同时这个括号里面的内容也是可以写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在实例方法上也可以添加 synchronized 关键字：</span></span><br><span class="line"><span class="comment"> *      1. 在实例方法上添加了synchronized关键字之后，整个方法体是一个同步代码块。</span></span><br><span class="line"><span class="comment"> *      2. 在实例方法上添加了synchronized关键字之后，共享对象的对象锁一定是this的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这种方式相对于之前所讲的局部同步代码块的方式要差一些：</span></span><br><span class="line"><span class="comment"> *      synchronized(共享对象)&#123;</span></span><br><span class="line"><span class="comment"> *          // 同步代码块</span></span><br><span class="line"><span class="comment"> *      &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      这种方式优点：灵活</span></span><br><span class="line"><span class="comment"> *          共享对象可以随便调整。</span></span><br><span class="line"><span class="comment"> *          同步代码块的范围可以随便调整。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="线程同步机制面试题"><a href="#线程同步机制面试题" class="headerlink" title="线程同步机制面试题"></a>线程同步机制面试题</h2><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h1 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 内容是关于：线程通信。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 线程通信涉及到三个方法：</span></span><br><span class="line"><span class="comment"> *      wait()、notify()、notifyAll()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. 以上三个方法都是Object类的方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 其中wait()方法重载了三个：</span></span><br><span class="line"><span class="comment"> *      wait():调用此方法，线程进入“等待状态”</span></span><br><span class="line"><span class="comment"> *      wait(毫秒)：调用此方法，线程进入“超时等待状态”</span></span><br><span class="line"><span class="comment"> *      wait(毫秒, 纳秒)：调用此方法，线程进入“超时等待状态”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. 调用wait方法和notify相关方法的，不是通过线程对象去调用，而是通过共享对象去调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 6. 例如调用了：obj.wait()，什么效果？</span></span><br><span class="line"><span class="comment"> *      obj是多线程共享的对象。</span></span><br><span class="line"><span class="comment"> *      当调用了obj.wait()之后，在obj对象上活跃的所有线程进入无期限等待。直到调用了该共享对象的 obj.notify() 方法进行了唤醒。</span></span><br><span class="line"><span class="comment"> *      而且唤醒后，会接着上一次调用wait()方法的位置继续向下执行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 7. obj.wait()方法调用之后，会释放之前占用的对象锁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 8. 关于notify和notifyAll方法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure>



<h2 id="1-wait"><a href="#1-wait" class="headerlink" title="1.wait()"></a>1.wait()</h2><p>wait方法无参数的会进入等待状态，有参数的会进入超时等待状态</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%865/image-20240304153614044.png" alt="image-20240304153614044"></p>
<p>当调用了obj.wait()之后，在obj对象上活跃的所有线程都会进入等待，直到调用了该共享对象的notify方法进行唤醒。</p>
<h2 id="2-notify-和notify"><a href="#2-notify-和notify" class="headerlink" title="2.notify()和notify()"></a>2.notify()和notify()</h2><ul>
<li><pre><code> 共享对象.notify(); 调用之后效果是什么？唤醒优先级最高的等待线程。如果优先级一样，则随机唤醒一个。
</code></pre>
</li>
<li><pre><code> 共享对象.notifyAll(); 调用之后效果是什么？唤醒所有在该共享对象上等待的线程。
</code></pre>
</li>
</ul>
<h1 id="单例模式的线程安全问题"><a href="#单例模式的线程安全问题" class="headerlink" title="单例模式的线程安全问题"></a>单例模式的线程安全问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.javase.thread23;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取某个类。这是反射机制中的内容。</span></span><br><span class="line">        <span class="comment">/*Class stringClass = String.class;</span></span><br><span class="line"><span class="comment">        Class singletonClass = Singleton.class;</span></span><br><span class="line"><span class="comment">        Class dateClass = java.util.Date.class;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象t1</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                s1 = Singleton.getSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象t2</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                s2 = Singleton.getSingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断这两个Singleton对象是否一样。</span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法执行了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非线程安全的。</span></span><br><span class="line">    <span class="comment">/*public static Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            singleton = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的：第一种方案（同步方法），找类锁。</span></span><br><span class="line">    <span class="comment">/*public static synchronized Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            singleton = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的：第二种方案（同步代码块），找的类锁</span></span><br><span class="line">    <span class="comment">/*public static Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        // 这里有一个知识点是反射机制中的内容。可以获取某个类。</span></span><br><span class="line"><span class="comment">        synchronized (Singleton.class)&#123;</span></span><br><span class="line"><span class="comment">            if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">                try &#123;</span></span><br><span class="line"><span class="comment">                    Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">                &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                    throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                singleton = new Singleton();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程安全的：这个方案对上一个方案进行优化，提升效率。</span></span><br><span class="line">    <span class="comment">/*public static Singleton getSingleton() &#123;</span></span><br><span class="line"><span class="comment">        if(singleton == null)&#123;</span></span><br><span class="line"><span class="comment">            synchronized (Singleton.class)&#123;</span></span><br><span class="line"><span class="comment">                if (singleton == null) &#123;</span></span><br><span class="line"><span class="comment">                    try &#123;</span></span><br><span class="line"><span class="comment">                        Thread.sleep(2000);</span></span><br><span class="line"><span class="comment">                    &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                        throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    singleton = new Singleton();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return singleton;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Lock来实现线程安全</span></span><br><span class="line">    <span class="comment">// Lock是接口，从JDK5开始引入的。</span></span><br><span class="line">    <span class="comment">// Lock接口下有一个实现类：可重入锁（ReentrantLock）</span></span><br><span class="line">    <span class="comment">// 注意：要想使用ReentrantLock达到线程安全，假设要让t1 t2 t3线程同步，就需要让t1 t2 t3共享同一个lock。</span></span><br><span class="line">    <span class="comment">// Lock 和 synchronized 哪个好？Lock更好。为什么？因为更加灵活。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁（需要100%保证解锁，怎么办？finally）</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><h1 id="Callable实现线程"><a href="#Callable实现线程" class="headerlink" title="Callable实现线程"></a>Callable实现线程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.javase.thread24;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现线程的第三种方式：实现Callable接口，实现call方法。</span></span><br><span class="line"><span class="comment"> * 这种方式实现的线程，是可以获取到线程返回值的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建“未来任务”对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 处理业务......</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取“未来任务”线程的返回值</span></span><br><span class="line">            <span class="comment">// 阻塞当前线程，等待“未来任务”结束并返回值。</span></span><br><span class="line">            <span class="comment">// 拿到返回值，当前线程的阻塞才会解除。继续执行。</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> task.get();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*class MyRunnable implements Runnable &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void run() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">class MyThread extends Thread &#123;</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void run() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure>

<h1 id="线程池实现线程ExecutorService"><a href="#线程池实现线程ExecutorService" class="headerlink" title="线程池实现线程ExecutorService"></a>线程池实现线程ExecutorService</h1><blockquote>
<p>高并发的商城项目，一定是会用到的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 创建线程的第四种方式：使用线程池技术。</span><br><span class="line">* 线程池本质上就是一个缓存：cache</span><br><span class="line">* 一般都是服务器在启动的时候，初始化线程池，</span><br><span class="line">* 也就是说服务器在启动的时候，创建N多个线程对象，</span><br><span class="line">* 直接放到线程池中，需要使用线程对象的时候，直接从线程池中获取。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个线程池对象（线程池中有3个线程）</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将任务交给线程池（你不需要触碰到这个线程对象，你只需要将要处理的任务交给线程池即可。）</span></span><br><span class="line">executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后记得关闭线程池</span></span><br><span class="line">executorService.shutdown();</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/02/28/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%864-%E9%9B%86%E5%90%88/" rel="prev" title="Java基础部分4-集合">
                  <i class="fa fa-angle-left"></i> Java基础部分4-集合
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/03/04/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%866-%E5%8F%8D%E5%B0%84/" rel="next" title="Java基础知识6-反射">
                  Java基础知识6-反射 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">lolo</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
