<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Loloooo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Loloooo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lolo">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Loloooo</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Loloooo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">lolo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/01/Redis-%E9%9B%86%E7%BE%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/Redis-%E9%9B%86%E7%BE%A4/" class="post-title-link" itemprop="url">Redis-集群</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-01 21:31:35 / 修改时间：21:31:54" itemprop="dateCreated datePublished" datetime="2024-04-01T21:31:35+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/01/Redis-%E5%93%A8%E5%85%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/Redis-%E5%93%A8%E5%85%B5/" class="post-title-link" itemprop="url">Redis-哨兵</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-01 18:11:32 / 修改时间：21:32:00" itemprop="dateCreated datePublished" datetime="2024-04-01T18:11:32+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="哨兵sentinel"><a href="#哨兵sentinel" class="headerlink" title="哨兵sentinel"></a>哨兵sentinel</h1><p>吹哨人巡查监控后台master主机是否故障,如果故障了根据<strong>投票数</strong>自动将某一个从库换成新主库;</p>
<p>投票数写多少:?</p>
<p><strong>作用:无人值守运维</strong></p>
<p>监控redis运行状态,包括master和slave</p>
<p>当master down 机,能自动将slave切换成新master</p>
<h2 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h2><h3 id="主从监控"><a href="#主从监控" class="headerlink" title="主从监控"></a>主从监控</h3><p>监控主从redis库运行是否正常</p>
<h3 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h3><p>哨兵可以将故障转移的结果发送给客户端</p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>如果master异常,则会进行主从切换,将其中一个slave作为新的Master</p>
<h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p>客户端通过连接哨兵来获得当前redis服务的主节点</p>
<p><img src="/../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401190333439.png" alt="image-20240401190333439"></p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="重点参数项说明"><a href="#重点参数项说明" class="headerlink" title="重点参数项说明"></a>重点参数项说明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>

<p>设置要监控的master服务器</p>
<p>quorum表示最少有几个哨兵 认可客观下线,同意故障迁移的法定票数</p>
<img src="../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401201726993.png" alt="image-20240401201726993" style="zoom:33%;" />

<blockquote>
<p>quorum这个参数是进行客观下线的一个依据,意思是至少有quorum个sentinel认为这个master有故障,才会对这个master进行下线以及故障转移.因为有的时候,某个sentinel节点可能因为自身网络的原因,无法连接master,而此时master并没有出现故障,所以这就需要多个sentinel都一致认为该master有问题,才可以进行下一步操作,就保证了公平性和高可用.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel auth-pass &lt;master-name&gt; &lt;password&gt; </span><br></pre></td></tr></table></figure>

<p>master 设置了密码,连接master服务的密码</p>
<img src="../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401202612382.png" alt=" " style="zoom:33%;" />  

<img src="../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401202852489.png" alt="image-20240401202852489" style="zoom:33%;" />

<img src="../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401203501054.png" alt="image-20240401203501054" style="zoom:25%;" />

<h2 id="运行流程和选举原理"><a href="#运行流程和选举原理" class="headerlink" title="运行流程和选举原理"></a>运行流程和选举原理</h2><p>当一个主从配置中的master失效之后,sentinel可以选举出一个新的master用于自动接替原master的工作,主从配置中的其他redis服务器自动指向新的master同步数据.一般建议sentinel采用奇数台</p>
<h2 id="运行流程-故障切换"><a href="#运行流程-故障切换" class="headerlink" title="运行流程,故障切换"></a>运行流程,故障切换</h2><img src="../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401205758253.png" alt="image-20240401205758253" style="zoom:25%;" />

<h3 id="三个哨兵监控一主二从-正常运行中……"><a href="#三个哨兵监控一主二从-正常运行中……" class="headerlink" title="三个哨兵监控一主二从,正常运行中……"></a>三个哨兵监控一主二从,正常运行中……</h3><h3 id="SDown主观下线-Subjectively-Down"><a href="#SDown主观下线-Subjectively-Down" class="headerlink" title="SDown主观下线(Subjectively Down)"></a>SDown主观下线(Subjectively Down)</h3><ul>
<li>SDOWN(主观不可用)是单个sentinel自己主观上检测到的关于master的状态,从sentinel的角度来看,如果发送了ping心跳之后,在一定的时间里面没有收到合法的回复,就达到了SDOWN的条件.</li>
<li>sentinel配置文件中的down-after-milliseconds设置了判断主观下线的时间长度</li>
</ul>
<img src="../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401210114847.png" alt="image-20240401210114847" style="zoom:25%;" />

<h3 id="ODOWN客观下线-Objectively-down"><a href="#ODOWN客观下线-Objectively-down" class="headerlink" title="ODOWN客观下线(Objectively down)"></a>ODOWN客观下线(Objectively down)</h3><p>ODOWN需要一定数量的sentinel,多个哨兵达成一致意见才能认为一个master客观上已经宕了</p>
<p><img src="/../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401210306067.png" alt="image-20240401210306067"></p>
<h3 id="选举出领导者哨兵-哨兵中选出兵王-leader"><a href="#选举出领导者哨兵-哨兵中选出兵王-leader" class="headerlink" title="选举出领导者哨兵(哨兵中选出兵王)leader"></a>选举出领导者哨兵(哨兵中选出兵王)leader</h3><p>当主节点被判断客观下线以后,哥哥哨兵节点会协商,先选举出一个**&#x3D;&#x3D;领导者哨兵节点&#x3D;&#x3D;** 并由该领导者节点,也即被选举出的leader进行failover(故障迁移)</p>
<h4 id="哨兵leader如何选举的-Raft算法"><a href="#哨兵leader如何选举的-Raft算法" class="headerlink" title="哨兵leader如何选举的 Raft算法"></a>哨兵leader如何选举的 Raft算法</h4><p>基本思路:先到先得</p>
<p><strong>在一轮选举中,哨兵A向B发送成为领导者的申请,如果B没有同意过其他哨兵,就会同意A成为领导者</strong></p>
 <img src="../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401211541666.png" alt="image-20240401211541666" style="zoom:25%;" />

<h3 id="由leader开始推动故障切换流程并选择一个新的master"><a href="#由leader开始推动故障切换流程并选择一个新的master" class="headerlink" title="由leader开始推动故障切换流程并选择一个新的master"></a>由leader开始推动故障切换流程并选择一个新的master</h3><p>某一个slave被选中成为一个新的master,规则如下:</p>
<blockquote>
<p>由于存在网络抖动,不见得每个slave都会有效的得到master的信息,replication 谁复制的多就选谁</p>
</blockquote>
<img src="../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401212047065.png" alt="image-20240401212047065" style="zoom: 33%;" />

<img src="../blog_images/Redis-%E5%93%A8%E5%85%B5/image-20240401212224451.png" alt="image-20240401212224451" style="zoom:33%;" />

<h4 id="执行slaveof-no-one命令让选出来的从节点成为新的主节点-并通过slaveof命令让其他节点成为其从节点"><a href="#执行slaveof-no-one命令让选出来的从节点成为新的主节点-并通过slaveof命令让其他节点成为其从节点" class="headerlink" title="执行slaveof no one命令让选出来的从节点成为新的主节点,并通过slaveof命令让其他节点成为其从节点"></a>执行slaveof no one命令让选出来的从节点成为新的主节点,并通过slaveof命令让其他节点成为其从节点</h4><p>Sentinel leader会对选举出的新master执行slaveof no one 操作,将其提升为master节点</p>
<p>sentinel leader向其他slave发送命令,让剩余的slave成为新的master节点的slave</p>
<h1 id="哨兵使用建议"><a href="#哨兵使用建议" class="headerlink" title="哨兵使用建议"></a>哨兵使用建议</h1><ul>
<li>哨兵系欸但的数量应该为多个,哨兵本身应该集群,保证高可用</li>
<li>哨兵节点的数量应该是奇数</li>
<li>各个哨兵节点的配置应该是一致的.最好硬件一样</li>
<li>如果哨兵节点部署在Docker等容器里面,尤其是注意端口的正确映射</li>
<li>哨兵集群+主从复制,并不能保证数据的零丢失</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/01/Redis-%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/Redis-%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">Redis-复制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-01 15:39:45 / 修改时间：16:57:36" itemprop="dateCreated datePublished" datetime="2024-04-01T15:39:45+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Redis复制（replica）"><a href="#Redis复制（replica）" class="headerlink" title="Redis复制（replica）"></a>Redis复制（replica）</h1><img src="../blog_images/Redis-%E5%A4%8D%E5%88%B6/image-20240401155246193.png" alt="image-20240401155246193" style="zoom:33%;" />

<blockquote>
<p>就是主从复制，master以写为主，Slave以读为主</p>
<p>当master数据变化的时候，自动iang新的数据异步同步到其他的slave数据库</p>
</blockquote>
<h2 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h2><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>写找master 读找slave</p>
<h3 id="容灾恢复"><a href="#容灾恢复" class="headerlink" title="容灾恢复"></a>容灾恢复</h3><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><h3 id="水平扩容支持高并发"><a href="#水平扩容支持高并发" class="headerlink" title="水平扩容支持高并发"></a>水平扩容支持高并发</h3><h2 id="怎么操作"><a href="#怎么操作" class="headerlink" title="怎么操作"></a>怎么操作</h2><blockquote>
<p>配置从库不配置主库</p>
</blockquote>
<img src="../blog_images/Redis-%E5%A4%8D%E5%88%B6/image-20240401155846349.png" alt="image-20240401155846349" style="zoom:25%;" />

<p>master 如果配置了requirepass参数，需要密码登录</p>
<p>那么slave就要配置masterauth来设置校验密码，否则master就会拒绝slave的访问请求。</p>
<h3 id="info-replication"><a href="#info-replication" class="headerlink" title="info replication"></a>info replication</h3><blockquote>
<p>建立了主从关系之后可以查看复制节点的主从关系和配置信息 </p>
</blockquote>
<h3 id="replicaof-主库IP-主库端口"><a href="#replicaof-主库IP-主库端口" class="headerlink" title="replicaof 主库IP 主库端口"></a>replicaof 主库IP 主库端口</h3><blockquote>
<p>在从机上写清楚,找哪个为主机,一般写入redis.conf配置文件内的</p>
</blockquote>
<h3 id="slaveof-主库IP-主库端口"><a href="#slaveof-主库IP-主库端口" class="headerlink" title="slaveof 主库IP 主库端口"></a>slaveof 主库IP 主库端口</h3><blockquote>
<p>有些类似于上一个指令(写进配置文件的) 的命令版本</p>
</blockquote>
<p>每次与master断开之后,都要重新连接,除非你配置进redis,conf文件</p>
<p><strong>&#x3D;&#x3D;在运行期间修改slave节点的消息,如果该数据库已经是某个主数据库的从数据库,那么就会停止和原主数据库的同步关系转而和新的数据库同步,重新设置主数据库&#x3D;&#x3D;</strong></p>
<h3 id="slaveof-no-one"><a href="#slaveof-no-one" class="headerlink" title="slaveof no one"></a>slaveof no one</h3><img src="../blog_images/Redis-%E5%A4%8D%E5%88%B6/image-20240401160806518.png" alt="image-20240401160806518" style="zoom:25%;" />

<p>使当前数据库停止与其他数据库的同步,转为主数据库</p>
<h3 id="复制的原理和工作流程"><a href="#复制的原理和工作流程" class="headerlink" title="复制的原理和工作流程"></a>复制的原理和工作流程</h3><p>1 slave 启动成功连接到master后会发送一个syncm’l</p>
<p>​    slave首次全新连接master,一次完全同步,(全量复制)将会被自动的执行,slave自身原有数据会被master数据覆盖</p>
<p><img src="/../blog_images/Redis-%E5%A4%8D%E5%88%B6/image-20240401163543131.png" alt="image-20240401163543131"></p>
<img src="../blog_images/Redis-%E5%A4%8D%E5%88%B6/image-20240401163830466.png" alt="image-20240401163830466" style="zoom:25%;" />

<h3 id="复制的缺点"><a href="#复制的缺点" class="headerlink" title="复制的缺点"></a>复制的缺点</h3><p>复制延时,信号衰减</p>
<p>master挂了怎么办?</p>
<p><img src="/../blog_images/Redis-%E5%A4%8D%E5%88%B6/image-20240401165735857.png" alt="image-20240401165735857"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/01/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/" class="post-title-link" itemprop="url">Redis-发布订阅</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-01 15:36:37 / 修改时间：15:40:00" itemprop="dateCreated datePublished" datetime="2024-04-01T15:36:37+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/../blog_images/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/image-20240401153705166.png" alt="image-20240401153705166"></p>
<p><img src="/../blog_images/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/image-20240401153751361.png" alt="image-20240401153751361"></p>
<img src="../blog_images/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/image-20240401153845316.png" alt="image-20240401153845316" style="zoom:33%;" />

<img src="../blog_images/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/image-20240401153902782.png" alt="image-20240401153902782" style="zoom:33%;" />

<p><img src="/../blog_images/Redis-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/image-20240401153920432.png" alt="image-20240401153920432"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/01/Redis-%E7%AE%A1%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/Redis-%E7%AE%A1%E9%81%93/" class="post-title-link" itemprop="url">Redis-管道</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-01 15:09:35 / 修改时间：15:33:59" itemprop="dateCreated datePublished" datetime="2024-04-01T15:09:35+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="管道pipelining"><a href="#管道pipelining" class="headerlink" title="管道pipelining"></a>管道pipelining</h1><p>redis事一种基于客户端-服务端模型以及请求&#x2F;响应协议的TCP服务，一个请求会遵循一下的步骤：</p>
<ol>
<li>客户端向服务端发送命令分四步（发送命令-&gt;命令排队-&gt;命令执行-&gt;返回结果），并监听socket返回，通常以阻塞模式等待服务端的响应。</li>
<li>服务端处理命令，并将结果返回给客户端</li>
</ol>
<p>&#x3D;&#x3D;以上两部称为 Round Trip Time&#x3D;&#x3D;</p>
<img src="../blog_images/Redis-%E7%AE%A1%E9%81%93/image-20240401151605018.png" alt="image-20240401151605018" style="zoom:33%;" />

 

<p><img src="/../blog_images/Redis-%E7%AE%A1%E9%81%93/image-20240401151638019.png" alt="image-20240401151638019"></p>
<p>管道的解决思路： 管<strong>道可以一次性的发送多条命令给服务端，服务端依次处理完毕之后，通过 一条响应一次寻的将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间</strong>。</p>
<p>将几个频繁往返的命令合起来</p>
<p>pipeline实现的原理是队列，先进先出特性就保证了数据的顺序性。</p>
<img src="../blog_images/Redis-%E7%AE%A1%E9%81%93/image-20240401151958228.png" alt="image-20240401151958228" style="zoom:33%;" />

<blockquote>
<p>&#x3D;&#x3D;批处理命令变种的优化措施，类似于Redis的原生批命令（mget和mset）&#x3D;&#x3D;</p>
</blockquote>
<img src="../blog_images/Redis-%E7%AE%A1%E9%81%93/image-20240401152633289.png" alt="image-20240401152633289" style="zoom:33%;" />

<img src="../blog_images/Redis-%E7%AE%A1%E9%81%93/image-20240401152656048.png" alt="image-20240401152656048" style="zoom:33%;" />

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="Pipeline-与原生批量命令对比"><a href="#Pipeline-与原生批量命令对比" class="headerlink" title="Pipeline 与原生批量命令对比"></a>Pipeline 与原生批量命令对比</h1><ul>
<li>原生命令是原子性的（例如mset、mget） 管道是非原子性的</li>
<li>原生批量命令只能执行一种命令，pipeline可以执行不同种的命令</li>
<li>原生批命令是服务端实现的 ，而pipeline需要服务端和客户端一起实现。</li>
</ul>
<h1 id="Pipeline与事务对比"><a href="#Pipeline与事务对比" class="headerlink" title="Pipeline与事务对比"></a>Pipeline与事务对比</h1><ul>
<li>事务具有原子性，管道是不具有原子性的</li>
<li>管道一次性将多条命令发送给服务器，事务是一条一条法的，事务只有在接收到exec命令之后才会执行</li>
<li>执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会。</li>
</ul>
<h1 id="使用Pipeline的注意事项"><a href="#使用Pipeline的注意事项" class="headerlink" title="使用Pipeline的注意事项"></a>使用Pipeline的注意事项</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/01/Redis-%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/01/Redis-%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">Redis-事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-04-01 13:07:31 / 修改时间：21:32:02" itemprop="dateCreated datePublished" datetime="2024-04-01T13:07:31+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p> 其实就是同一组指令需要一起执行。</p>
<p>一个队列中、一次性、顺序性、排他性的执行一系列的命令</p>
<h2 id="redis与数据库事务的区别"><a href="#redis与数据库事务的区别" class="headerlink" title="redis与数据库事务的区别"></a>redis与数据库事务的区别</h2><img src="../blog_images/Redis-%E4%BA%8B%E5%8A%A1/image-20240401135206539.png" alt="image-20240401135206539" style="zoom: 25%;" />

<h2 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h2><h3 id="case1：正常执行"><a href="#case1：正常执行" class="headerlink" title="case1：正常执行"></a>case1：正常执行</h3><h4 id="MULTI"><a href="#MULTI" class="headerlink" title="MULTI"></a>MULTI</h4><p>开启事务</p>
<img src="../blog_images/Redis-%E4%BA%8B%E5%8A%A1/image-20240401141119017.png" alt="image-20240401141119017" style="zoom:25%;" />

<p>后续的命令要加入这个是事务当中</p>
<h4 id="EXEC-结束"><a href="#EXEC-结束" class="headerlink" title="EXEC 结束"></a>EXEC 结束</h4><h3 id="case2：放弃事务"><a href="#case2：放弃事务" class="headerlink" title="case2：放弃事务"></a>case2：放弃事务</h3><h4 id="MULTI-1"><a href="#MULTI-1" class="headerlink" title="MULTI"></a>MULTI</h4><h4 id="DISCARD"><a href="#DISCARD" class="headerlink" title="DISCARD"></a>DISCARD</h4><p>这个输入之后就是全体放弃，之前执行一半的事务全部撤销</p>
<img src="../blog_images/Redis-%E4%BA%8B%E5%8A%A1/image-20240401141941014.png" alt="image-20240401141941014" style="zoom:33%;" />

<p>相当于一个是编译报错一个是运行时报错</p>
<h3 id="case3：全体连坐"><a href="#case3：全体连坐" class="headerlink" title="case3：全体连坐"></a>case3：全体连坐</h3><blockquote>
<p>一条命令出错全部打回去</p>
<p>语法出错了，直接编译就存在问题，当然执行不了</p>
</blockquote>
<img src="../blog_images/Redis-%E4%BA%8B%E5%8A%A1/image-20240401142255133.png" alt="image-20240401142255133" style="zoom:33%;" />

<h3 id="case4：冤有头债有主"><a href="#case4：冤有头债有主" class="headerlink" title="case4：冤有头债有主"></a>case4：冤有头债有主</h3><blockquote>
<p>对的执行，错的停止，类似于运行时异常，当一个命令失败了，</p>
<p>类似于语法没有检查出错误</p>
</blockquote>
<img src="../blog_images/Redis-%E4%BA%8B%E5%8A%A1/image-20240401142554856.png" alt="image-20240401142554856" style="zoom:33%;" />

<h3 id="case5：watch监控"><a href="#case5：watch监控" class="headerlink" title="case5：watch监控"></a>case5：watch监控</h3><p>redis会使用watch来提供乐观锁定，类似于CAS（check-and-Set）</p>
<blockquote>
<p>乐观锁：optimistic lock 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下再次期间别人有没有去更新这个数据</p>
<p>乐观锁的策略： 提交版本必须大于记录当前版本才能执行更新</p>
</blockquote>
<p>拿一个watch监控一个key，如果这个key在监控期间没有人动过，皆大欢喜，否则，本次执行的操作就会设置成一个null。</p>
<p>watch 初始化k1 和balance两个key，先监控再开启multi，保证两个key变动在同一个事务当中。</p>
<img src="../blog_images/Redis-%E4%BA%8B%E5%8A%A1/image-20240401144932380.png" alt="image-20240401144932380" style="zoom:33%;" />

<p><strong>有加塞篡改</strong></p>
<h3 id="case6：unwatch"><a href="#case6：unwatch" class="headerlink" title="case6：unwatch"></a>case6：unwatch</h3><p><img src="/../blog_images/Redis-%E4%BA%8B%E5%8A%A1/image-20240401145239659.png" alt="image-20240401145239659"></p>
<p>放弃监控</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一旦执行了exec之前加的监控锁都会被取消掉，当客户端连接丢失的时候（比如退出连接），所有的东西都会被取消监控</p>
<ul>
<li>开启：以MULTI 开启一个事务</li>
<li>入队：将多个命令入队到事务当中去，接到这些命令并不会立即的执行，而是会放到等待执行的事务队列中</li>
<li>执行：由EXEC命令触发事务</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/31/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/31/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">Redis-持久化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-31 21:15:11" itemprop="dateCreated datePublished" datetime="2024-03-31T21:15:11+08:00">2024-03-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-01 13:06:29" itemprop="dateModified" datetime="2024-04-01T13:06:29+08:00">2024-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>就是把数据写到磁盘里面。在实际的应用场景中，会存在服务器突然的宕机，数据全部打到mysql上，这个对于我们来说是灾难性的，所以我们需要让redis可以自己把数据写到服务器中</p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331212516033.png" alt="image-20240331212516033"></p>
<h2 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h2><p>RDB持久性以指定的时间间隔执行数据集的时间点快照。</p>
<p>实现类似于照片记录效果的方式，就是把某个时刻的数据与状态以文件的形式写到了磁盘的上面，也就是快照。这样一来，即使是服务器故障宕机，快照文件也不会丢失，数据的可靠性也得到了保证。</p>
<p>&#x3D;&#x3D;这个快照文件也被称为了RDB文件（dump.rdb),其中，RDB就是Redis Database的缩写&#x3D;&#x3D;</p>
<p>会直接去读这个dump.rdb文件，重新写回redis的缓存里</p>
<h3 id="Redis6与Redis7"><a href="#Redis6与Redis7" class="headerlink" title="Redis6与Redis7"></a>Redis6与Redis7</h3><p>在Redis7里面，把持久话RDB的保存规则发生了改变，尤其是时间记录额度的变化</p>
<p>vim redis7.conf,因为底层做了优化，所以不需要像之前一样记录的那么频繁了</p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331213643968.png" alt="image-20240331213643968"></p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331213709629.png" alt="image-20240331213709629"></p>
<h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>redis 默认使用</p>
<p>**<img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331230827587.png" alt="image-20240331230827587"><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331231302890.png" alt="image-20240331231302890"> </p>
<p>执行flashall&#x2F;flushdb命令也会产生dump.rdb文件，但是里里面是空的，没有意义</p>
<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>满足不了要求，但是希望是立马就备份，产生rdb文件，就需要开启手动的备份</p>
<p>redis提供了两个命令来生成RDB文件，分别是save喝bdsave</p>
<p>相当于在后台开启了一个子进程，可以立即的开启备份</p>
<img src="../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331232230372.png" alt="image-20240331232230372" style="zoom: 25%;" />

<p>生产上只能用bgsave，绝对不能用save</p>
<h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>在主程序中执行回阻塞当前的redis服务器，直到持久化工作完成执行save命令期间，redis是不能处理其他命令的，线上是禁止使用的</p>
<h4 id="bgsave（默认）"><a href="#bgsave（默认）" class="headerlink" title="bgsave（默认）"></a>bgsave（默认）</h4><p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331232606065.png" alt="image-20240331232606065"></p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331232850986.png" alt="image-20240331232850986"></p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331232902475.png" alt="image-20240331232902475"></p>
<p><strong>什么是fork</strong></p>
<p>在Linux系统中，fork会产生一个与父进程完全向同伴的一个子进程，但是子进程会在此后多会exec系统调用，处于效率考虑，尽量的避免膨胀</p>
<h4 id="lastsave"><a href="#lastsave" class="headerlink" title="lastsave"></a>lastsave</h4><p>可以通过lastsave命令去获取最后一次成功执行快照的时间</p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331233019774.png" alt="image-20240331233019774"></p>
<h3 id="RDB-优缺点"><a href="#RDB-优缺点" class="headerlink" title="RDB 优缺点"></a>RDB 优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>适合大规模的数据恢复</li>
<li>按照业务定时进行备份</li>
<li>对于数据的完整性喝一致性的要求不高</li>
<li>RDB文件在内存中的加载速度要比AOF快得多</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果你需要在redis停止工作时，比如断电之后，把损失降低到最低，那么rdb并不好</p>
<p>RDB需要经常的fork()以便使用子进程在磁盘上持久话，如果数据集很大，fork()可能会很耗时，并且数据集很大而且CPU性能不是很好的时候，可能会导致Redis停止为客户端服务几毫秒甚至于疫苗</p>
<p>如何检查并修复我们的RDB文件</p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331234106128.png" alt="image-20240331234106128"> </p>
<h3 id="如何禁用快照"><a href="#如何禁用快照" class="headerlink" title="如何禁用快照"></a>如何禁用快照</h3><p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331234255878.png" alt="image-20240331234255878"></p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331234309380.png" alt="image-20240331234309380"></p>
<h3 id="RDB优化配置项详解snapshotting模块"><a href="#RDB优化配置项详解snapshotting模块" class="headerlink" title="RDB优化配置项详解snapshotting模块"></a>RDB优化配置项详解snapshotting模块</h3><p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331234534060.png" alt="image-20240331234534060"></p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331234747105.png" alt="image-20240331234747105"></p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331234813084.png" alt="image-20240331234813084"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240331234853713.png" alt="image-20240331234853713"></p>
<h2 id="AOF-Append-Only-file"><a href="#AOF-Append-Only-file" class="headerlink" title="AOF(Append Only file)"></a>AOF(Append Only file)</h2><p>如果宕掉了，就load 数据 写回实例里。会以日志的形式记录下每个写的操作，然后将Redis执行过的所有写指令记录下来，（读操作不记录），只允许追加文件不允许改写文件，redis在启动之初会读取该文件重新构建数据。</p>
<p>—&#x3D;&#x3D;redis重启的话就会根据日志文件的内任凭将写指令从前到后执行一次以完成数据的恢复工作&#x3D;&#x3D;</p>
<p>默认情况下使用的AOF，开启AOF功能需要配置appendonly yes</p>
<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401095600434.png" alt="image-20240401095600434"></p>
<h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><h4 id="Always"><a href="#Always" class="headerlink" title="Always"></a>Always</h4><h4 id="everysec"><a href="#everysec" class="headerlink" title="everysec"></a>everysec</h4><h4 id="no"><a href="#no" class="headerlink" title="no"></a>no</h4><img src="../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401095655676.png" alt="image-20240401095655676" style="zoom:33%;" />

<img src="../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401095950257.png" alt="image-20240401095950257" style="zoom:33%;" />

<h3 id="redis6与redis7"><a href="#redis6与redis7" class="headerlink" title="redis6与redis7"></a>redis6与redis7</h3><p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401101931550.png" alt="image-20240401101931550"></p>
<h3 id="优点缺点"><a href="#优点缺点" class="headerlink" title="优点缺点"></a>优点缺点</h3><h4 id="优点：更好的保护数据不被丢失，性能高，可以做紧急恢复"><a href="#优点：更好的保护数据不被丢失，性能高，可以做紧急恢复" class="headerlink" title="优点：更好的保护数据不被丢失，性能高，可以做紧急恢复"></a>优点：更好的保护数据不被丢失，性能高，可以做紧急恢复</h4><ul>
<li>使用AOF redis更加的持久，你可以设计不同的fsync策略（三种写回策略），即使是每秒写入，写入的性能依旧是不错的，fsync是使用后台线程执行的，当没有fsync正在进行的时候，主线程会努力的执行写入，只会丢失一秒钟的写入。</li>
<li>AOF日志是一个仅附加日志，因此不会出现寻道问题，也不会在断电的时候出现损坏的问题，即使由于某种原因，磁盘已经满了或者其他的原因日志以写一般的命令结尾，redis-check-aof也能很轻松的修复。</li>
<li>当AOF变得太大的时候，redis能够在后台重写AOF，重写是完全安全的，因为当redis继续附加到旧文件时，会创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，redis就会切换两者并开始附加到新的那一个。</li>
<li>AOF以易于理解喝解析的格式依次包含所有操作的日志，您甚至可以轻松的导出AOF文件，如歌不小心使用了flushall命令刷新了所有的内容，只要在此期间内没有执行日志重写工作，您仍然可以通过停止服务器，删除最新命令并重新启动redis来保存数据集。</li>
</ul>
<p>打开appendonly.aof.1.incr.aof里面一定有个flushall，把这个命令删掉</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度要慢于rdb</li>
<li>aof运行的效率要慢于rdb，每秒同步策略的效率较好，不同步效率与rdb相同</li>
</ul>
<h4 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h4><p>由于AOF持久话是redis不断将写命令记录到AOF文件中，随着redis的不断的进行，AOF的文件就会越来越大，占用的服务器内存越大，以及AOF恢复时间要求越长。</p>
<p>&#x3D;&#x3D;为了解决这个问题，redis新增了重写机制，当AOF的文件的大小超过了所设定的峰值时，redis就会自动的<strong>启动AOF文件内容压缩，只保留恢复数据的最小指令集</strong>，或者<strong>手动使用命令bgrewriteaof</strong>&#x3D;&#x3D;</p>
<p><strong>峰值</strong></p>
<img src="../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401104852636.png" alt="image-20240401104852636" style="zoom:33%;" />

<img src="../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401104918329.png" alt="image-20240401104918329" style="zoom:33%;" />

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401110224729.png" alt="image-20240401110224729"></p>
<img src="../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401110249259.png" alt="image-20240401110249259" style="zoom:33%;" />

<h2 id="RDB-AOP混合持久化"><a href="#RDB-AOP混合持久化" class="headerlink" title="RDB-AOP混合持久化"></a>RDB-AOP混合持久化</h2><p>可以同时共存 ， AOF说的算</p>
<img src="../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401111518010.png" alt="image-20240401111518010" style="zoom:33%;" />

<p>在这种情况下，redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存。</p>
<p>设置aof-use-rdbpreamble都值为yes，yes表示开启设置no表示禁用</p>
<p>RDB镜像做全量吃就话，AOF做增量持久化</p>
<img src="../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401130144683.png" style="zoom:33%;" />

<p><img src="/../blog_images/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/image-20240401130628985.png" alt="image-20240401130628985"></p>
<h2 id="纯缓存模式"><a href="#纯缓存模式" class="headerlink" title="纯缓存模式"></a>纯缓存模式</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/31/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/31/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-31 17:13:55 / 修改时间：21:11:39" itemprop="dateCreated datePublished" datetime="2024-03-31T17:13:55+08:00">2024-03-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Linux下安装使用Redis"><a href="#Linux下安装使用Redis" class="headerlink" title="Linux下安装使用Redis"></a>Linux下安装使用Redis</h1><p><img src="/../blog_images/Redis/image-20240331183148156.png" alt="image-20240331183148156"></p>
<p><img src="/../blog_images/Redis/image-20240331183151856.png" alt="image-20240331183151856"></p>
<h2 id="1-打开-关闭redis命令"><a href="#1-打开-关闭redis命令" class="headerlink" title="1. 打开&#x2F;关闭redis命令"></a>1. 打开&#x2F;关闭redis命令</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a <span class="number">123456</span> -p <span class="number">6379</span></span><br><span class="line">quit//退出</span><br><span class="line">redis-cli -a <span class="number">123456</span> shutdown//单实例关闭</span><br><span class="line"> redis-cli -a <span class="number">123456</span> shutdown //多实例关闭</span><br></pre></td></tr></table></figure>

<h1 id="Redis的十大数据结构"><a href="#Redis的十大数据结构" class="headerlink" title="Redis的十大数据结构"></a>Redis的十大数据结构</h1><h2 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1. String 字符串"></a>1. String 字符串</h2><h2 id="2-List-列表"><a href="#2-List-列表" class="headerlink" title="2.List 列表"></a>2.List 列表</h2><h2 id="3-Hash哈希表"><a href="#3-Hash哈希表" class="headerlink" title="3.Hash哈希表"></a>3.Hash哈希表</h2><h2 id="4-Set集合"><a href="#4-Set集合" class="headerlink" title="4.Set集合"></a>4.Set集合</h2><h2 id="5-ZSet-redis有序集合"><a href="#5-ZSet-redis有序集合" class="headerlink" title="5.ZSet redis有序集合"></a>5.ZSet redis有序集合</h2><h2 id="6-GEO-地理空间"><a href="#6-GEO-地理空间" class="headerlink" title="6.GEO 地理空间"></a>6.GEO 地理空间</h2><h2 id="7-HyperLogLog-基数统计"><a href="#7-HyperLogLog-基数统计" class="headerlink" title="7.HyperLogLog 基数统计"></a>7.HyperLogLog 基数统计</h2><h2 id="8-bitmap位图"><a href="#8-bitmap位图" class="headerlink" title="8.bitmap位图"></a>8.bitmap位图</h2><h2 id="9-bitfield位域"><a href="#9-bitfield位域" class="headerlink" title="9.bitfield位域"></a>9.bitfield位域</h2><h2 id="10-Stream流"><a href="#10-Stream流" class="headerlink" title="10.Stream流"></a>10.Stream流</h2><h1 id="Redis基础操作"><a href="#Redis基础操作" class="headerlink" title="Redis基础操作"></a>Redis基础操作</h1><p><img src="/../blog_images/Redis/image-20240331174848465.png" alt="image-20240331174848465"></p>
<p>del key 是原子的</p>
<p>unlink key 是非阻塞删除</p>
<p>redis默认是16个库，默认使用的是0号库</p>
<p>keepTTL</p>
<p><img src="/../blog_images/Redis/image-20240331181959700.png" alt="image-20240331181959700"></p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="最常用"><a href="#最常用" class="headerlink" title="最常用"></a>最常用</h3><p>set、get、ttl</p>
<h3 id="同时设置-获取多个键值"><a href="#同时设置-获取多个键值" class="headerlink" title="同时设置&#x2F;获取多个键值"></a>同时设置&#x2F;获取多个键值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MSET Key value [key value]</span><br><span class="line">MGET key [key ...]</span><br><span class="line">mset/mget/msetnx</span><br><span class="line">msetnx:不存在的时候才创建，此外，这个命令有点像事务的完整性，只有全部成功才会创建</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Redis/image-20240331182938441.png" alt="image-20240331182938441"></p>
<p><img src="/../blog_images/Redis/image-20240331183123246.png" alt="image-20240331183123246"></p>
<h3 id="获取指定区间范围内的值"><a href="#获取指定区间范围内的值" class="headerlink" title="获取指定区间范围内的值"></a>获取指定区间范围内的值</h3><h4 id="GETRANGE-k1-0-1"><a href="#GETRANGE-k1-0-1" class="headerlink" title="GETRANGE k1 0 -1"></a>GETRANGE k1 0 -1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GETRANGE k1 0 -1</span><br><span class="line">// 对于string就是获得子串 类似于substring</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Redis/image-20240331183849993.png" alt="image-20240331183849993"></p>
<h4 id="SETRANGE-k1-xxyy"><a href="#SETRANGE-k1-xxyy" class="headerlink" title="SETRANGE k1 xxyy"></a>SETRANGE k1 xxyy</h4><p>从第一位开始， 用‘xxyy’全部覆盖</p>
<p><img src="/../blog_images/Redis/image-20240331184034033.png" alt="image-20240331184034033"></p>
<h3 id="数值的增减"><a href="#数值的增减" class="headerlink" title="数值的增减"></a>数值的增减</h3><h4 id="INCR-K1"><a href="#INCR-K1" class="headerlink" title="INCR K1"></a>INCR K1</h4><p>表示自增1</p>
<h4 id="DECR"><a href="#DECR" class="headerlink" title="DECR"></a>DECR</h4><p>表示自减</p>
<h4 id="DECRBY-k1-5"><a href="#DECRBY-k1-5" class="headerlink" title="DECRBY k1 5"></a>DECRBY k1 5</h4><p><img src="/../blog_images/Redis/image-20240331194044855.png" alt="image-20240331194044855"></p>
<p><img src="/../blog_images/Redis/image-20240331194106413.png" alt="image-20240331194106413"></p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="/../blog_images/Redis/image-20240331194142112.png" alt="image-20240331194142112"></p>
<p>之前的sync&#x2F;lock&#x2F;unlock 只能在<strong>一个jvm</strong>中保证加锁，</p>
<p><img src="/../blog_images/Redis/image-20240331194937034.png" alt="image-20240331194937034"></p>
<h4 id="setex-k1-15-hello"><a href="#setex-k1-15-hello" class="headerlink" title="setex k1 15 hello"></a>setex k1 15 hello</h4><p>设置 key 过期时间 value</p>
<img src="../blog_images/Redis/image-20240331195300058.png" alt="image-20240331195300058" style="zoom:50%;" />

<h3 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h3><p>先get再set</p>
<h2 id="List-Redis-列表"><a href="#List-Redis-列表" class="headerlink" title="List Redis 列表"></a>List Redis 列表</h2><p>底层是一个&#x3D;&#x3D;双端链表&#x3D;&#x3D;的结构，大概有40多个亿，主要功能有push&#x2F;pop等，一般用在栈、队列、消息队列等场景中。</p>
<p>left和right都可以加入</p>
<p>如果键不存在，就创建一个新的连别</p>
<p>如果键存在，就新增内容</p>
<p>如果值全部被移除了，对应的键也会消失</p>
<blockquote>
<p>对于两端的操作性能是很强的，对于索引下标的操作中间的节点性能就会比较差</p>
</blockquote>
<h3 id="lpush-rpush-lrange"><a href="#lpush-rpush-lrange" class="headerlink" title="lpush&#x2F;rpush&#x2F;lrange"></a>lpush&#x2F;rpush&#x2F;lrange</h3><p><img src="/../blog_images/Redis/image-20240331201214038.png" alt="image-20240331201214038"></p>
<h3 id="lpop-rpop"><a href="#lpop-rpop" class="headerlink" title="lpop&#x2F;rpop"></a>lpop&#x2F;rpop</h3><p><img src="/../blog_images/Redis/image-20240331201351026.png" alt="image-20240331201351026"></p>
<h3 id="lindex-按照索引的下标获得元素（从上至下）"><a href="#lindex-按照索引的下标获得元素（从上至下）" class="headerlink" title="lindex 按照索引的下标获得元素（从上至下）"></a>lindex 按照索引的下标获得元素（从上至下）</h3><p><img src="/../blog_images/Redis/image-20240331201559339.png" alt="image-20240331201559339"></p>
<h3 id="llen-获取列表中元素的个数"><a href="#llen-获取列表中元素的个数" class="headerlink" title="llen 获取列表中元素的个数"></a>llen 获取列表中元素的个数</h3><h3 id="lrem-key-数字N给定值v1-（删除N个值等于V1的元素）、"><a href="#lrem-key-数字N给定值v1-（删除N个值等于V1的元素）、" class="headerlink" title="lrem key 数字N给定值v1 （删除N个值等于V1的元素）、"></a>lrem key 数字N给定值v1 （删除N个值等于V1的元素）、</h3><img src="../blog_images/Redis/image-20240331201925609.png" alt="image-20240331201925609" style="zoom:50%;" />

<p>删除list1里面三个值为1的元素</p>
<h3 id="ltrim-key-开始index-结束index-，截取指定范围内的值再赋值给key"><a href="#ltrim-key-开始index-结束index-，截取指定范围内的值再赋值给key" class="headerlink" title="ltrim key 开始index 结束index ，截取指定范围内的值再赋值给key"></a>ltrim key 开始index 结束index ，截取指定范围内的值再赋值给key</h3><p><img src="/../blog_images/Redis/image-20240331202135633.png" alt="image-20240331202135633"></p>
<h3 id="rpoplpush-源列表-目的列表"><a href="#rpoplpush-源列表-目的列表" class="headerlink" title="rpoplpush 源列表 目的列表"></a>rpoplpush 源列表 目的列表</h3><p><img src="/../blog_images/Redis/image-20240331202408163.png" alt="image-20240331202408163"></p>
<h3 id="lset-key-index-value"><a href="#lset-key-index-value" class="headerlink" title="lset key index value"></a>lset key index value</h3><p><img src="/../blog_images/Redis/image-20240331202503414.png" alt="image-20240331202503414"></p>
<h3 id="linset-key-before-after-已有的值插入新的值"><a href="#linset-key-before-after-已有的值插入新的值" class="headerlink" title="linset key before &#x2F;after 已有的值插入新的值"></a>linset key before &#x2F;after 已有的值插入新的值</h3><p><img src="/../blog_images/Redis/image-20240331202637152.png" alt="image-20240331202637152"></p>
<h2 id="Hash（）"><a href="#Hash（）" class="headerlink" title="Hash（）"></a>Hash（）</h2><p>kv键值对的结构不变，但是v是一个新的键值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String , Map&lt;Object,Object&gt;&gt;</span><br></pre></td></tr></table></figure>



<h3 id="hset-hget-hmset-hmget-hgetall-hdel"><a href="#hset-hget-hmset-hmget-hgetall-hdel" class="headerlink" title="hset&#x2F;hget&#x2F;hmset&#x2F;hmget&#x2F;hgetall&#x2F;hdel"></a>hset&#x2F;hget&#x2F;hmset&#x2F;hmget&#x2F;hgetall&#x2F;hdel</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset key 字段1 value1 字段2 value2 字段3 value3...</span><br></pre></td></tr></table></figure>

<img src="../blog_images/Redis/image-20240331203248639.png" alt="image-20240331203248639" style="zoom:33%;" />



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有什么区别</span><br><span class="line">hmset/hmget</span><br></pre></td></tr></table></figure>

<img src="../blog_images/Redis/image-20240331203424491.png" alt="image-20240331203424491" style="zoom:33%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hgetall/hdel</span><br></pre></td></tr></table></figure>

<p>hgetall类似于遍历，hdel就是删掉</p>
<img src="../blog_images/Redis/image-20240331203632378.png" alt="image-20240331203632378" style="zoom:50%;" />

<h3 id="hlen-获取某个key中的全部的数量"><a href="#hlen-获取某个key中的全部的数量" class="headerlink" title="hlen 获取某个key中的全部的数量"></a>hlen 获取某个key中的全部的数量</h3><img src="../blog_images/Redis/image-20240331203807798.png" alt="image-20240331203807798" style="zoom:33%;" />

<h3 id="hexists-key-判断在key里面的某个值的key"><a href="#hexists-key-判断在key里面的某个值的key" class="headerlink" title="hexists key 判断在key里面的某个值的key"></a>hexists key 判断在key里面的某个值的key</h3><p><img src="/../blog_images/Redis/image-20240331203900374.png" alt="image-20240331203900374"></p>
<h3 id="hkeys-hvals"><a href="#hkeys-hvals" class="headerlink" title="hkeys&#x2F;hvals"></a>hkeys&#x2F;hvals</h3><p>罗列key和value</p>
<img src="../blog_images/Redis/image-20240331204001831.png" alt="image-20240331204001831" style="zoom:33%;" />

<h3 id="hincrby-hincrbyfloat"><a href="#hincrby-hincrbyfloat" class="headerlink" title="hincrby&#x2F;hincrbyfloat"></a>hincrby&#x2F;hincrbyfloat</h3><p>增加</p>
<p><img src="/../blog_images/Redis/image-20240331204104566.png" alt="image-20240331204104566"></p>
<p><img src="/../blog_images/Redis/image-20240331204313354.png" alt="image-20240331204313354"></p>
<h3 id="hsetnx-（就是set的性质"><a href="#hsetnx-（就是set的性质" class="headerlink" title="hsetnx （就是set的性质"></a>hsetnx （就是set的性质</h3><p><img src="/../blog_images/Redis/image-20240331204340967.png" alt="image-20240331204340967"></p>
<img src="../blog_images/Redis/image-20240331204227917.png" alt="image-20240331204227917" style="zoom:50%;" />

<p>购物车</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>单个值可以有多个value ，但是每个值都不能重复</p>
<p><img src="/../blog_images/Redis/image-20240331204829210.png" alt="image-20240331204829210"></p>
<h3 id="SADD-自动去重"><a href="#SADD-自动去重" class="headerlink" title="SADD 自动去重"></a>SADD 自动去重</h3><p><img src="/../blog_images/Redis/image-20240331205105464.png" alt="image-20240331205105464"></p>
<h3 id="SMEMEBERS-set1遍历"><a href="#SMEMEBERS-set1遍历" class="headerlink" title="SMEMEBERS set1遍历"></a>SMEMEBERS set1遍历</h3><img src="../blog_images/Redis/image-20240331205144592.png" alt="image-20240331205144592" style="zoom:33%;" />



<img src="../blog_images/Redis/image-20240331205332306.png" alt="image-20240331205332306" style="zoom:33%;" />

<h3 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h3><p><img src="/../blog_images/Redis/image-20240331205619186.png" alt="image-20240331205619186"></p>
<p><img src="/../blog_images/Redis/image-20240331205705964.png" alt="image-20240331205705964"></p>
<p><img src="/../blog_images/Redis/image-20240331205758175.png" alt="image-20240331205758175"></p>
<h2 id="Zset（sorted-set-有序集合"><a href="#Zset（sorted-set-有序集合" class="headerlink" title="Zset（sorted set)有序集合"></a>Zset（sorted set)有序集合</h2><h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><h2 id="Stream（redis-版本的MQ）消息中间件"><a href="#Stream（redis-版本的MQ）消息中间件" class="headerlink" title="Stream（redis 版本的MQ）消息中间件"></a>Stream（redis 版本的MQ）消息中间件</h2><blockquote>
<p>MQ 包含Kafka RabbitMQ rocketmq等</p>
<p>先去学了MQ</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/18/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/18/Docker/" class="post-title-link" itemprop="url">Docker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-03-18 10:53:35 / 修改时间：11:24:16" itemprop="dateCreated datePublished" datetime="2024-03-18T10:53:35+08:00">2024-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">中间件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、容器"><a href="#一、容器" class="headerlink" title="一、容器"></a>一、容器</h1><h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>将软件打包成标准化单元，以用于开发、交付与部署</p>
<h1 id="二、Docker"><a href="#二、Docker" class="headerlink" title="二、Docker"></a>二、Docker</h1><p><strong>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；——一致的运行环境</strong></p>
<p><strong>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</strong></p>
<p><strong>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</strong></p>
<p><strong>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</strong></p>
<p><strong>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</strong></p>
<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署</p>
<h1 id="三-容器VS虚拟机"><a href="#三-容器VS虚拟机" class="headerlink" title="三 容器VS虚拟机"></a>三 容器VS虚拟机</h1><p>简单来说：容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</p>
<h2 id="3-1-两者对比图"><a href="#3-1-两者对比图" class="headerlink" title="3.1 两者对比图"></a>3.1 两者对比图</h2><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<hr>
<p>传统的虚拟机技术是虚拟出一套硬件之后，在其上运行一套完整的操作系统，然后在该操作系统上再运行所需要的应用进程；而容器内的应用进程直接运行于宿主的内核，容器中没有自己的内核，而且也没有进行硬件虚拟，因此容器要比传统虚拟机更加的轻便。</p>
<p><img src="/../blog_images/Docker/image-20240318111036086.png" alt="image-20240318111036086"></p>
<h2 id="3-2-容器与虚拟机总结"><a href="#3-2-容器与虚拟机总结" class="headerlink" title="3.2 容器与虚拟机总结"></a>3.2 容器与虚拟机总结</h2><p><img src="/../blog_images/Docker/image-20240318111314460.png" alt="image-20240318111314460"></p>
<p><strong>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。</strong> <strong>多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行</strong> 。与虚拟机相比， <strong>容器占用的空间较少</strong>（容器镜像大小通常只有几十兆），<strong>瞬间就能完成启动</strong> 。</p>
<p><strong>虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。</strong> 管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 <strong>占用大量空间</strong> 。而且 VM <strong>启动也十分缓慢</strong> 。</p>
<p>通过 Docker 官网，我们知道了这么多 Docker 的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。<strong>虚拟机更擅长于彻底隔离整个运行环境</strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 <strong>Docker 通常用于隔离不同的应用</strong> ，例如前端，后端以及数据库</p>
<h2 id="3-3容器与虚拟机两者是可以共存的"><a href="#3-3容器与虚拟机两者是可以共存的" class="headerlink" title="3.3容器与虚拟机两者是可以共存的"></a>3.3容器与虚拟机两者是可以共存的</h2><p><img src="/../blog_images/Docker/image-20240318111806112.png" alt="image-20240318111806112"></p>
<h1 id="四、Docker基本概念"><a href="#四、Docker基本概念" class="headerlink" title="四、Docker基本概念"></a>四、Docker基本概念</h1><p><strong>Docker 中有非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。</strong></p>
<ul>
<li><strong>镜像（Image）</strong></li>
<li><strong>容器（Container）</strong></li>
<li><strong>仓库（Repository）</strong></li>
</ul>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期</p>
<p><img src="/../blog_images/Docker/image-20240318111954221.png" alt="image-20240318111954221"></p>
<h2 id="镜像：一个特殊的文件系统"><a href="#镜像：一个特殊的文件系统" class="headerlink" title="镜像：一个特殊的文件系统"></a>镜像：一个特殊的文件系统</h2><p><strong>操作系统分为内核和用户空间</strong>。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。</p>
<p><strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong> 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>Docker 设计时，就充分利用 <strong>Union FS</strong> 的技术，&#x3D;&#x3D;将其设计为<strong>分层存储的架构</strong> 。镜像实际是由多层文件系统联合组成。&#x3D;&#x3D;</p>
<p><strong>&#x3D;&#x3D;镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong>&#x3D;&#x3D; 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是&#x3D;&#x3D;仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。&#x3D;&#x3D;因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以&#x3D;&#x3D;用之前构建好的镜像作为基础层&#x3D;&#x3D;，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h2 id="容器-镜像运行时的实体"><a href="#容器-镜像运行时的实体" class="headerlink" title="容器:镜像运行时的实体"></a>容器:镜像运行时的实体</h2><p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/open in new window</a> 。官方是这样介绍 Docker Hub 的</p>
<hr>
<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a target="_blank" rel="noopener" href="https://javaguide.cn/tools/docker/docker-intro.html">https://javaguide.cn/tools/docker/docker-intro.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/03/17/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="lolo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Loloooo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Loloooo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/17/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/" class="post-title-link" itemprop="url">Java微服务3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-17 21:42:41" itemprop="dateCreated datePublished" datetime="2024-03-17T21:42:41+08:00">2024-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-18 13:54:48" itemprop="dateModified" datetime="2024-03-18T13:54:48+08:00">2024-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java体系知识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E4%BD%93%E7%B3%BB%E7%9F%A5%E8%AF%86/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="服务保护和分布式事务"><a href="#服务保护和分布式事务" class="headerlink" title="服务保护和分布式事务"></a>服务保护和分布式事务</h1><p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317214812012.png" alt="image-20240317214812012">有个服务很高 一个服务就所有的线程和进程全占了</p>
<p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317215027907.png" alt="image-20240317215027907"></p>
<h2 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h2><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。</p>
<p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317215511651.png" alt="image-20240317215511651"></p>
<h3 id="雪崩问题产生的原因是什么？"><a href="#雪崩问题产生的原因是什么？" class="headerlink" title="雪崩问题产生的原因是什么？"></a>雪崩问题产生的原因是什么？</h3><ul>
<li>微服务相互调用，服务提供者出现故障或阻塞。</li>
<li>服务调用者没有做好异常处理，导致自身故障。</li>
<li>调用链中的所有服务级联失败，导致整个集群故障</li>
</ul>
<h3 id="解决问题的思路有哪些？"><a href="#解决问题的思路有哪些？" class="headerlink" title="解决问题的思路有哪些？"></a>解决问题的思路有哪些？</h3><ul>
<li>尽量避免服务出现故障或阻塞。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">保证代码的健壮性；</span><br><span class="line"></span><br><span class="line">保证网络畅通；</span><br><span class="line"></span><br><span class="line">能应对较高的并发请求；</span><br></pre></td></tr></table></figure>

<ul>
<li>服务调用者做好远程调用异常的后备方案，避免故障扩散</li>
</ul>
<h3 id="服务保护方案"><a href="#服务保护方案" class="headerlink" title="服务保护方案"></a>服务保护方案</h3><h4 id="请求限流"><a href="#请求限流" class="headerlink" title="- 请求限流"></a>- 请求限流</h4><p>限制访问接口的请求的并发量，避免服务因流量激增出现故障。</p>
<p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317220549992.png" alt="image-20240317220549992"></p>
<h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h4><p>线程隔离：也叫做舱壁模式，模拟船舱隔板的防水原理。通过限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散。</p>
<p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317220702031.png" alt="image-20240317220702031"></p>
<h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>服务熔断：由<strong>断路器</strong>统计请求的异常比例或慢&#x3D;&#x3D;调用比例&#x3D;&#x3D;，如果超出阈值则会<strong>熔断</strong>该业务，则拦截该接口的请求。</p>
<p>熔断期间，所有请求快速失败，全都走fallback逻辑。</p>
<p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317223937333.png" alt="image-20240317223937333"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>请求限流</strong>：限制流量在服务可以处理的范围，避免因突发流量而故障</p>
<p><strong>线程隔离</strong>：控制业务可用的线程数量，将故障隔离在一定范围</p>
<p><strong>失败处理</strong>：定义fallback逻辑，让业务失败时不再抛出异常，而是走fallback逻辑</p>
<p><strong>服务熔断</strong>：将异常比例过高的接口断开，拒绝所有请求，直接走fallback</p>
<h3 id="服务保护技术"><a href="#服务保护技术" class="headerlink" title="服务保护技术"></a>服务保护技术</h3><table>
<thead>
<tr>
<th></th>
<th><strong>Sentinel</strong></th>
<th><strong>Hystrix</strong></th>
</tr>
</thead>
<tbody><tr>
<td>线程隔离</td>
<td>信号量隔离</td>
<td>线程池隔离&#x2F;信号量隔离</td>
</tr>
<tr>
<td>熔断策略</td>
<td>基于慢调用比例或异常比例</td>
<td>基于异常比率</td>
</tr>
<tr>
<td>限流</td>
<td>基于 QPS，支持流量整形</td>
<td>有限的支持</td>
</tr>
<tr>
<td>Fallback</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>控制台</td>
<td>开箱即用，可配置规则、查看秒级监控、机器发现等</td>
<td>不完善</td>
</tr>
<tr>
<td>配置方式</td>
<td>基于控制台，重启后失效</td>
<td>基于注解或配置文件，永久生效</td>
</tr>
</tbody></table>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/index.html"> https://sentinelguard.io/zh-cn/index.html</a></p>
<p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317224540969.png" alt="image-20240317224540969"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="step1-导包"><a href="#step1-导包" class="headerlink" title="step1 导包"></a>step1 导包</h4><p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317224630323.png" alt="image-20240317224630323"></p>
<h4 id="step2-配置控制台"><a href="#step2-配置控制台" class="headerlink" title="step2 配置控制台"></a>step2 配置控制台</h4><p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317224644608.png" alt="image-20240317224644608"></p>
<h4 id="step3-重启访问"><a href="#step3-重启访问" class="headerlink" title="step3 重启访问"></a>step3 重启访问</h4><p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317224807401.png" alt="image-20240317224807401"></p>
<h3 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a><strong>簇点链路</strong></h3><p>就是单机调用链路。是一次请求进入服务后经过的每一个被Sentinel监控的资源链。默认Sentinel会监控SpringMVC的每一个Endpoint（http接口）。限流、熔断等都是针对簇点链路中的<strong>资源</strong>设置的。而资源名默认就是接口的请求路径：</p>
<p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317224937069.png" alt="image-20240317224937069"></p>
<p>熔断什么的都是针对簇点资源做的</p>
<p>Restful风格的API请求路径一般都相同，这会导致簇点资源名称重复。因此我们要修改配置，把<strong>请求方式+请求路径</strong>作为簇点资源名称：</p>
<p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240317225139867.png" alt="image-20240317225139867"></p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>在分布式系统中，如果一个业务需要多个服务合作完成，而且每一个服务都有事务，&#x3D;&#x3D;多个事务必须同时成功或失败，这样的事务就是<strong>分布式事务</strong>。其中的每个服务的事务就是一个<strong>分支事务</strong>。整个业务称为<strong>全局事务</strong>。&#x3D;&#x3D;</p>
<p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240318095044645.png" alt="image-20240318095044645"></p>
<h3 id="初识Seata"><a href="#初识Seata" class="headerlink" title="初识Seata"></a>初识Seata</h3><p>解决分布式事务，各个子事务之间必须能感知到彼此的事务状态，才能保证状态一致。</p>
<p>Seata事务管理中有三个重要的角色：</p>
<p>•<strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</p>
<p>•<strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</p>
<p>•<strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态</p>
<p><img src="/../blog_images/Java%E5%BE%AE%E6%9C%8D%E5%8A%A13/image-20240318095501708.png" alt="image-20240318095501708"></p>
<h3 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h3><h3 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata</h3><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">lolo</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
