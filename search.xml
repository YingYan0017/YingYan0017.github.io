<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2024/02/18/20240217%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A31/</url>
    <content><![CDATA[<h1 id="一、技术的版本控制"><a href="#一、技术的版本控制" class="headerlink" title="一、技术的版本控制"></a>一、技术的版本控制</h1><p><img src="/../blog_images/20240217%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A31/image-20240218015738084.png" alt="image-20240218015738084"></p>
<p><img src="/../blog_images/20240217%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A31/image-20240218015750388.png" alt="image-20240218015750388"></p>
<h1 id="二、动力云客的项目概述"><a href="#二、动力云客的项目概述" class="headerlink" title="二、动力云客的项目概述"></a>二、动力云客的项目概述</h1><p>这个项目就是一个商业的集合营销销售为一体的客户关系管理系统，采用信息化、数字化的方式来进行营销和看客户管理。</p>
<h2 id="1-项目数据库：Mysql一个数据库"><a href="#1-项目数据库：Mysql一个数据库" class="headerlink" title="1.项目数据库：Mysql一个数据库"></a>1.项目数据库：Mysql一个数据库</h2><h2 id="2-前端项目："><a href="#2-前端项目：" class="headerlink" title="2.前端项目："></a>2.前端项目：</h2><p> 这是一个前后端分离的项目 （前端vue–&gt;（ajax axios） http请求–&gt;后端项目（spring boot）</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/18/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h1 id="Java-基础部分"><a href="#Java-基础部分" class="headerlink" title="Java 基础部分"></a>Java 基础部分</h1><h2 id="P18"><a href="#P18" class="headerlink" title="P18"></a>P18</h2><h3 id="一、基础知识细节"><a href="#一、基础知识细节" class="headerlink" title="一、基础知识细节"></a>一、基础知识细节</h3><ol>
<li><p>编译java代码 ： javac HelloWorld.java</p>
</li>
<li><p>main方法是JVM规定的，程序就是从这个位置执行的，程序的入口</p>
</li>
<li><p>public class 和class的区别</p>
</li>
</ol>
<h2 id="P19-public-class和class的区别"><a href="#P19-public-class和class的区别" class="headerlink" title="P19 public class和class的区别"></a>P19 public class和class的区别</h2><ol>
<li><p>一个java源文件中可以生成多个源文件 ；</p>
</li>
<li><p>编译后，一个class对应生成一个class字节码文件</p>
</li>
</ol>
<img src="../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223111209337.png" alt="image-20240223111209337" style="zoom:50%;" />

<ol start="3">
<li><p>如果一个类是public的，那么这个类名要和文件名保持一致，如果不一致就会报错。</p>
</li>
<li><p>一个java文件里，public class可以没有，如果有也只能有一个。</p>
</li>
<li><p>每个类里面都可以写入口main函数 ，执行只需要 java 类名</p>
<blockquote>
<p>在实际的开发中，入口只能有一个</p>
</blockquote>
</li>
</ol>
<img src="../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223111722726.png" alt="image-20240223111722726" style="zoom:50%;" />

<h2 id="JAVA基础语法"><a href="#JAVA基础语法" class="headerlink" title="JAVA基础语法"></a>JAVA基础语法</h2><h3 id="一、标识符"><a href="#一、标识符" class="headerlink" title="一、标识符"></a>一、标识符</h3><blockquote>
<p>凡是有权利自己起名的都是标识符，比如类名等</p>
</blockquote>
<p>①在Java中，标识符是用来给变量、方法、类和包等命名的字符序列。</p>
<p>②标识符的长度没有限制，但是建议使用有意义的、简洁的标识符，以提高代码的可读性和可维护性。</p>
<h4 id="标识符可以标识什么"><a href="#标识符可以标识什么" class="headerlink" title="标识符可以标识什么"></a><strong>标识符可以标识什么</strong></h4><p>①变量名</p>
<p>②方法名</p>
<p>③类名、接口名、枚举名、注解名</p>
<p>④包名</p>
<p>⑤常量名</p>
<p>⑥……</p>
<h4 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h4><p>①标识符可以由字母、数字、下划线(_)和美元符号($)组成，不能含有其他符号。（java支持全球所有语言，所以这里的 字母 指的是任何一个国家的文字都可以）</p>
<p>②标识符不能以数字开头。</p>
<p>③标识符不能是Java中的关键字，如public、class、void等。</p>
<p>④标识符是区分大小写的，即Foo和foo是两个不同的标识符。</p>
<p>⑤标识符的长度没有限制，但是Java建议使用有意义的、简短的标识符。</p>
<h4 id="标识符命名规范"><a href="#标识符命名规范" class="headerlink" title="标识符命名规范"></a><strong>标识符命名规范</strong></h4><p>①见名知意</p>
<p>②驼峰式命名方式</p>
<p>③类名、接口名、枚举、注解：首字母大写，后面每个单词首字母大写。（StudentService，UserService）</p>
<p>④变量名和方法名：首字母小写，后面每个单词首字母大写。（doSome，doOther）</p>
<p>⑤常量名：全部大写，每个单词用下划线连接。（LOGIN_SUCCESS，SYSTEM_ERROR）</p>
<p>⑥包名：全部小写    </p>
<h3 id="二、关键字"><a href="#二、关键字" class="headerlink" title="二、关键字"></a>二、关键字</h3><blockquote>
<p>Java关键字是Java编程语言中预定义的具有特殊含义的单词，这些单词不能被用作标识符，而是在语法中有特定的用法和限制。</p>
</blockquote>
<h4 id="Java关键字有哪些"><a href="#Java关键字有哪些" class="headerlink" title="Java关键字有哪些"></a>Java关键字有哪些</h4><p>①Java关键字都是小写的。</p>
<p>②abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, extends, final, finally, float, for, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while（50）</p>
<p>③Java保留字：goto，const(虽然没有在java中用到，但是不能用)</p>
<h3 id="三、字面量"><a href="#三、字面量" class="headerlink" title="三、字面量"></a>三、字面量</h3><blockquote>
<p>①字面量指的是在程序中直接使用的数据，字面量是Java中最基本的表达式，不需要进行计算或转换，直接使用即可。</p>
<p>就是数据</p>
</blockquote>
<h4 id="Java中有哪些字面量"><a href="#Java中有哪些字面量" class="headerlink" title="Java中有哪些字面量"></a>Java中有哪些字面量</h4><p>①整数型：10、-5、0、100</p>
<p>②浮点型：3.14、-0.5、1.0</p>
<p>③布尔型：true、false</p>
<p>④字符型：’a’、’b’、’c’、’1’、’2’、’国’</p>
<p>⑤字符串型：”Hello”、”World”、”Java”、”你好呀”</p>
<h4 id="加号运算符"><a href="#加号运算符" class="headerlink" title="加号运算符 +"></a>加号运算符 +</h4><p>①作用1：求和（当加号两边都是数字时进行求和运算）</p>
<p>②作用2：字符串拼接（当加号&#x3D;&#x3D;两边有任意一边是字符串类型&#x3D;&#x3D;时会进行字符串拼接，结果还是一个字符串）</p>
<p><img src="/../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223113100144.png" alt="image-20240223113100144"></p>
<p><img src="/../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223113232992.png" alt="image-20240223113232992"></p>
<p><img src="/../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223113303115.png" alt="image-20240223113303115"></p>
<h3 id="四、变量"><a href="#四、变量" class="headerlink" title="四、变量"></a>四、变量</h3><p><strong>①变量是内存当中的一块空间。是计算机中存储数据最基本的单元。</strong></p>
<p><strong>②变量三要素：</strong></p>
<ul>
<li>l数据类型（决定空间大小）【int, double, String】</li>
<li>l变量名（只要是合法的标识符即可）</li>
<li>l变量值（变量中具体存储的数据）</li>
</ul>
<p><strong>③变量的声明、赋值、访问</strong></p>
<ul>
<li>lint i; &#x2F;&#x2F; 声明一个整数型的变量，起名i</li>
<li>li &#x3D; 100; &#x2F;&#x2F; 给变量i赋值100</li>
<li>lSystem.out.println(i); &#x2F;&#x2F; 访问i变量：读操作</li>
<li>li &#x3D; 200; &#x2F;&#x2F; 访问i变量：改操作【给变量i重新赋值200】</li>
</ul>
<p>生命周期就是从内存开辟到内存释放</p>
<h4 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h4><p><strong>①局部变量</strong></p>
<p>在方法体里面定义的变量</p>
<p><strong>②成员变量</strong></p>
<p>在类里面，不是在方法体里面定义的；</p>
<p>&#x3D;&#x3D;对于成员变量来说，如果没有手动赋值，系统会自动赋默认值。&#x3D;&#x3D;0.false，null</p>
<ol>
<li><p>静态变量</p>
<p>​	&#x2F;&#x2F;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> a；</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例变量</p>
</li>
</ol>
<h3 id="五、数据类型"><a href="#五、数据类型" class="headerlink" title="五、数据类型"></a>五、数据类型</h3><p><img src="/../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223124717592.png" alt="image-20240223124717592"></p>
<p><img src="/../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223124824008.png" alt="image-20240223124824008"></p>
<p>关于默认值：Java语言中变量必须先声明，再赋值，才能使用。对于局部变量来说必须手动赋值，而对于成员变量来说，如果没有手动赋值，系统会自动赋默认值。</p>
<h4 id="1-整数型详解"><a href="#1-整数型详解" class="headerlink" title="1.整数型详解"></a>1.整数型详解</h4><ol>
<li>整数型字面量一般默认是int，所以在定义long的时候，需要在字面量的后面加上“L&#x2F;l”</li>
</ol>
<p><img src="/../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223125508845.png" alt="image-20240223125508845"></p>
<h4 id="2-自动类型转换"><a href="#2-自动类型转换" class="headerlink" title="2.自动类型转换"></a>2.自动类型转换</h4><p>小容量的可以转大的，在Java中，对于基本数据类型来说，<strong>小容量是可以直接赋值给大容量的，这被称为自动类型转换。</strong></p>
<p><strong>&#x3D;&#x3D;<em>byte &lt; short &lt; int &lt; long &lt; float &lt; double</em>&#x3D;&#x3D;</strong></p>
<p><img src="/../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223134152096.png" alt="image-20240223134152096"></p>
<h4 id="3-强制类型转换"><a href="#3-强制类型转换" class="headerlink" title="3.强制类型转换"></a>3.强制类型转换</h4><blockquote>
<p>需要大容量转小容量</p>
</blockquote>
<p><strong>①Java中大容量是无法直接转换成小容量的。</strong>因为这种操作可能会导致精度损失，所以这种行为交给了程序员来决定，当然这种后果自然是程序员自己去承担。因此在代码中需要程序员自己亲手加上强制类型转换符，程序才能编译通过</p>
<p><strong>②强制类型转换时，底层二进制是如何变化的？原则：砍掉左侧多余的二进制。</strong></p>
<p><strong>③强制类型转换时，精度可能会损失，也可能不会损失，这要看具体的数据是否真正的超出了强转后的类型的取值范围</strong>。如下图：水可能溢出，也可能不会溢出，这要看真实存放的水有多少</p>
<p>④请推算结果：byte b &#x3D; (byte)150;</p>
<p><img src="/../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223134219863.png" alt="image-20240223134219863"></p>
<h4 id="4-byte"><a href="#4-byte" class="headerlink" title="4.byte"></a>4.byte</h4><p><strong>当整数字面量没有超出byte的范围</strong></p>
<p><strong>①在Java中有这样一个规定，</strong>&#x3D;&#x3D;当整数型字面量没有超出byte的范围：可以直接赋值给byte类型的变量。&#x3D;&#x3D;</p>
<p><strong>byte b &#x3D; 127</strong>; &#x2F;&#x2F; 这是允许的</p>
<p>很显然，这是一种编译优化。同时也是为了方便程序员写代码。</p>
<p><strong>②如果超出了范围</strong>，例如：</p>
<p>byte b &#x3D; 128; &#x2F;&#x2F; 编译报错</p>
<p>这样就会报错，需要做强制类型转换，例如：</p>
<p>byte b &#x3D; (byte)128;</p>
<p>它的执行结果你知道吗？可以尝试推算一下</p>
<p><strong>③在整数类型中，除了byte有这个待遇之外，short同样也是支持的。</strong>也就是说：如果整数型字面量没有超出short取值范围时，也是支持直接赋值的。</p>
<h4 id="5-数据类型运算"><a href="#5-数据类型运算" class="headerlink" title="5.数据类型运算"></a>5.数据类型运算</h4><p><strong>两个int类型做运算：</strong>两个int类型的数据做运算，最终的结果还是int类型</p>
<p><strong>多种数据类型混合运算：</strong></p>
<h5 id="a-在Java中，多种数据类型混合运算时，各自先转换成容量最大的类型，再做运算"><a href="#a-在Java中，多种数据类型混合运算时，各自先转换成容量最大的类型，再做运算" class="headerlink" title="a.在Java中，多种数据类型混合运算时，各自先转换成容量最大的类型，再做运算"></a>a.在Java中，多种数据类型混合运算时，各自先转换成容量最大的类型，再做运算</h5><p>byte a &#x3D; 100;</p>
<p>int b &#x3D; 200;</p>
<p>long c &#x3D; 300L;</p>
<p>long d &#x3D; a + b + c;</p>
<p>你可以测试一下，如果d变量是int类型则编译器会报错</p>
<h5 id="b-byte和short混合运算（byte-byte、short-short）的时候，各自先转换成int再做运算，最后的结果是int，不能用short"><a href="#b-byte和short混合运算（byte-byte、short-short）的时候，各自先转换成int再做运算，最后的结果是int，不能用short" class="headerlink" title="b.byte和short混合运算（byte+byte、short+short）的时候，各自先转换成int再做运算，最后的结果是int，不能用short"></a>b.byte和short混合运算（byte+byte、short+short）的时候，各自先转换成int再做运算，最后的结果是int，不能用short</h5><h5 id="c-byte-a-10-3-这个是在编译的时候就得到结果了"><a href="#c-byte-a-10-3-这个是在编译的时候就得到结果了" class="headerlink" title="c.byte a  &#x3D; 10&#x2F;3 ,这个是在编译的时候就得到结果了"></a>c.byte a  &#x3D; 10&#x2F;3 ,这个是在编译的时候就得到结果了</h5><p>编译后的class文件中直接就是byte a &#x3D; 3</p>
<h5 id="d-byte-a-10-byte-b-3-byte-c-a-b-这个是运行的时候才得到结果的。"><a href="#d-byte-a-10-byte-b-3-byte-c-a-b-这个是运行的时候才得到结果的。" class="headerlink" title="d.byte a &#x3D; 10; byte b &#x3D; 3; byte c &#x3D; a&#x2F;b 这个是运行的时候才得到结果的。"></a>d.byte a &#x3D; 10; byte b &#x3D; 3; byte c &#x3D; a&#x2F;b 这个是运行的时候才得到结果的。</h5><p>编译的阶段只能知道a&#x2F;b的结果是int类型，不知道最后的结果是多少。</p>
<h3 id="6-浮点型"><a href="#6-浮点型" class="headerlink" title="6.浮点型"></a>6.浮点型</h3><p><strong>浮点型字面量默认被当做double</strong></p>
<h4 id="①Java中，浮点型字面量默认被当做double类型，如果要当做float类型，需要在数字后面添加-F-或-f。"><a href="#①Java中，浮点型字面量默认被当做double类型，如果要当做float类型，需要在数字后面添加-F-或-f。" class="headerlink" title="①Java中，浮点型字面量默认被当做double类型，如果要当做float类型，需要在数字后面添加 F 或 f。"></a><strong>①Java中，浮点型字面量默认被当做double类型</strong>，如果要当做float类型，需要在数字后面添加 F 或 f。</h4><p><img src="/../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223142425166.png" alt="image-20240223142425166"></p>
<p>&#x3D;&#x3D;float f &#x3D; 3.0; &#x2F;&#x2F; 编译报错&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;报错原因是：3.0默认被当做double类型，大容量无法直接赋值给小容量。如何修改：&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;float f &#x3D; 3.0F;&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;float f &#x3D; （double）3.14;&#x3D;&#x3D;这个是强制类型转换</p>
<h4 id="②另外，可以通过以下程序的输出结果看到，double精度高于float："><a href="#②另外，可以通过以下程序的输出结果看到，double精度高于float：" class="headerlink" title="②另外，可以通过以下程序的输出结果看到，double精度高于float："></a><strong>②另外，可以通过以下程序的输出结果看到，double精度高于float：</strong></h4><p>double d &#x3D; 1.5656856894;</p>
<p>System.out.println(d);</p>
<p>float f &#x3D; 1.5656856894F;</p>
<p>System.out.println(f);</p>
<h4 id="③浮点型数据两种表示形式"><a href="#③浮点型数据两种表示形式" class="headerlink" title="③浮点型数据两种表示形式"></a>③浮点型数据两种表示形式</h4><p> <strong>第一种形式：十进制</strong></p>
<p>double x &#x3D; 1.23;</p>
<p>double y &#x3D; 0.23;</p>
<p>double z &#x3D; .23;</p>
<p> <strong>第二种形式：科学计数法</strong></p>
<p>double x &#x3D; 0.123E2; &#x2F;&#x2F; 0.123 * 10的平方</p>
<p>double y &#x3D; 123.34E-2; &#x2F;&#x2F; 123.34 &#x2F; 10的平方</p>
<h4 id="⑤浮点型数据存储原理"><a href="#⑤浮点型数据存储原理" class="headerlink" title="⑤浮点型数据存储原理"></a>⑤<strong>浮点型数据存储原理</strong></h4><blockquote>
<p>①符号位：0表示整数。1表示负数。</p>
<p>②指数位：比如小数0.123E30，其中30就是指数。表示0.123 * 10的30次幂。所以也有把指数位叫做偏移量的。最大偏移量127。</p>
<p>③尾数位：浮点数的小数部分的有效数字。例如：0.00123，那么尾数位存储123对应的二进制。</p>
<p>④从浮点型数据存储原理上可以看到，二进制中的指数位决定了数字呈指数级增大。因此float虽然是4个字节，但却可以表示比long更大的数值。因此float容量比long的容量大。</p>
</blockquote>
<p><img src="/../blog_images/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/image-20240223142930629.png" alt="image-20240223142930629"></p>
<p>①一旦有浮点型数据参与运算得出的结果，一定不要使用“&#x3D;&#x3D;”与其它数字进行“相等比较”</p>
<blockquote>
<p>浮点型数据在计算机底层计算的是近似值，</p>
</blockquote>
<h3 id="7-字符型"><a href="#7-字符型" class="headerlink" title="7.字符型"></a>7.字符型</h3><p>①占用两个字节，0~65535，和short容量相同，但char可以取更大的整数</p>
<p>②单个字符，使用单引号括起来，不能是多个字符</p>
<p>③可以保存一个汉字                       </p>
<p>④char c &#x3D; ‘’; 这是不允许的</p>
<p>⑤char c &#x3D; ‘\u0000’; 这表示一个空字符，也是char的默认值。\u0000是一个Unicode码。</p>
<p>⑥空字符与空格字符是不同的。空字符表示什么也没有。空格字符表示一个空格。****</p>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><p>乱码产生的原因在于，在编码和解码的时候没有用同一个码表</p>
]]></content>
  </entry>
  <entry>
    <title>Java基础部分2</title>
    <url>/2024/02/23/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/</url>
    <content><![CDATA[<h1 id="Java-基础知识"><a href="#Java-基础知识" class="headerlink" title="Java 基础知识"></a>Java 基础知识</h1><h2 id="一、-package-和-import"><a href="#一、-package-和-import" class="headerlink" title="一、 package 和 import"></a>一、 package 和 import</h2><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>其实包就是把很多很多的代码进行整理，便于代码的统一管理。</p>
<p>①怎么定义包：在java源码第一行编写 package 语句。注意：package语句只能出现在java代码第一行。</p>
<p>②包名命名规范中要求是全部小写。</p>
<p>③包名命名规范：公司域名倒序 + 项目名 + 模块名 + 功能名。例如：</p>
<p>①com.powernode.oa.empgt.service</p>
<p>④如果带包编译：</p>
<p>①javac -d 编译后的存放目录 java源文件路径</p>
<p>⑥有了包机制后，完整类名是包含包名的，例如类名是：com.powernode.javase.chapter02.PackageTest</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a><strong>import</strong></h3><p>①import语句用来引入其他类。</p>
<p>②A类中使用B类，A类和B类不在同一个包下时，就需要在A类中使用import引入B类。</p>
<p>③java.lang包下的不需要手动引入。</p>
<p>④import语句只能出现在package语句之下，class定义之前。</p>
<p>⑤import语句可以编写多个。</p>
<p>⑥import语句可以模糊导入：java.util.*;</p>
<p>⑦import静态导入：import static java.lang.System.*;</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223194626584.png" alt="image-20240223194626584"><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223194657595.png" alt="image-20240223194657595"></p>
<h2 id="二、面向对象概述"><a href="#二、面向对象概述" class="headerlink" title="二、面向对象概述"></a>二、面向对象概述</h2><h3 id="1-面向对象三大特征"><a href="#1-面向对象三大特征" class="headerlink" title="1. 面向对象三大特征"></a>1. 面向对象三大特征</h3><p>面向对象三大特征</p>
<p>①封装（Encapsulation）</p>
<p>②继承（Inheritance）</p>
<p>③多态（Polymorphism）</p>
<h3 id="2-对象的创建与使用"><a href="#2-对象的创建与使用" class="headerlink" title="2.对象的创建与使用"></a>2.对象的创建与使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="comment">// 姓名</span></span><br><span class="line">String name; <span class="comment">// 实例变量</span></span><br><span class="line"><span class="comment">// 年龄</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="comment">// 性别</span></span><br><span class="line"><span class="type">boolean</span> gender;</span><br><span class="line"><span class="comment">// 学习</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123; System.out.println(“正在学习”); &#125; <span class="comment">// 实例方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="①对象的创建"><a href="#①对象的创建" class="headerlink" title="①对象的创建"></a>①对象的创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>

<p>在Java中，使用class定义的类，属于引用数据类型。所以Student属于引用数据类型。类型名为：Student。</p>
<p>Student s; 表示定义一个变量。数据类型是Student。变量名是s。</p>
<h4 id="②对象的使用"><a href="#②对象的使用" class="headerlink" title="②对象的使用"></a>②对象的使用</h4><p>读取属性值：s.name</p>
<p>修改属性值：s.name &#x3D; “jackson”;</p>
<h4 id="③通过一个类可以实例化多个对象"><a href="#③通过一个类可以实例化多个对象" class="headerlink" title="③通过一个类可以实例化多个对象"></a>③通过一个类可以实例化多个对象</h4><p>Student s1 &#x3D; new Student();</p>
<p>Student s2 &#x3D; new Student();</p>
<h4 id="④-public-static-void-functionA（），直接用类名-functionA-来访问"><a href="#④-public-static-void-functionA（），直接用类名-functionA-来访问" class="headerlink" title="④ public static   void functionA（），直接用类名.functionA()来访问"></a>④ public static   void functionA（），直接用类名.functionA()来访问</h4><blockquote>
<p>这个叫做静态方法</p>
<p>如果描述对象的动作，就不加static ，这种方法叫做实例方法</p>
</blockquote>
<h3 id="3-JVM内存结构图"><a href="#3-JVM内存结构图" class="headerlink" title="3.JVM内存结构图"></a>3.JVM内存结构图</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223195906110.png" alt="image-20240223195906110"></p>
<ol>
<li><strong>元空间（mataspace）存储的是类的元信息，字节码等。</strong>元空间是在java8后面引入的。</li>
</ol>
<p>JVM java虚拟机中定义的规范叫做方法区。</p>
<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223202022775.png" alt="image-20240223202022775" style="zoom:200%;" />

<h4 id="一旦引用为NULL，表示引用不再指向对象了"><a href="#一旦引用为NULL，表示引用不再指向对象了" class="headerlink" title="&#x3D;&#x3D;一旦引用为NULL，表示引用不再指向对象了&#x3D;&#x3D;"></a>&#x3D;&#x3D;一旦引用为NULL，表示引用不再指向对象了&#x3D;&#x3D;</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240223202252613.png" alt="image-20240223202252613"></p>
<h3 id="4-封装"><a href="#4-封装" class="headerlink" title="4.封装"></a>4.封装</h3><h4 id="什么是封装？"><a href="#什么是封装？" class="headerlink" title="什么是封装？"></a><strong>什么是封装</strong>？</h4><p>封装是一种将数据和方法加以包装，使之成为一个独立的实体，并且把它与外部对象隔离开来的机制。具体来说，封装是将一个对象的所有“状态（属性）”以及“行为（方法）”统一封装到一个类中，从而隐藏了对象内部的具体实现细节，向外界提供了有限的访问接口，以实现对对象的保护和隔离。</p>
<h4 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h4><p>封装通过限制外部对对象内部的直接访问和修改，保证了数据的安全性，并提高了代码的可维护性和可复用性。</p>
<h4 id="在代码上如何实现封装"><a href="#在代码上如何实现封装" class="headerlink" title="在代码上如何实现封装"></a>在代码上如何实现封装</h4><h5 id="1-属性私有化，对外提供getter和setter方法。"><a href="#1-属性私有化，对外提供getter和setter方法。" class="headerlink" title="1. 属性私有化，对外提供getter和setter方法。"></a>1. 属性私有化，对外提供getter和setter方法。</h5><p>属性私有化：使用private来进行修饰。</p>
<p>属性私有化的作用是禁止外部程序随意访问。</p>
<h5 id="2-为了保证外部程序以然可以访问age属性，还是需要提供一个公开的外部访问的入口。"><a href="#2-为了保证外部程序以然可以访问age属性，还是需要提供一个公开的外部访问的入口。" class="headerlink" title="2. 为了保证外部程序以然可以访问age属性，还是需要提供一个公开的外部访问的入口。"></a>2. 为了保证外部程序以然可以访问age属性，还是需要提供一个公开的外部访问的入口。</h5><blockquote>
<p>访问一般分为两个方法，一个负责读，一个负责修改。</p>
</blockquote>
<p>读取方法的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>改方法的格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>实例方法调用实例方法</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225145941617.png" alt="image-20240225145941617"></p>
<p>还是一个this.pay()</p>
<h3 id="5-构造方法（构造器）constructor"><a href="#5-构造方法（构造器）constructor" class="headerlink" title="5.  构造方法（构造器）constructor"></a>5.  构造方法（构造器）constructor</h3><blockquote>
<p>其实就是C里面的构造函数</p>
</blockquote>
<h4 id="构造方法的作用"><a href="#构造方法的作用" class="headerlink" title="构造方法的作用"></a>构造方法的作用</h4><ol>
<li>实现对象的出啊关键，通过调用的构造方法啊可以完成对于对象的创建</li>
<li>实现对于对象的各种属性的赋值。</li>
</ol>
<h4 id="构造方法怎么定义？"><a href="#构造方法怎么定义？" class="headerlink" title="构造方法怎么定义？"></a>构造方法怎么定义？</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225150328362.png" alt="image-20240225150328362"></p>
<p>构造方法最后执行结束之后，会返回这个new出来的实例的内存地址，但是构造方法中不需要提供return语句</p>
<h5 id="构造方法名一定要和类名保持一致！"><a href="#构造方法名一定要和类名保持一致！" class="headerlink" title="构造方法名一定要和类名保持一致！"></a>构造方法名一定要和类名保持一致！</h5><p>构造方法不需要返回值，如果有返回值就变成了普通方法</p>
<h4 id="缺省构造器"><a href="#缺省构造器" class="headerlink" title="缺省构造器"></a>缺省构造器</h4><p>如果一个类中没有显示的去定义构造方法，就会提供一个默认的方法，叫做缺省构造器。</p>
<p>当在调用 new Classname的时候，其实就是在调用构造函数</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225151158129.png" alt="image-20240225151158129"></p>
<p>完成构建，属性赋默认值。 </p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225154836218.png" alt="image-20240225154836218"></p>
<p>如果一个类里面提供了构造函数，那么就不会再创建缺省的构造方法，所以最好还是写一个无参数的构造方法。</p>
<blockquote>
<p>构造方法Constructor(构造器)</p>
<p>①构造方法有什么作用？</p>
<p>1.构造方法的执行分为两个阶段：对象的创建和对象的初始化。这两个阶段不能颠倒，也不可分割。</p>
<p>2.在Java中，当我们使用关键字new时，就会在内存中创建一个新的对象，虽然对象已经被创建出来了，但还没有被初始化。而初始化则是在执行构造方法体时进行的。</p>
<p>②构造方法如何定义？</p>
<p>[修饰符列表] 构造方法名(形参){}</p>
<p>③构造方法如何调用？new 构造方法名(实参);</p>
<p>④关于无参数构造方法：如果一个类没有显示的定义任何构造方法，系统会默认提供一个无参数构造方法，也被称为缺省构造器。一旦显示的定义了构造方法，则缺省构造器将不存在。为了方便对象的创建，建议将缺省构造器显示的定义出来。</p>
<p>⑤构造方法支持重载机制。</p>
<p>⑥关于构造代码块。对象的创建和初始化过程梳理：</p>
<p>①new的时候在堆内存中开辟空间，给所有属性赋默认值</p>
<p>②执行构造代码块进行初始化</p>
<p>③执行构造方法体进行初始化</p>
<p>④构造方法执行结束，对象初始化完毕。</p>
</blockquote>
<p>注意，set是修改，构造方法是初始化</p>
<h3 id="6-this关键字"><a href="#6-this关键字" class="headerlink" title="6. this关键字"></a>6. this关键字</h3><p>this关键字</p>
<p>①this是一个关键字。</p>
<p>②this出现在实例方法中，代表当前对象。语法是：this.</p>
<p>③this本质上是一个&#x3D;&#x3D;引用&#x3D;&#x3D;，该引用保存当前对象的内存地址。</p>
<p>④通过“this.”可以访问实例变量，可以调用实例方法。</p>
<p>⑤this存储在：栈帧的局部变量表的第0个槽位上。</p>
<p>⑥this. 大部分情况下可以省略，用于区分局部变量和实例变量时不能省略。</p>
<p>⑦this不能出现在静态方法中。</p>
<blockquote>
<p>public static vois functionstatic(){}</p>
<p>这里面不可以用this，因为static方法中没有当前对象，所以不可以用this。</p>
<p>但是在静态方法中可以调用另外一个静态方法。</p>
</blockquote>
<p>⑧“this(实参)”语法：</p>
<p>①只能出现在构造方法的第一行。</p>
<p>②通过当前构造方法去调用本类中其他的构造方法。</p>
<p>③作用是：代码复用。</p>
<p>实例方法只可以引用.</p>
<h3 id="7-static关键字"><a href="#7-static关键字" class="headerlink" title="7.static关键字"></a>7.static关键字</h3><blockquote>
<p>final变量不能修改,static变量可以在这个类里头修改</p>
</blockquote>
<p>①static是一个关键字，翻译为：静态的。</p>
<p><strong>②static修饰的变量叫做静态变量。</strong>当所有对象的某个属性的值是相同的，建议将该属性定义为静态变量，来节省内存的开销。</p>
<p>③静态变量在类加载时初始化，存储在堆中。</p>
<p><strong>④static修饰的方法叫做静态方法。</strong></p>
<blockquote>
<p>所有static级别的，都是类级别的，直接用类名来访问</p>
</blockquote>
<p>⑤所有静态变量和静态方法，统一使用“类名.”调用。&#x3D;&#x3D;虽然可以使用“引用.”来调用，但实际运行时和对象无关，所以不建议这样写，因为这样写会给其他人造成疑惑。&#x3D;&#x3D;</p>
<p>⑥使用“引用.”访问静态相关的，即使引用为null，也不会出现空指针异常。</p>
<p>⑦静态方法中不能使用this关键字。因此无法直接访问实例变量和调用实例方法。</p>
<p>⑧静态代码块在类加载时执行，一个类中可以编写多个静态代码块，遵循自上而下的顺序依次执行。</p>
<p>⑨静态代码块代表了类加载时刻，如果你有代码需要在此时刻执行，可以将该代码放到静态代码块中。</p>
<h4 id="静态变量内存图"><a href="#静态变量内存图" class="headerlink" title="静态变量内存图"></a>静态变量内存图</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225194625857.png" alt="image-20240225194625857"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225194714666.png" alt="image-20240225194714666"></p>
<h4 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225195106209.png" alt="image-20240225195106209"></p>
<p>静态方法中无法直接访问实例相关的数据。</p>
<h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225195527691.png" alt="image-20240225195527691"></p>
<h5 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h5><ol>
<li><p>语法格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static&#123;</span><br><span class="line">这个括号叫做静态上下文，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态代码块在类加载的时候执行，并且只执行了一次</p>
</li>
<li><p>静态代码块可以编写多个，并且遵循自上而下的顺序执行。</p>
</li>
</ol>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225212935175.png" alt="image-20240225212935175"></p>
<p>按照以上的这个代码，main方法也是最后执行的</p>
<p>此外</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225213020734.png" alt="image-20240225213020734"></p>
<p>按照这个，会报错。连main方法都没有执行，name也没有执行，</p>
<p>：在静态上下文中无法直接访问实例相关的数据，但是可以访问在这个静态代码块前面定义的静态数据。</p>
<p>在这个静态代码块之后定义的就不能访问了。因为静态的数据是按照顺序进行的。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225213131315.png" alt="image-20240225213131315"></p>
<h3 id="8-JVMjava虚拟机的体系结构"><a href="#8-JVMjava虚拟机的体系结构" class="headerlink" title="8.JVMjava虚拟机的体系结构"></a>8.JVMjava虚拟机的体系结构</h3><p>&#x3D;&#x3D;JVM对应了一套规范（Java虚拟机规范），它可以有不同的实现&#x3D;&#x3D;</p>
<p>①JVM规范是一种抽象的概念，它可以有多种不同的实现。例如：</p>
<p>1.HotSpot：HotSpot 由 Oracle 公司开发，是目前最常用的虚拟机实现，也是默认的 Java 虚拟机，默认包含在 Oracle JDK 和 OpenJDK 中</p>
<p>2.JRockit：JRockit 也是由 Oracle 公司开发。它是一款针对生产环境优化的 JVM 实现，能够提供高性能和可伸缩性</p>
<p>3.IBM JDK：IBM JDK 是 IBM 公司开发的 Java 环境，采用了与 HotSpot 不同的 J9 VM，能够提供更小的内存占用和更迅速的启动时间</p>
<p>4.Azul Zing：Azul Zing 是针对生产环境优化的虚拟机实现，能够提供高性能和实时处理能力，适合于高负载的企业应用和实时分析等场景</p>
<p>5.OpenJ9：OpenJ9 是由 IBM 开发的优化的 Java 虚拟机实现，支持高度轻量级、低时延的 GC、优化的 JIT 编译器和用于健康度测试的可观察性仪表板</p>
<p>②右图是从oracle官网上截取的Java虚拟机规范中的一部分。（大家也可以找一下oracle官方文档）</p>
<p>③我们主要研究运行时数据区。运行时数据区包括6部分：</p>
<ol>
<li><p>The pc Register（程序计数器）：下一个你要执行的字节码指令</p>
</li>
<li><p>Java Virtual Machine Stacks（Java虚拟机栈）</p>
</li>
<li><p><strong>Heap（堆）</strong></p>
</li>
<li><p><strong>Method Area（方法区）</strong></p>
</li>
<li><p>Run-Time Constant Pool（运行时常量池）</p>
</li>
<li><p>Native Method Stacks（本地方法栈）</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JVM规范中的运行时数据区</span><br><span class="line">The pc Register（程序计数器）：是一块较小的内存空间，此计数器记录的是正在执行的虚拟机字节码指令的地址；</span><br><span class="line">Java Virtual Machine Stacks（Java虚拟机栈）：Java虚拟机栈用于存储栈帧。栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</span><br><span class="line">Heap（堆）：是Java虚拟机所管理的最大的一块内存。堆内存用于存放Java对象实例以及数组。堆是垃圾收集器收集垃圾的主要区域。</span><br><span class="line">Method Area（方法区）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</span><br><span class="line">这个是规范，但是在实现中有些会加到堆里</span><br><span class="line">Run-Time Constant Pool（运行时常量池）：是方法区的一部分，用于存放编译期生成的各种字面量与符号引用（类名、属性名等）。</span><br><span class="line">Native Method Stacks（本地方法栈）：在本地方法的执行过程中，会使用到本地方法栈。和 Java 虚拟机栈十分相似。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结：这些运行时数据区虽然在功能上有所区别，但在整个 Java 虚拟机启动时都需要被创建，并且在虚拟机运行期间始终存在，直到虚拟机停止运行时被销毁。同时，不同的 JVM 实现对运行时数据区的分配和管理方式也可能不同，会对性能和功能产生影响。</span><br></pre></td></tr></table></figure>

<p>**<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225214223891.png" alt="image-20240225214223891"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225214331825.png" alt="image-20240225214331825"></p>
<h3 id="9、设计模式概述"><a href="#9、设计模式概述" class="headerlink" title="9、设计模式概述"></a>9、设计模式概述</h3><p>单例模式（&#x3D;&#x3D;GoF&#x3D;&#x3D;23种设计模式之一，最简单的设计模式：&#x3D;&#x3D;如何保证某种类型的对象只创建一个）&#x3D;&#x3D;</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225220833968.png" alt="image-20240225220833968"></p>
<p>&#x2F;&#x2F;饿汉式单例模式：不管这个对象用还是不用，提前把对象给创建好了。</p>
<p><strong>step1：构造函数私有化&#x2F;&#x2F;不让new，但是又可以获得方法</strong></p>
<p><strong>step2：对外提供一个公开的静态方法，用这个方法获取单个实例</strong></p>
<p><strong>step3: 定义一个静态变量，在类加载的时候，初始化静态变量（只初始化一次）。</strong></p>
<p>&#x2F;&#x2F;懒汉式单例模式：等到用的时候再创建，不用不创建。</p>
<p>step1：构造方法私有化</p>
<p>step2：对外提供一个静态方法，可以通过这个方法获取到对象；</p>
<p><strong>这个是初步的，等到以后多线程的时候，还需要 改进</strong></p>
<h3 id="10-继承"><a href="#10-继承" class="headerlink" title="10.继承"></a>10.继承</h3><p>① 面向对象三大特征之一：继承</p>
<p>② 继承作用？</p>
<p><strong>l基本作用：代码复用</strong></p>
<p><strong>l重要作用：有了继承，才有了方法覆盖和多态机制。</strong></p>
<p>③继承在java中如何实现？</p>
<p><strong>l[修饰符列表] class 类名 extends 父类名{}</strong></p>
<p><strong>lextends翻译为扩展。表示子类继承父类后，子类是对父类的扩展。</strong></p>
<p>④继承相关的术语：当B类继承A类时</p>
<p><strong>lA类称为：父类、超类、基类、superclass</strong></p>
<p><strong>lB类称为：子类、派生类、subclass</strong></p>
<p>⑤Java只支持单继承，一个类只能直接继承一个类。</p>
<p>⑥Java不支持多继承，但支持多重继承（多层继承）。</p>
<p>⑦子类继承父类后，除私有的不支持继承、构造方法不支持继承。其它的全部会继承。</p>
<p>&#x3D;&#x3D;⑧一个类没有显示继承任何类时，默认继承java.lang.Object类。&#x3D;&#x3D;比如tostring就是object的，任何一个类都可以调用</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225221336300.png" alt="image-20240225221336300"></p>
<h3 id="11-方法覆盖"><a href="#11-方法覆盖" class="headerlink" title="11.方法覆盖"></a>11.方法覆盖</h3><p>方法覆盖&#x2F;override&#x2F;方法重写&#x2F;overwrite，是在编译器层面的功能，方法重载机制是给编译器看的</p>
<h4 id="①什么情况下考虑使用方法覆盖？"><a href="#①什么情况下考虑使用方法覆盖？" class="headerlink" title="①什么情况下考虑使用方法覆盖？"></a>①什么情况下考虑使用方法覆盖？</h4><p>1.当从父类中继承过来的方法无法满足当前子类的业务需求时。</p>
<h4 id="②发生方法覆盖的条件？"><a href="#②发生方法覆盖的条件？" class="headerlink" title="②发生方法覆盖的条件？"></a>②发生方法覆盖的条件？</h4><ol>
<li><p>具有&#x3D;&#x3D;继承关系的父子类之间&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;相同的返回值类型，相同的方法名，相同的形式参数列表&#x3D;&#x3D;</p>
</li>
<li><p>访问权限不能变低，可以变高。</p>
</li>
</ol>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225225653075.png" alt="image-20240225225653075"></p>
<p>高———————&gt;低</p>
<ol start="4">
<li>抛出异常不能变多，可以变少。</li>
</ol>
<p>父类抛了,子类不抛,比如</p>
<ol start="5">
<li>返回值类型可以是父类方法返回值类型的子类。</li>
</ol>
<h4 id="③方法覆盖的小细节："><a href="#③方法覆盖的小细节：" class="headerlink" title="③方法覆盖的小细节："></a>③方法覆盖的小细节：</h4><ol>
<li><p>@Override注解标注的方法会在编译阶段检查该方法是否重写了父类的方法。</p>
</li>
<li><p>&#x3D;&#x3D;私有方法不能继承，所以不能覆盖。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;构造方法不能继承，所以不能覆盖。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;静态方法不存在方法覆盖，方法覆盖针对的是实例方法。&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;方法覆盖说的实例方法，和实例变量无关。（&#x3D;&#x3D;可以写程序测试一下）</p>
</li>
</ol>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225224843910.png" alt="image-20240225224843910"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225224915679.png" alt="image-20240225224915679"></p>
<p><strong>在java中也有个注解，在编译的时候可以检查这个方法是否是重写了父类的方法</strong>@Override</p>
<blockquote>
<p>@Override 只在编译阶段会有用,和运行期无关.</p>
<p>如果返回值类型是引用类型,那么这个返回值类型可以是原类型的子类型</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225225250788.png" alt="image-20240225225250788"></p>
<h3 id="12-多态"><a href="#12-多态" class="headerlink" title="12.多态"></a>12.多态</h3><p>多态的基础语法</p>
<h4 id="①什么是向上转型和向下转型？"><a href="#①什么是向上转型和向下转型？" class="headerlink" title="①什么是向上转型和向下转型？"></a>①什么是向上转型和向下转型？</h4><ol>
<li><p>java允许具有继承关系的父子类型之间的类型转换。</p>
</li>
<li><p>&#x3D;&#x3D;向上转型（upcasting）：子–&gt;父&#x3D;&#x3D;</p>
</li>
</ol>
<p>&#x3D;&#x3D;l子类型的对象可以赋值给一个父类型的引用。&#x3D;&#x3D;</p>
<ol start="3">
<li>&#x3D;&#x3D;向下转型（downcasting）：父–&gt;子&#x3D;&#x3D;</li>
</ol>
<blockquote>
<p>一般来说,想要调用的方法是子类当中特有的方法的时候,才会想要向下转型.</p>
</blockquote>
<p>&#x3D;&#x3D;l父类型的引用可以转换为子&#x3D;&#x3D;类型的引用。但是需要加强制类型转换符。</p>
<ol start="4">
<li>无论是向上转型还是向下转型，前提条件是：&#x3D;&#x3D;两种类型之间必须存在继承关系。这样编译器才能编译通过。&#x3D;&#x3D;</li>
</ol>
<h4 id="②什么是多态？"><a href="#②什么是多态？" class="headerlink" title="②什么是多态？"></a>②什么是多态？</h4><blockquote>
<p>编译过程中是一个形态,运行的时候又是另外一个形态.</p>
</blockquote>
<ol>
<li><p>父类型引用指向子类对象。Animal a &#x3D; new Cat(); a.move();</p>
</li>
<li><p>程序分为编译阶段和运行阶段：</p>
</li>
</ol>
<blockquote>
<p>l编译阶段：编译器只知道a是Animal类型，因此去Animal类中找move()方法，找到之后，绑定成功，编译通过。这个过程通常被称为静态绑定。</p>
</blockquote>
<blockquote>
<p>l运行阶段：运行时和JVM堆内存中的真实Java对象有关，所以运行时会自动调用真实对象的move()方法。这个过程通常被称为动态绑定。</p>
</blockquote>
<ol start="3">
<li>多态指的是：多种形态，编译阶段一种形态，运行阶段另一种形态，因此叫做多态。</li>
</ol>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225231010553.png" alt="image-20240225231010553"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240225231835927.png" alt="image-20240225231835927"></p>
<h4 id="③-instanceof运算符可以解决类型转换问题"><a href="#③-instanceof运算符可以解决类型转换问题" class="headerlink" title="③ instanceof运算符可以解决类型转换问题"></a>③ instanceof运算符可以解决类型转换问题</h4><ol>
<li>instanceof运算符的结果一定是:true&#x2F;false</li>
<li>语法结构</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(a instanceof cat)</span><br><span class="line">	true表示:a引用指向的对象是cat类型</span><br><span class="line">	false表示:a引用的指向的对象不是cat</span><br></pre></td></tr></table></figure>

<p>这个运算符主要就是用来进行判断.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Bird)&#123;</span><br><span class="line">	<span class="type">Bird</span> <span class="variable">y</span> <span class="operator">=</span>(Bird)x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="④-软件开发七大原则"><a href="#④-软件开发七大原则" class="headerlink" title="④ 软件开发七大原则"></a>④ 软件开发七大原则</h4><blockquote>
<p>软件开发原则旨在引导软件行业的从业者在代码设计和开发过程中，遵循一些基本原则，以达到高质量、易维护、易扩展、安全性强等目标。软件开发原则与具体的编程语言无关的，属于软件设计方面的知识。</p>
</blockquote>
<ol>
<li><p>&#x3D;&#x3D;开闭原则 (Open-Closed Principle，OCP)：一个软件实体应该对扩展开放，对修改关闭。即在不修改原有代码的基础上，通过添加新的代码来扩展功能。（最基本的原则，其它原则都是为这个原则服务的。）&#x3D;&#x3D;</p>
</li>
<li><p>单一职责原则：一个类只负责单一的职责，也就是一个类只有一个引起它变化的原因。</p>
</li>
<li><p>里氏替换原则：子类对象可以替换其基类对象出现的任何地方，并且保证原有程序的正确性。</p>
</li>
<li><p>接口隔离原则：客户端不应该依赖它不需要的接口。</p>
</li>
<li><p>依赖倒置原则：高层模块不应该依赖底层模块，它们都应该依赖于抽象接口。换言之，面向接口编程。</p>
</li>
<li><p>迪米特法则：一个对象应该对其它对象保持最少的了解。即一个类应该对自己需要耦合或调用的类知道得最少。</p>
</li>
<li><p>合成复用原则：尽量使用对象组合和聚合，而不是继承来达到复用的目的。组合和聚合可以在获取外部对象的方法中被调用，是一种运行时关联，而继承则是一种编译时关联。</p>
</li>
</ol>
<h4 id="⑤-多态在开发中的作用"><a href="#⑤-多态在开发中的作用" class="headerlink" title="⑤ 多态在开发中的作用"></a>⑤ 多态在开发中的作用</h4><ol>
<li><p>降低程序的耦合度，提高程序的扩展力。</p>
</li>
<li><p>尽量使用多态，面向抽象编程，不要面向具体编程。</p>
</li>
</ol>
<h4 id="⑥多态的基础语法"><a href="#⑥多态的基础语法" class="headerlink" title="⑥多态的基础语法"></a>⑥多态的基础语法</h4><p> <strong>向下转型我们需要注意什么？</strong></p>
<ol>
<li><p>向下转型时，使用不当，容易发生类型转换异常：ClassCastException。</p>
</li>
<li><p>在向下转型时，一般建议使用instanceof运算符进行判断来避免ClassCastException的发生。</p>
</li>
</ol>
<p><strong>instanceof运算符的使用</strong></p>
<ol>
<li><p>语法格式：(引用 instanceof 类型)</p>
</li>
<li><p>执行结果是true或者false</p>
</li>
<li><p>例如：(a instanceof Cat)</p>
</li>
</ol>
<p>l如果结果是true：表示a引用指向的对象是Cat类型的。</p>
<p>l如果结果是false：表示a引用指向的对象不是Cat类型的。</p>
<h3 id="13-抽象类"><a href="#13-抽象类" class="headerlink" title="13 . 抽象类"></a>13 . 抽象类</h3><blockquote>
<p>注意！抽象类不一定有抽象方法，但是有抽象方法的类一定是抽象类。</p>
<p>此外,public和abstract没有顺序关系</p>
</blockquote>
<h4 id="①什么时候考虑将类定义为抽象类？"><a href="#①什么时候考虑将类定义为抽象类？" class="headerlink" title="①什么时候考虑将类定义为抽象类？"></a>①什么时候考虑将类定义为抽象类？</h4><p>如果类中有些方法无法实现或者没有意义，可以将方法定义为抽象方法。类定义为抽象类。这样在抽象类中只提供<strong>公共代码</strong>，具体的实现<strong>强行</strong>交给子类去做。比如一个Person类有一个问候的方法greet()，但是不同国家的人问候的方式不同，因此greet()方法具体实现应该交给子类。再比如主人喂养宠物的例子中的宠物Pet，Pet中的eat()方法的方法体就是没有意义的。</p>
<h4 id="②抽象类如何定义？"><a href="#②抽象类如何定义？" class="headerlink" title="②抽象类如何定义？"></a>②抽象类如何定义？</h4><p>abstract class 类名{}</p>
<h4 id="③抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。"><a href="#③抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。" class="headerlink" title="③抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。"></a>③抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的。</h4><h4 id="④抽象方法如何定义？"><a href="#④抽象方法如何定义？" class="headerlink" title="④抽象方法如何定义？"></a>④抽象方法如何定义？</h4><p>abstract 方法返回值类型 方法名(形参);</p>
<blockquote>
<p>没有方法体 </p>
</blockquote>
<h4 id="⑤抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。"><a href="#⑤抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。" class="headerlink" title="⑤抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。"></a>⑤抽象类中不一定有抽象方法，但如果有抽象方法那么类要求必须是抽象类。</h4><h4 id="⑥一个非抽象的类继承extend抽象类，要求必须将抽象方法进行实现-重写。"><a href="#⑥一个非抽象的类继承extend抽象类，要求必须将抽象方法进行实现-重写。" class="headerlink" title="&#x3D;&#x3D;⑥一个非抽象的类继承extend抽象类，要求必须将抽象方法进行实现&#x2F;重写。&#x3D;&#x3D;"></a>&#x3D;&#x3D;⑥一个非抽象的类继承extend抽象类，要求必须将抽象方法进行实现&#x2F;重写。&#x3D;&#x3D;</h4><blockquote>
<p>需要把全部的抽象方法全部给实现了</p>
</blockquote>
<h4 id="⑦abstract关键字不能和private，final，static关键字共存。"><a href="#⑦abstract关键字不能和private，final，static关键字共存。" class="headerlink" title="⑦abstract关键字不能和private，final，static关键字共存。"></a>⑦abstract关键字不能和private，final，static关键字共存。</h4><blockquote>
<p>private: private是不能被继承覆盖的,而abstract修饰的是一定要被继承实现的,存在冲突.</p>
<p>final: 不能继承</p>
<p>static:不能被覆盖</p>
</blockquote>
<h4 id="⑧抽象类需要构造方法-但是无法实现实例化-这个构造方法是给其子类使用的"><a href="#⑧抽象类需要构造方法-但是无法实现实例化-这个构造方法是给其子类使用的" class="headerlink" title="⑧抽象类需要构造方法,但是无法实现实例化,这个构造方法是给其子类使用的."></a>⑧抽象类需要构造方法,但是无法实现实例化,这个构造方法是给其子类使用的.</h4><h3 id="14-super关键字"><a href="#14-super关键字" class="headerlink" title="14. super关键字"></a>14. super关键字</h3><p>①super关键字和this关键字对比来学习。this代表的是当前对象。<strong>super代表的是当前对象中的父类型特征。</strong></p>
<p><strong>②super不能使用在静态上下文中。</strong>就是在编写</p>
<p>③“super.”大部分情况下是可以省略的。什么时候不能省略？</p>
<p>&#x3D;&#x3D;<strong>当父类和子类中定义了相同的属性（实例变量）或者相同方法（实例方法）时，如果需要在子类中访问父类的属性或方法时，super.不能省略。</strong>&#x3D;&#x3D;</p>
<p><strong>④this可以单独输出，super不能单独输出。</strong></p>
<blockquote>
<p>this本身是一个引用,所以可以直接输出,super不是引用,不能直接输出</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system.out.println(this);//√</span><br><span class="line">System.out.println(super);//×</span><br></pre></td></tr></table></figure>

<p>⑤super(实参); 通过子类的构造方法调用父类的构造方法，目的是为了完成父类型特征的初始化。</p>
<p>⑥当一个构造方法第一行没有显示的调用“super(实参);”，也没有显示的调用“this(实参)”，系统会自动调用super()。因此一个类中的无参数构造方法建议显示的定义出来。</p>
<p>⑦super(实参); 这个语法只能出现在构造方法第一行。</p>
<blockquote>
<p>this()和super()</p>
</blockquote>
<p>⑧在Java语言中只要new对象，Object的无参数构造方法一定会执行。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226111210195.png" alt="image-20240226111210195"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226112229142.png" alt="image-20240226112229142"></p>
<p>子类的构造方法中,就算没有写super();,也是会跑这个代码.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>();</span><br><span class="line">会跑父类的构造方法.也会给父类的字段赋值.</span><br><span class="line">当一个构造方法,没有显示的写<span class="built_in">this</span>(),也没有显示的写<span class="built_in">super</span>(),系统会自动的调用<span class="built_in">super</span>()     </span><br><span class="line">当然也可以是:<span class="built_in">super</span>(actno , balance); </span><br><span class="line">    调用父类的方法: <span class="built_in">super</span>.doSome();</span><br><span class="line">				</span><br></pre></td></tr></table></figure>

<h3 id="15-final关键字"><a href="#15-final关键字" class="headerlink" title="15.final关键字"></a>15.final关键字</h3><blockquote>
<p>这个关键字表示是最终的,被final所修饰的类不能被 继承</p>
</blockquote>
<p>①final修饰的类不能被继承</p>
<p>②final修饰的方法不能被覆盖</p>
<p>③final修饰的变量，一旦赋值不能重新赋值</p>
<p>④final修饰的实例变量必须&#x3D;&#x3D;在对象初始化时&#x3D;&#x3D;手动赋值</p>
<blockquote>
<p>必须在构造方法执行完之前,手动附上值.不允许采用系统的默认值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final class Mystring&#123;</span><br><span class="line">	public final void m()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//比如String就是不能被继承</span><br><span class="line"></span><br><span class="line">final String name;//×</span><br><span class="line">或者 </span><br><span class="line">final String name;</span><br><span class="line">public User(String name , int age)&#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑤final修饰的实例变量一般和static联合使用：&#x3D;&#x3D;称为常量&#x3D;&#x3D;</p>
<blockquote>
<p>因为类中定义的final 修饰的变量不能修改,最直接的理解就是所有的实例变量的这个变量都是一个值,因此,假设new出来了100个,那么这100个类的这个字段也都是同一个,所以可以直接加上static,设置成一个静态的,更方便,也更省堆空间. </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">MATH_PAI</span> <span class="operator">=</span> <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<p>⑥final修饰的引用，一旦指向某个对象后，不能再指向其它对象。但指向的对象内部的数据是可以修改的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> 修饰对象,内存地址不能改,但是内存地址里面的东西还是可以修改的</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226150228776.png" alt="image-20240226150228776"></p>
<h3 id="16-接口"><a href="#16-接口" class="headerlink" title="16.接口"></a>16.接口</h3><h4 id="接口的基础语法"><a href="#接口的基础语法" class="headerlink" title="接口的基础语法"></a>接口的基础语法</h4><p><strong>&#x3D;&#x3D;①接口（interface）在Java中表示一种规范或契约，它定义了一组抽象方法和常量，用来描述一些实现这个接口的类应该具有哪些行为和属性&#x3D;&#x3D;<strong>。</strong>接口和类一样，也是一种引用数据类型</strong>。</p>
<p>②接口怎么定义？[修饰符列表] interface 接口名{}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Myinterface&#123;</span><br><span class="line">	里面的方法可不能有方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③抽象类是半抽象的(抽象类可以定义抽象方法也可以定义非抽象方法 ,有构造方法不能new对象)，</p>
<p>​	接口是完全抽象的。&#x3D;&#x3D;<strong>接口没有构造方法，也无法实例化。</strong>&#x3D;&#x3D;</p>
<p><strong>④接口中只能定义：常量+抽象方法。&#x3D;&#x3D;接口中的常量的static final可以省略&#x3D;&#x3D;。接口中的抽象方法的abstract可以省略。接口中所有的方法和变量都是public修饰的。</strong>(JDK8)</p>
<p><strong>⑤接口和接口之间可以多继承。</strong></p>
<p>⑥类和接口的关系我们叫做实现（**&#x3D;&#x3D;这里的实现也可以等同看做继承&#x3D;&#x3D;<strong>）。使用</strong>&#x3D;&#x3D;implements&#x3D;&#x3D;**关键字进行接口的实现。</p>
<p><strong>⑦一个非抽象的类实现接口必须将接口中所有的抽象方法全部实现。</strong></p>
<p><strong>⑧一个类可以实现多个接口。语法是：class 类 implements 接口A,接口B{}</strong></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226161310540.png" alt="image-20240226161310540"></p>
<p>⑨Java8之后，接口中允许出现默认方法和静态方法(JDK8新特性)</p>
<p>​        <strong>引入默认方式是为了解决接口演变问题：接口可以定义抽象方法，但是不能实现这些方法。所有实现接口的类都必须实现这些抽象方法。这会导致接口升级的问题：当我们向接口添加或删除一个抽象方法时，这会破坏该接口的所有实现，并且所有该接口的用户都必须修改其代码才能适应更改。这就是所谓的”接口演变”问题。</strong></p>
<blockquote>
<p>如果还是按照之前的,那么如果需要在接口中加入一个新的方法,按照接口的实现类需要把借口中的全部都给实现了这一个要求,这个接口的所有实现类都需要实现这个接口,这太麻烦了.</p>
<p>加入默认方法后,实现该接口的实现类中都有这个默认方法,但是不需要去实现</p>
</blockquote>
<p>​        <strong>引入的静态方法只能使用本接口名来访问，无法使用实现类的类名访问。</strong></p>
<blockquote>
<p>原因:接口也可以当工具使用,渐渐变成了工具类</p>
</blockquote>
<p>默认方法:</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226162231265.png" alt="image-20240226162231265"></p>
<p>静态方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticmethod</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">MyInterface.staticmethod();</span><br><span class="line"><span class="comment">//不可以</span></span><br><span class="line">MyInterfaceImpl.staticmethod();</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226162707551.png" alt="image-20240226162707551"><strong>⑩JDK9之后允许接口中定义私有private的实例方法（为默认方法服务的）和私有的静态方法（为静态方法服务的)。</strong></p>
<p>⑪所有的接口隐式的继承Object。因此接口也可以调用Object类的相关方法。</p>
<h4 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h4><p>①面向接口调用的称为：接口调用者</p>
<p>②面向接口实现的称为：接口实现者</p>
<p>③调用者和实现者通过接口达到了解耦合。也就是说调用者不需要关心具体的实现者，实现者也不需要关心具体的调用者，双方都遵循规范，面向接口进行开发。</p>
<p>④<strong>面向抽象编程，面向接口编程，可以降低程序的耦合度，提高程序的&#x3D;&#x3D;扩展力&#x3D;&#x3D;。</strong></p>
<p>⑤例如定义一个Usb接口，提供read()和write()方法，通过read()方法读，通过write()方法写：</p>
<p>①定义一个电脑类Computer，它是调用者，面向Usb接口来调用。</p>
<p>②Usb接口的实现可以有很多，例如：打印机（Printer），硬盘（HardDrive）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conn</span><span class="params">(Usb usb)</span>&#123;</span><br><span class="line"></span><br><span class="line">usb.read();</span><br><span class="line"></span><br><span class="line">usb.write();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑦再想想，我们平时去饭店吃饭，这个场景中有没有接口呢？食谱菜单就是接口。顾客是调用者。厨师是实现者。</p>
<h4 id="接口与抽象类如何选择"><a href="#接口与抽象类如何选择" class="headerlink" title="接口与抽象类如何选择"></a>接口与抽象类如何选择</h4><p>①抽象类和接口虽然在代码角度都能达到同样的效果，但适用场景不同：</p>
<p>​        抽象类主要适用于公共代码的提取。当多个类中有共同的属性和方法时，为了达到代码的复用，建议为这几个类提取出来一个父类，在该父类中编写公共的代码。如果有一些方法无法在该类中实现，可以延迟到子类中实现。这样的类就应该使用抽象类。</p>
<p>​       <strong>接口主要用于功能的扩展</strong>。例如有很多类，一些类需要这个方法，另外一些类不需要这个方法时，可以将该方法定义到接口中。需要这个方法的类就去实现这个接口，不需要这个方法的就可以不实现这个接口。接口主要规定的是行为。</p>
<p>注意：一个类继承某个类的同时可以实现多个接口：class 类 extends 父类 implements 接口A,接口B{}</p>
<p>注意：当某种类型向下转型为某个接口类型时，接口类型和该类之间可以没有继承关系，编译器不会报错的。</p>
<h3 id="17-UML-统一建模语言概述"><a href="#17-UML-统一建模语言概述" class="headerlink" title="17. UML(统一建模语言概述)"></a>17. UML(统一建模语言概述)</h3><h4 id="考虑一下类之间的关系"><a href="#考虑一下类之间的关系" class="headerlink" title="考虑一下类之间的关系."></a>考虑一下类之间的关系.</h4><p>①UML（Unified Modeling Language，统一建模语言）是一种用于面向对象软件开发的图形化的建模语言。它由Grady Booch、James Rumbaugh和Ivar Jacobson等三位著名的软件工程师所开发，并于1997年正式发布。UML提供了一套通用的图形化符号和规范，帮助开发人员以图形化的形式表达软件设计和编写的所有关键方面，从而更好地展示软件系统的设计和实现过程。</p>
<p>②UML是一种图形化的语言，类似于现实生活中建筑工程师画的建筑图纸，图纸上有特定的符号代表特殊的含义。</p>
<p>③UML不是专门为java语言准备的。只要是面向对象的编程语言，开发前的设计，都需要画UML图进行系统设计。（设计模式、软件开发七大原则等同样也不是只为java语言准备的。）</p>
<p>④UML图包括：</p>
<ul>
<li>类图（Class Diagram）：描述软件系统中的类、接口、关系和其属性等；</li>
<li>用例图（Use Case Diagram）：描述系统的功能需求和用户与系统之间的关系；</li>
<li>序列图（Sequence Diagram）：描述对象之间的交互、消息传递和时序约束等；</li>
<li>状态图（Statechart Diagram）：描述类或对象的生命周期以及状态之间的转换；</li>
<li>对象图（Object Diagram）：表示特定时间的系统状态，并显示其包含的对象及其属性；</li>
<li>协作图（Collaboration Diagram）：描述对象之间的协作，表示对象之间相互合作来完成任务的关系；</li>
<li>活动图（Activity Diagram）：描述系统的动态行为和流程，包括控制流和对象流；</li>
<li>部署图（Deployment Diagram）：描述软件或系统在不同物理设备上部署的情况，包括计算机、网络、中间件、应用程序等。</li>
</ul>
<p>⑤常见的UML建模工具有：StarUML，Rational Rose等。</p>
<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><ol>
<li>泛化关系（is a）&#x2F;&#x2F;继承关系</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">泛化关系（继承关系）is a关系。Cat is a Animal</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226173319940.png" alt="image-20240226173319940"></p>
<ol start="2">
<li>实现关系（is like a）&#x2F;&#x2F;定义一个接口,然后有一个实现接口类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现关系 is like a 关系。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Usb</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HardDrive</span> <span class="keyword">implements</span> <span class="title class_">Usb</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226173405538.png" alt="image-20240226173405538"></p>
<ol start="3">
<li>关联关系（has a）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">关联关系 has a</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Course</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量（属性）</span></span><br><span class="line">    Course course;</span><br><span class="line">&#125;</span><br><span class="line">A里面有B</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226173521101.png" alt="image-20240226173521101"></p>
<ol start="4">
<li>聚合关系</li>
</ol>
<blockquote>
<p>聚合关系指的是一个类包含、合成或者拥有另一个类的实例，而这个实例是可以独立存在的。聚合关系是一种弱关联关系，表示整体与部分之间的关系。例如一个教室有多个学生</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226174835150.png" alt="image-20240226174835150"></p>
<blockquote>
<p><strong>&#x3D;&#x3D;生命不绑定在一起&#x3D;&#x3D;</strong></p>
</blockquote>
<ol start="5">
<li>组合关系（Composition）</li>
</ol>
<blockquote>
<p><strong>组合关系是聚合关系的一种特殊情况，表示整体与部分之间的关系更加强烈</strong>。组合关系指的是一个类包含、合成或者拥有另一个类的实例，而这个实例只能同时存在于一个整体对象中。如果整体对象被销毁，那么部分对象也会被销毁。&#x3D;&#x3D;<strong>例如一个人对应四个肢体</strong>&#x3D;&#x3D;。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Limbs</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    List&lt;Limbs&gt; limbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175009462.png" alt="image-20240226175009462"></p>
<ol start="6">
<li>依赖关系（Dependency）</li>
</ol>
<blockquote>
<p>依赖关系是一种临时性的关系，**&#x3D;&#x3D;当一个类使用另一个类的功能时&#x3D;&#x3D;**，就会产生依赖关系。如果一个类的改变会影响到另一个类的功能，那么这两个类之间就存在依赖关系。依赖关系是一种较弱的关系，可以存在多个依赖于同一个类的对象。&#x3D;&#x3D;<strong>例如A类中使用了B类，但是B类作为A类的方法参数或者局部变量等</strong>。&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175047202.png" alt="image-20240226175047202"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">(A a)</span>&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">          A a;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-访问控制权限"><a href="#18-访问控制权限" class="headerlink" title="&#x3D;&#x3D;18. 访问控制权限&#x3D;&#x3D;"></a>&#x3D;&#x3D;18. 访问控制权限&#x3D;&#x3D;</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175206352.png" alt="image-20240226175206352"></p>
<p>①private：私有的，只能在本类中访问。</p>
<p>②缺省：默认的，同一个包下可以访问。</p>
<p>③protected：受保护的，子类中可以访问。（&#x3D;&#x3D;受保护的通常就是给子孙用的。&#x3D;&#x3D;）clone就是protected的</p>
<p>④public：公共的，在任何位置都可以访问。</p>
<p>&#x3D;&#x3D;①类中的属性和方法访问权限共有四种：private、缺省、protected和public。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;②类的访问权限只有两种：public和 缺省。&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">只有以上两种是正确的</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="comment">//这个就是错误的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③访问权限控制符不能修饰局部变量。</p>
<blockquote>
<p>注意:class里面的属性,方法的访问权限是四个;但是对于定义类,是只有两种访问权限的.!</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226175919594.png" alt="image-20240226175919594"></p>
<h3 id="19-Object类"><a href="#19-Object类" class="headerlink" title="19.Object类"></a>19.Object类</h3><h4 id="①java-lang-Object是所有类的超类。java中所有类都实现了这个类中的方法。"><a href="#①java-lang-Object是所有类的超类。java中所有类都实现了这个类中的方法。" class="headerlink" title="①java.lang.Object是所有类的超类。java中所有类都实现了这个类中的方法。"></a>①java.lang.Object是所有类的超类。java中所有类都实现了这个类中的方法。</h4><h4 id="②Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。"><a href="#②Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。" class="headerlink" title="②Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。"></a>②Object类是我们学习JDK类库的第一个类。通过这个类的学习要求掌握会查阅API帮助文档。</h4><h4 id="③现阶段Object类中需要掌握的方法："><a href="#③现阶段Object类中需要掌握的方法：" class="headerlink" title="③现阶段Object类中需要掌握的方法："></a>③现阶段Object类中需要掌握的方法：</h4><p> toString：将java对象转换成字符串。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226180456350.png" alt="image-20240226180456350"></p>
<p> equals：判断两个对象是否相等。&#x2F;&#x2F;返回一个布尔类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">== 的作用：</span><br><span class="line"></span><br><span class="line">　　基本类型：比较的就是值是否相同</span><br><span class="line"></span><br><span class="line">　　引用类型：比较的就是地址值是否相同</span><br><span class="line">　　</span><br><span class="line">equals 的作用:</span><br><span class="line"></span><br><span class="line">　　引用类型：默认情况下，比较的是地址值。</span><br><span class="line"></span><br><span class="line">注：不过，我们可以根据情况自己重写该方法。一般重写都是自动生成，比较对象的成员变量值是否相同</span><br><span class="line">String类中被复写的equals()方法其实是比较两个字符串的内容</span><br></pre></td></tr></table></figure>



<h4 id="④现阶段Object类中需要了解的方法："><a href="#④现阶段Object类中需要了解的方法：" class="headerlink" title="④现阶段Object类中需要了解的方法："></a>④现阶段Object类中需要了解的方法：</h4><p> hashCode：返回一个对象的哈希值，通常作为在哈希表中查找该对象的键值。Object类的默认实现是根据对象的内存地址生成一个哈希码（即将对象的内存地址转换为整数作为哈希值）。hashCode()方法是为了HashMap、Hashtable、HashSet等集合类进行优化而设置的，以便更快地查找和存储对象。</p>
<p> finalize：当java对象被回收时，由GC自动调用被回收对象的finalize方法，通常在该方法中完成销毁前的准备。</p>
<h5 id="clone：对象的拷贝。（浅拷贝，深拷贝）"><a href="#clone：对象的拷贝。（浅拷贝，深拷贝）" class="headerlink" title="&#x3D;&#x3D;clone：对象的拷贝。（浅拷贝，深拷贝）&#x3D;&#x3D;"></a><strong>&#x3D;&#x3D;clone：对象的拷贝。（浅拷贝，深拷贝）&#x3D;&#x3D;</strong></h5><p><a href="https://blog.csdn.net/riemann_/article/details/87217229">Java深入理解深拷贝和浅拷贝区别_java深拷贝浅拷贝-CSDN博客</a></p>
<h6 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝:"></a>浅拷贝:</h6><blockquote>
<p>Object的默认方法,专门给子类使用的,受保护的,c++实现的</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226181415375.png" alt="image-20240226181415375"></p>
<blockquote>
<p>user和usertest不符合三个要求,不能进行clone,那么怎么实现呢?</p>
<p>重写!</p>
<p>1.<strong>&#x3D;&#x3D;建议把重写的修饰符改为public&#x3D;&#x3D;</strong></p>
<p>2.要实现接口 <strong>&#x3D;&#x3D;implements Cloneable&#x3D;&#x3D;</strong>(这是一个标志接口,给java虚拟机看的)</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226181815569.png" alt="image-20240226181815569"></p>
<p>  protected修饰的只能在同一个包下或者子类中访问。</p>
<p> 只有实现了Cloneable接口的对象才能被克隆。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226182500898.png" alt="image-20240226182500898"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226182936458.png" alt="image-20240226182936458"></p>
<h6 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝:"></a>深拷贝:</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是浅拷贝</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">       <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">super</span>.clone();</span><br><span class="line">       <span class="keyword">return</span> object;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//这是深拷贝</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">       <span class="comment">// 浅复制时：</span></span><br><span class="line">       <span class="comment">// Object object = super.clone();</span></span><br><span class="line">       <span class="comment">// return object;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 改为深复制：</span></span><br><span class="line">       <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) <span class="built_in">super</span>.clone();</span><br><span class="line">       <span class="comment">// 本来是浅复制，现在将Teacher对象复制一份并重新set进来</span></span><br><span class="line">       student.setTeacher((Teacher) student.getTeacher().clone());</span><br><span class="line">       <span class="keyword">return</span> student;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-clone"><a href="#20-clone" class="headerlink" title="20.clone"></a>20.clone</h3><h5 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h5><blockquote>
<p>直接赋值的方式没有生产新的对象，只是生新增了一个对象引用**，直接赋值在 Java 内存中的模型大概是这样的</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226184438712.png" alt="image-20240226184438712"></p>
<h5 id="浅拷贝-1"><a href="#浅拷贝-1" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><blockquote>
<p>如果原型对象的成员变量是值类型，将复制一份给克隆对象，也就是说在堆中拥有独立的空间；</p>
<p>如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p>
<p>换句话说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226184739067.png" alt="image-20240226184739067"></p>
<p>也就是新开一个空间,放克隆的对象,但是这个地址里放的还是原来的引用地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 重写 clone 方法，需要将权限改成 public ，直接调用父类的 clone 方法就好了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略...</span><br><span class="line">&#125;\\</span><br><span class="line">    ***************</span><br><span class="line">person对象：Person&#123;name=<span class="string">&#x27;张三&#x27;</span>, age=<span class="number">20</span>, email=<span class="string">&#x27;123456@qq.com&#x27;</span>, desc=<span class="string">&#x27;我是张三&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">person1对象：Person&#123;name=<span class="string">&#x27;我是张三的克隆对象&#x27;</span>, age=<span class="number">22</span>, email=<span class="string">&#x27;123456@qq.com&#x27;</span>, desc=<span class="string">&#x27;我是张三&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 初始化一个对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>,<span class="string">&quot;123456@qq.com&quot;</span>,<span class="string">&quot;我是张三&quot;</span>);</span><br><span class="line">        <span class="comment">// 复制对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> (Person) person.clone();</span><br><span class="line">        <span class="comment">// 改变 person1 的属性值</span></span><br><span class="line">        person1.setName(<span class="string">&quot;我是张三的克隆对象&quot;</span>);</span><br><span class="line">        <span class="comment">// 修改 person age 的值</span></span><br><span class="line">        person1.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;person对象：&quot;</span>+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;person1对象：&quot;</span>+person1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String、Integer 等包装类都是不可变的对象，当需要修改不可变对象的值时，需要在内存中生成一个新的对象来存放新的值，然后将原来的引用指向新的地址，所以在这里我们修改了 person1 对象的 name 属性值，person1 对象的 name 字段指向了内存中新的 name 对象，</p>
<p>但是我们并没有改变 person 对象的 name 字段的指向，所以 person 对象的 name 还是指向内存中原来的 name 地址，也就没有变化</p>
<h5 id="深拷贝-1"><a href="#深拷贝-1" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>深拷贝也是对象克隆的一种方式，相对于浅拷贝，<strong>深拷贝是一种完全拷贝，无论是值类型还是引用类型都会完完全全的拷贝一份，在内存中生成一个新的对象</strong>，简单点说就是拷贝对象和被拷贝对象没有任何关系，互不影响。深拷贝的通用模型如下</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/v2-cb4cb526cc8a637848ad2ad176d50d40_720w.webp" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonDesc</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述</span></span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    ...省略...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 邮件</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * clone 方法不是简单的调用super的clone 就好，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person)<span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">// 需要将引用对象也克隆一次</span></span><br><span class="line">        person.personDesc = (PersonDesc) personDesc.clone();</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-内部类"><a href="#21-内部类" class="headerlink" title="21.内部类"></a>21.内部类</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%862/image-20240226185936183.png" alt="image-20240226185936183"></p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类:"></a>静态内部类:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于静态内部类来说：访问控制权限修饰符在这里都可以使用。</span><br><span class="line">private static class InnerClass&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//怎么创建内部类对象</span><br><span class="line">OuterClass.InnerClass innerClass = new OuterClass.InnerClass();</span><br><span class="line">OuterClass.InnerClass.m4();</span><br><span class="line">innerClass.m3();</span><br></pre></td></tr></table></figure>

<p>由于在创建静态内部类的时候,不用创建外部的那个类,所以不能访问外部类所定义的实例变量和实例方法,但是可以访问静态变量和静态方法,因为静态的(static)是刚开始运行的时候就会跑的,写入编译文件中的</p>
<h4 id="实例内部类"><a href="#实例内部类" class="headerlink" title="实例内部类"></a>实例内部类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 实例内部类：等同可以看做实例变量。</span><br><span class="line">* 结论：实例内部类中可以直接访问外部类中实例成员和静态成员。</span><br><span class="line">就是在创建这个实例内部类中,会创建外部类//自己的理解</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的实例方法m1执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;外部类的静态方法m2执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例内部类</span></span><br><span class="line">    <span class="comment">// 也可以使用访问权限修饰符修饰。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">x</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(j);</span><br><span class="line">            m1();</span><br><span class="line">            m2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        System.out.println(outerClass.i);</span><br><span class="line">        OuterClass.<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.x();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><blockquote>
<p>①局部内部类：和局部变量一个级别</p>
<p>局部内部类方外类外部的局部变量时，局部变量需要被final修饰。</p>
<p>从JDK8开始，不需要手动添加final了，但JVM会自动添加。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">            <span class="comment">// 实例方法</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">x</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(k);</span><br><span class="line">                System.out.println(f);</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// new对象</span></span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        innerClass.x();</span><br><span class="line">        <span class="comment">//这两行执行了,这个内部类就要执行,内部类执行就需要这个实例方法执行,这个实例方法执行,就要这个外部类创建,所以在不受限制的情况下,实例变量/方法和静态变量/方法是都可以访问的,但是不可以改,是默认加final的 </span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 局部内部类：等同于局部变量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：局部内部类能不能访问外部类的数据，取决于局部内部类所在的方法。</span></span><br><span class="line"><span class="comment"> * 如果这个方法是静态的：只能访问外部类中静态的。</span></span><br><span class="line"><span class="comment"> * 如果这个方法是实例的：可以都访问。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 局部内部类不能使用访问权限修饰符修饰。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 局部内部类在访问外部的局部变量时，这个局部变量必须是final的。只不过从JDK8开始。这个final关键字不需要提供了。系统自动提供。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="&#x3D;&#x3D;匿名内部类&#x3D;&#x3D;"></a>&#x3D;&#x3D;匿名内部类&#x3D;&#x3D;</h4><p><strong>特殊的局部内部类，没有名字，只能用一次。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.javase.oop45;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 匿名内部类：没有名字的类。只能使用一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建电脑对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">//computer.conn(new Printer());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下conn方法参数上的代码做了两件事：</span></span><br><span class="line">        <span class="comment">// 第一：完成了匿名内部类的定义。</span></span><br><span class="line">        <span class="comment">// 第二：同时实例化了一个匿名内部类的对象。</span></span><br><span class="line">        computer.conn(<span class="keyword">new</span> <span class="title class_">Usb</span>()&#123;</span><br><span class="line">            <span class="comment">// 接口的实现</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;read.....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;write.....&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conn</span><span class="params">(Usb usb)</span>&#123;</span><br><span class="line">        usb.read();</span><br><span class="line">        usb.write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个接口的实现类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Printer implements Usb &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void read() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;打印机开始读取数据&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void write() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;打印机开始打印&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java体系知识</category>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础部分4-集合</title>
    <url>/2024/02/28/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%864-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><h3 id="①什么是集合，有什么用？"><a href="#①什么是集合，有什么用？" class="headerlink" title="①什么是集合，有什么用？"></a>①什么是集合，有什么用？</h3><p>1.集合是一种容器，用来组织和管理数据的。非常重要。</p>
<p><strong>2.Java的集合框架对应的这套类库其实就是对各种数据结构的实现。</strong></p>
<p>3.每一个集合类底层采用的数据结构不同，例如ArrayList集合底层采用了数组，LinkedList集合底层采用了双向链表，HashMap集合底层采用了哈希表，TreeMap集合底层采用了红黑树。</p>
<p>4.我们不用写数据结构的实现了。直接用就行了。但我们需要知道的是在哪种场合下选择哪一个集合效率是最高的。</p>
<h3 id="②集合中-存储的是引用-，不是把堆中的对象存储到集合中，是把-对象的地址-存储到集合中。"><a href="#②集合中-存储的是引用-，不是把堆中的对象存储到集合中，是把-对象的地址-存储到集合中。" class="headerlink" title="②集合中&#x3D;&#x3D;存储的是引用&#x3D;&#x3D;，不是把堆中的对象存储到集合中，是把&#x3D;&#x3D;对象的地址&#x3D;&#x3D;存储到集合中。"></a>②集合中&#x3D;&#x3D;存储的是引用&#x3D;&#x3D;，不是把堆中的对象存储到集合中，是把&#x3D;&#x3D;对象的地址&#x3D;&#x3D;存储到集合中。</h3><h3 id="③默认情况下，-如果不使用泛型的话，集合中可以存储任何类型的引用，只要是Object的子类都可以存储。"><a href="#③默认情况下，-如果不使用泛型的话，集合中可以存储任何类型的引用，只要是Object的子类都可以存储。" class="headerlink" title="③默认情况下，&#x3D;&#x3D;如果不使用泛型的话，集合中可以存储任何类型的引用，只要是Object的子类都可以存储。&#x3D;&#x3D;"></a>③默认情况下，&#x3D;&#x3D;<strong>如果不使用泛型的话</strong>，集合中可以存储任何类型的引用，只要是Object的子类都可以存储。&#x3D;&#x3D;</h3><h3 id="④Java集合框架相关的类都在-java-util-包下。"><a href="#④Java集合框架相关的类都在-java-util-包下。" class="headerlink" title="④Java集合框架相关的类都在 java.util 包下。"></a>④Java集合框架相关的类都在 java.util 包下。</h3><h3 id="⑤Java集合框架分为两部分："><a href="#⑤Java集合框架分为两部分：" class="headerlink" title="⑤Java集合框架分为两部分："></a>⑤Java集合框架分为两部分：</h3><p>1.Collection结构：元素以单个形式存储。</p>
<p>2.Map结构：元素以键值对的映射关系存储。</p>
<h2 id="Collection继承结构"><a href="#Collection继承结构" class="headerlink" title="Collection继承结构"></a>Collection继承结构</h2><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><h2 id="SequencedCollection接口"><a href="#SequencedCollection接口" class="headerlink" title="SequencedCollection接口"></a>SequencedCollection接口</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="迭代时删除元素"><a href="#迭代时删除元素" class="headerlink" title="迭代时删除元素"></a>迭代时删除元素</h2><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h2 id="链表存储结构"><a href="#链表存储结构" class="headerlink" title="链表存储结构"></a>链表存储结构</h2><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h2 id="栈数据结构"><a href="#栈数据结构" class="headerlink" title="栈数据结构"></a>栈数据结构</h2><h2 id="队列数据结构"><a href="#队列数据结构" class="headerlink" title="队列数据结构"></a>队列数据结构</h2><h2 id="Map继承结构"><a href="#Map继承结构" class="headerlink" title="Map继承结构"></a>Map继承结构</h2><h2 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h2><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><h2 id="二叉树与红黑二叉树"><a href="#二叉树与红黑二叉树" class="headerlink" title="二叉树与红黑二叉树"></a>二叉树与红黑二叉树</h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2>]]></content>
      <categories>
        <category>Java体系知识</category>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java基础部分3</title>
    <url>/2024/02/26/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h3><h4 id="①什么是数组？"><a href="#①什么是数组？" class="headerlink" title="①什么是数组？"></a>①什么是数组？</h4><p>1.在Java中，数组是一种用于存储多个相同数据类型元素的容器。</p>
<p>2.例如一个存储整数的数组：int[] nums &#x3D; {100, 200, 300};</p>
<p>3.例如一个存储字符串的数组：String[] names &#x3D; {“jack”,“lucy”,“lisi”};</p>
<p>4.数组是一种引用数据类型，隐式继承Object。因此数组也可以调用Object类中的方法。</p>
<p>5.数组对象存储在堆内存中。</p>
<h4 id="②数组的分类？"><a href="#②数组的分类？" class="headerlink" title="②数组的分类？"></a>②数组的分类？</h4><p>1.根据维数进行分类：一维数组，二维数组，三维数组，多维数组。</p>
<p>2.根据数组中存储的元素类型分类：基本类型数组，引用类型数组。</p>
<p>3.根据数组初始化方式不同分类：静态数组，动态数组。</p>
<h4 id="③Java数组存储元素的特点？"><a href="#③Java数组存储元素的特点？" class="headerlink" title="③Java数组存储元素的特点？"></a>③Java数组存储元素的特点？</h4><p>1.数组长度一旦确定不可变。</p>
<p>2.数组中元素数据类型一致，每个元素占用空间大小相同。</p>
<p>3.数组中每个元素在空间存储上，内存地址是连续的。</p>
<p>4.每个元素有索引，首元素索引0，以1递增。</p>
<p>5.以首元素的内存地址作为数组对象在堆内存中的地址。</p>
<p>6.所有数组对象都有length属性用来获取数组元素个数。末尾元素下标：length-1</p>
<h4 id="①数组优点？"><a href="#①数组优点？" class="headerlink" title="①数组优点？"></a>①数组优点？</h4><p><strong>1.根据下标查询某个元素的效率极高。</strong>数组中有100个元素和有100万个元素，查询效率相同。时间复杂度O(1)。也就是说在数组中根据下标查询某个元素时，不管数组的长短，耗费时间是固定不变的。</p>
<p> 原因：<strong>知道首元素内存地址，元素在空间存储上内存地址又是连续的</strong>，每个元素占用空间大小相同，只要知道下标，就可以通过数学表达式计算出来要查找元素的内存地址。直接通过内存地址定位元素。</p>
<h4 id="②数组缺点？"><a href="#②数组缺点？" class="headerlink" title="②数组缺点？"></a>②数组缺点？</h4><p><strong>1.随机增删元素的效率较低。因为随机增删元素时，为了保证数组中元素的内存地址连续，就需要涉及到后续元素的位移问题。时间复杂度O(n)。O(n)表示的是线性阶，随着问题规模n的不断增大，时间复杂度不断增大，算法的执行效率越低。（不过需要注意的是：对数组末尾元素的增删效率是不受影响的。）</strong></p>
<p><strong>2.无法存储大量数据，因为很难在内存上找到非常大的一块连续的内存。</strong></p>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="①一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。"><a href="#①一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。" class="headerlink" title="①一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。"></a>①一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构。</h4><h4 id="②如何静态初始化一维数组？"><a href="#②如何静态初始化一维数组？" class="headerlink" title="②如何静态初始化一维数组？"></a>②如何静态初始化一维数组？</h4><p>1.第一种：int[] arr &#x3D; {55,67,22}; 或者 int arr[] &#x3D; {55,67,22};</p>
<p>2.第二种：int[] arr &#x3D; new int[]{55,67,22};</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal[] animals = &#123;a1,a2,<span class="keyword">new</span> <span class="title class_">Animal</span>()&#125;;</span><br><span class="line"><span class="comment">//静态初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="③如何访问数组中的元素？"><a href="#③如何访问数组中的元素？" class="headerlink" title="③如何访问数组中的元素？"></a>③如何访问数组中的元素？</h4><p>1.通过下标来访问。</p>
<p>2.注意ArrayIndexOutOfBoundsException异常的发生。</p>
<h4 id="④如何遍历数组？"><a href="#④如何遍历数组？" class="headerlink" title="④如何遍历数组？"></a>④如何遍历数组？</h4><p>1.普通for循环遍历</p>
<p>2.for-each遍历（优点是代码简洁。缺点是没有下标。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; citys.length;i++)&#123;</span><br><span class="line">	System.out.println(citys[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for each</span></span><br><span class="line"><span class="keyword">for</span>(String name:names)&#123;</span><br><span class="line">	System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="⑤如何动态初始化一维数组？"><a href="#⑤如何动态初始化一维数组？" class="headerlink" title="⑤如何动态初始化一维数组？"></a>⑤如何动态初始化一维数组？</h4><blockquote>
<p>在创建数组的时候，不确定具体存储那些数据，但是确定长度（就是开辟空间）</p>
<p>数据类型[] 变量名 &#x3D; new 数据类型[长度]</p>
</blockquote>
<p>1.int[] arr &#x3D; new int[4];</p>
<p>2.Object[] objs &#x3D; new Object[5];</p>
<p>3.数组动态初始化的时候，确定长度，并且数组中每个元素采用默认值。</p>
<h4 id="⑥方法在调用时如何给方法传一个数组对象？"><a href="#⑥方法在调用时如何给方法传一个数组对象？" class="headerlink" title="⑥方法在调用时如何给方法传一个数组对象？"></a>⑥方法在调用时如何给方法传一个数组对象？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">   display(a);</span><br><span class="line">display(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)<span class="comment">//error</span></span><br><span class="line">   display(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);<span class="comment">//静态初始化</span></span><br><span class="line">display(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]);<span class="comment">//动态初始化</span></span><br></pre></td></tr></table></figure>

<h4 id="⑦当一维数组中存储引用时的内存图？"><a href="#⑦当一维数组中存储引用时的内存图？" class="headerlink" title="⑦当一维数组中存储引用时的内存图？"></a>⑦当一维数组中存储引用时的内存图？</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Animals[] animals = new Animals[5];</span><br><span class="line"></span><br><span class="line">Object[] test = &#123;new Bird(),new Cat()&#125;</span><br><span class="line">public class Animal &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227110419147.png" alt="image-20240227110419147"></p>
<blockquote>
<p>数组中存储的每个元素的空间大小都是一样的，所以空间是不可能一样的，所以是不可能存储引用对象的，所以是存储的是引用（对象在堆内存中的地址）</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227111451718.png" alt="image-20240227111451718"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227111729307.png" alt="image-20240227111729307"></p>
<h4 id="⑧如何获取数组中的最大值？"><a href="#⑧如何获取数组中的最大值？" class="headerlink" title="⑧如何获取数组中的最大值？"></a>⑧如何获取数组中的最大值？</h4><p>​	假设首元素是最大的，然后遍历数组中所有元素，只要有更大的，就将其作为最大值。</p>
<p>​	思考：找出最大值的下标怎么做？</p>
<h4 id="⑨如果知道值，如何通过值找它的下标？"><a href="#⑨如果知道值，如何通过值找它的下标？" class="headerlink" title="⑨如果知道值，如何通过值找它的下标？"></a>⑨如果知道值，如何通过值找它的下标？</h4><h4 id="⑩如何将数组中的所有元素反转？"><a href="#⑩如何将数组中的所有元素反转？" class="headerlink" title="⑩如何将数组中的所有元素反转？"></a>⑩如何将数组中的所有元素反转？</h4><h5 id="第一种方式：创建一个新的数组。"><a href="#第一种方式：创建一个新的数组。" class="headerlink" title="第一种方式：创建一个新的数组。"></a>第一种方式：创建一个新的数组。</h5><p>就是倒着遍历第一个，然后赋值过去</p>
<h5 id="第二种方式：首尾交换。"><a href="#第二种方式：首尾交换。" class="headerlink" title="第二种方式：首尾交换。"></a>第二种方式：首尾交换。</h5><p>就是第一个和倒数第一个交换，以此类推</p>
<h4 id="⑾关于main方法的形参args？"><a href="#⑾关于main方法的形参args？" class="headerlink" title="⑾关于main方法的形参args？"></a>⑾关于main方法的形参args？</h4><p>​	接收命令行参数，</p>
<p>​	JVM 负责调用这个类名.main()方法的</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227112624635.png" alt="image-20240227112624635"></p>
<blockquote>
<p>JVM会把以上字符串以“空格”进行拆分，生成一个新的数组对象</p>
<p>最后这个数组对象是String[] args &#x3D; {“abc”,”def”,”xyz”}</p>
</blockquote>
<p>​	在DOS命令窗口中怎么传？在IDEA中怎么传？</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227112947509.png" alt="image-20240227112947509"></p>
<h4 id="⑿关于方法的可变长度参数？"><a href="#⑿关于方法的可变长度参数？" class="headerlink" title="⑿关于方法的可变长度参数？"></a>⑿关于方法的可变长度参数？</h4><p>​	可变长参数只能出现在形参列表中的最后一个位置。</p>
<p>​	可变长参数可以当做数组来处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mi</span><span class="params">(<span class="type">int</span>... nums)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m0; i &lt; nums;i++)&#123;</span><br><span class="line">		System.out.println(nums[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="⒀一维数组的扩容"><a href="#⒀一维数组的扩容" class="headerlink" title="⒀一维数组的扩容"></a>⒀一维数组的扩容</h4><p>①数组长度一旦确定不可变。</p>
<p>②那数组应该如何扩容？</p>
<p>​		<strong>&#x3D;&#x3D;只能创建一个更大的数组将原数组中的数据全部拷贝到新数组中&#x3D;&#x3D;</strong></p>
<p>​		<strong>&#x3D;&#x3D;可以使用System.arraycopy()方法完成数组的拷贝。&#x3D;&#x3D;</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.arraycopy(src,srcpos:<span class="number">0</span>,dest,destpos:<span class="number">0</span>,src.length)<span class="comment">//注意越界问题</span></span><br></pre></td></tr></table></figure>

<p>③数组扩容会影响程序的执行效率，因此尽可能预测数据量，创建一个接近数量的数组，减少扩容次数。</p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="①二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组（相当于存的还是一个地址，是一维数组的首位地址）。"><a href="#①二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组（相当于存的还是一个地址，是一维数组的首位地址）。" class="headerlink" title="①二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组（相当于存的还是一个地址，是一维数组的首位地址）。"></a>①二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组（相当于存的还是一个地址，是一维数组的首位地址）。</h4><h4 id="②二维数组的静态初始化"><a href="#②二维数组的静态初始化" class="headerlink" title="②二维数组的静态初始化"></a>②二维数组的静态初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr = &#123;&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="③二维数组的动态初始化-等长"><a href="#③二维数组的动态初始化-等长" class="headerlink" title="③二维数组的动态初始化(等长)"></a>③二维数组的动态初始化(等长)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h4 id="④二维数组的动态初始化（不等长）"><a href="#④二维数组的动态初始化（不等长）" class="headerlink" title="④二维数组的动态初始化（不等长）"></a>④二维数组的动态初始化（不等长）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br></pre></td></tr></table></figure>

<h4 id="⑤二维数组中元素的访问"><a href="#⑤二维数组中元素的访问" class="headerlink" title="⑤二维数组中元素的访问"></a>⑤二维数组中元素的访问</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一个元素：arr[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">最后一个元素：arr[arr.length-<span class="number">1</span>][arr[arr.length-<span class="number">1</span>].length-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="⑥二维数组中元素的遍历"><a href="#⑥二维数组中元素的遍历" class="headerlink" title="⑥二维数组中元素的遍历"></a>⑥二维数组中元素的遍历</h4><h3 id="IDEA的Debug"><a href="#IDEA的Debug" class="headerlink" title="IDEA的Debug"></a>IDEA的Debug</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122020670.png" alt="image-20240227122020670"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122031704.png" alt="image-20240227122031704"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122037930.png" alt="image-20240227122037930"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122045388.png" alt="image-20240227122045388"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122051856.png" alt="image-20240227122051856"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227122056862.png" alt="image-20240227122056862"></p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227123624933.png" alt="image-20240227123624933"></p>
<h4 id="①什么是单元测试，为什么要进行单元测试？"><a href="#①什么是单元测试，为什么要进行单元测试？" class="headerlink" title="①什么是单元测试，为什么要进行单元测试？"></a>①什么是单元测试，为什么要进行单元测试？</h4><p>1.一个项目是巨大的，只有保证你写的每一块都是正确的，最后整个项目才能正常运行。这里所谓的每一块就是一个单元。</p>
<h4 id="②做单元测试需要引入JUnit框架，JUnit框架在JDK中没有，需要额外引入，也就是引入JUnit框架的class文件（jar包）"><a href="#②做单元测试需要引入JUnit框架，JUnit框架在JDK中没有，需要额外引入，也就是引入JUnit框架的class文件（jar包）" class="headerlink" title="②做单元测试需要引入JUnit框架，JUnit框架在JDK中没有，需要额外引入，也就是引入JUnit框架的class文件（jar包）"></a>②做单元测试需要引入JUnit框架，JUnit框架在JDK中没有，需要额外引入，也就是引入JUnit框架的class文件（jar包）</h4><p>step1：文件目录下新建lib文件夹；</p>
<p>step2：将三个jar包复制进去，</p>
<p>step3：全选右键，Add as library</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227123922794.png" alt="image-20240227123922794"></p>
<h4 id="③单元测试类（测试用例）怎么写？"><a href="#③单元测试类（测试用例）怎么写？" class="headerlink" title="③单元测试类（测试用例）怎么写？"></a>③单元测试类（测试用例）怎么写？</h4><p>1.单元测试类名：XxxTest</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227133137828.png" alt="image-20240227133137828"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227133302806.png" alt="image-20240227133302806"></p>
<h4 id="④单元测试方法怎么写？"><a href="#④单元测试方法怎么写？" class="headerlink" title="④单元测试方法怎么写？"></a>④单元测试方法怎么写？</h4><p>1.单元测试方法需要使用@Test注解标注。</p>
<p>2.单元测试方法返回值类型必须是void</p>
<p>3.单元测试方法形参个数为0 </p>
<p>4.建议单元测试方法名：testXxx</p>
<h4 id="⑤什么是期望值，什么是实际值？"><a href="#⑤什么是期望值，什么是实际值？" class="headerlink" title="⑤什么是期望值，什么是实际值？"></a>⑤什么是期望值，什么是实际值？</h4><p>1.期望值就是在程序执行之前，你觉得正确的输出结果应该是多少</p>
<p>2.实际值就是程序在实际运行之后得到的结果</p>
<h4 id="⑥常见注解："><a href="#⑥常见注解：" class="headerlink" title="⑥常见注解："></a>⑥常见注解：</h4><p>1.@BeforeAll @AfterAll 主要用于在测试开始之前&#x2F;之后执行必要的代码。被标注的方法需要是静态的。</p>
<p>2.@BeforeEach @AfterEach 主要用于在每个测试方法执行前&#x2F;后执行必要的代码。</p>
<h4 id="⑦单元测试中使用Scanner失效怎么办？"><a href="#⑦单元测试中使用Scanner失效怎么办？" class="headerlink" title="⑦单元测试中使用Scanner失效怎么办？"></a>⑦单元测试中使用Scanner失效怎么办？</h4><p>1.选中导航栏的“Help”，然后选中“Edit Custom VM Options…”，接着在“IDEA64.exe.vmoptions”文件中添加内容“-Deditable.java.test.console&#x3D;true”，最后在重启IDEA即可解决</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>跳过</p>
<h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><blockquote>
<p>java.util</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.toString()方法：将数组转换成字符串</span><br><span class="line"></span><br><span class="line">这个和Object.toString不同，</span><br><span class="line"><span class="comment">/*************************************************/</span></span><br><span class="line">Object.toString()</span><br><span class="line">Arrays.toString(att)<span class="comment">//很显然，这个是一个静态数组</span></span><br><span class="line"><span class="comment">/*************************************************/</span></span><br><span class="line">    </span><br><span class="line">Arrays.deepToString()方法：可以将二维数组转换成字符串</span><br><span class="line"></span><br><span class="line">Arrays.equals(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)方法：判断两个数组是否相等</span><br><span class="line"></span><br><span class="line">Arrays.equals(Object[] arr1, Object[] arr2)方法</span><br><span class="line"></span><br><span class="line">Arrays.deepEquals(Object[] arr1, Object[] arr2)方法：判断两个二维数组是否相等</span><br><span class="line"></span><br><span class="line">Arrays.sort(<span class="type">int</span>[] arr)方法：基于快速排序算法，适合小型数据量排序。</span><br><span class="line"></span><br><span class="line">Arrays.sort(String[] arr)方法</span><br><span class="line"></span><br><span class="line">Arrays.parallelSort(<span class="type">int</span>[] arr)方法：基于分治的归并排序算法，支持多核CPU排序，适合大数据量排序。<span class="comment">//多个线程</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> elt)</span>方法：二分法查找 </span><br><span class="line"></span><br><span class="line">Arrays.fill(<span class="type">int</span>[] arr, <span class="type">int</span> data)方法：填充数组</span><br><span class="line"></span><br><span class="line">Arrays.fill(<span class="type">int</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> val)方法</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] Arrays.copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength)方法：数组拷贝</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	<span class="type">int</span>[] arr2 = Arrays.copyOf(arr,newLength:<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝一个范围内的数组，to不包含</span></span><br><span class="line"><span class="type">int</span>[] Arrays.copyOfRange(<span class="type">int</span>[] original, <span class="type">int</span> from, <span class="type">int</span> to)</span><br><span class="line">    </span><br><span class="line">Arrays.asList(T... data)方法：将一组数据转换成List集合。    </span><br></pre></td></tr></table></figure>

<h2 id="异常Exception"><a href="#异常Exception" class="headerlink" title="异常Exception"></a>异常Exception</h2><h3 id="异常概述"><a href="#异常概述" class="headerlink" title="异常概述"></a>异常概述</h3><h4 id="①什么是异常？有什么用？"><a href="#①什么是异常？有什么用？" class="headerlink" title="①什么是异常？有什么用？"></a>①什么是异常？有什么用？</h4><p>1.Java中的异常是指程序运行时出现了错误或异常情况，导致程序无法继续正常执行的现象。例如，数组下标越界、空指针异常、类型转换异常等都属于异常情况。</p>
<p>2.Java提供了异常处理机制，即在程序中对可能出现的异常情况进行捕捉和处理。异常机制可以帮助程序员更好地管理程序的错误和异常情况，避免程序崩溃或出现不可预测的行为。</p>
<p>3.没有异常机制的话，程序中就可能会出现一些难以调试和预测的异常行为，可能导致程序崩溃，甚至可能造成数据损失或损害用户利益。因此，异常机制是一项非常重要的功能，是编写可靠程序的基础。</p>
<h4 id="②异常在Java中以类和对象的形式存在。"><a href="#②异常在Java中以类和对象的形式存在。" class="headerlink" title="②异常在Java中以类和对象的形式存在。"></a>②异常在Java中以类和对象的形式存在。</h4><p>1.现实生活中也有异常，比如地震，火灾就是异常。也可以提取出类和对象，例如：</p>
<p>1.地震是类：512大地震、唐山大地震就是对象。</p>
<p>2.空指针异常是类：发生在第52行的空指针异常、发生在第100行的空指针异常就是对象。</p>
<p>2.也就是说：在第52行和第100行发生空指针异常的时候，底层一定分别new了一个NullPointerException对象。在程序中异常是如何发生的？</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227140425131.png" alt="image-20240227140425131"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227140431623.png" alt="image-20240227140431623"></p>
<h3 id="异常继承结构"><a href="#异常继承结构" class="headerlink" title="异常继承结构"></a>异常继承结构</h3><h4 id="①所有的异常和错误都是可抛出的。都继承了Throwable类。"><a href="#①所有的异常和错误都是可抛出的。都继承了Throwable类。" class="headerlink" title="①所有的异常和错误都是可抛出的。都继承了Throwable类。"></a>①所有的异常和错误都是可抛出的。都继承了Throwable类。</h4><h4 id="②Error是无法处理的，出现后只有一个结果：JVM终止。"><a href="#②Error是无法处理的，出现后只有一个结果：JVM终止。" class="headerlink" title="②Error是无法处理的，出现后只有一个结果：JVM终止。"></a>②Error是无法处理的，出现后只有一个结果：JVM终止。</h4><h4 id="③Exception是可以处理的。"><a href="#③Exception是可以处理的。" class="headerlink" title="③Exception是可以处理的。"></a>③Exception是可以处理的。</h4><h4 id="④Exception的分类："><a href="#④Exception的分类：" class="headerlink" title="④Exception的分类："></a>④Exception的分类：</h4><p>1.所有的RuntimeException的子类：运行时异常&#x2F;未检查异常(UncheckedException)&#x2F;非受控异常</p>
<p>2.Exception的子类（除RuntimeException之外）：编译时异常&#x2F;检查异常(CheckedException)&#x2F;受控异常</p>
<h4 id="⑤编译时异常和运行时异常区别："><a href="#⑤编译时异常和运行时异常区别：" class="headerlink" title="⑤编译时异常和运行时异常区别："></a>⑤编译时异常和运行时异常区别：</h4><ul>
<li>1.编译时异常特点：在编译阶段必须提前处理，如果不处理编译器报错。</li>
<li>2.运行时异常特点：在编译阶段可以选择处理，也可以不处理，没有硬性要求。</li>
<li>3.编译时异常一般是由外部环境或外在条件引起的，如网络故障、磁盘空间不足、文件找不到等</li>
<li>4.运行时异常一般是由程序员的错误引起的，并且不需要强制进行异常处理</li>
</ul>
<p>注意：编译时异常并不是在编译阶段发生的异常，所有的异常发生都是在运行阶段的，因为每个异常发生都是会new异常对象的，new异常对象只能在运行阶段完成。那为什么叫做编译时异常呢？这是因为这种异常必须在编译阶段提前预处理，如果不处理编译器报错，因此而得名编译时异常。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227141452414.png" alt="image-20240227141452414"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227141713987.png" alt="image-20240227141713987"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NullPointerException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br></pre></td></tr></table></figure>



<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h4 id="step1：继承Exception（编译时异常）-RuntimeException"><a href="#step1：继承Exception（编译时异常）-RuntimeException" class="headerlink" title="step1：继承Exception（编译时异常）&#x2F;RuntimeException"></a>step1：继承Exception（编译时异常）&#x2F;RuntimeException</h4><h4 id="step2-提供一个无参数构造方法，再提供一个带String-msg参数的构造方法，在构造方法中调用父类的构造方法。"><a href="#step2-提供一个无参数构造方法，再提供一个带String-msg参数的构造方法，在构造方法中调用父类的构造方法。" class="headerlink" title="step2:   提供一个无参数构造方法，再提供一个带String msg参数的构造方法，在构造方法中调用父类的构造方法。"></a>step2:   提供一个无参数构造方法，再提供一个带String msg参数的构造方法，在构造方法中调用父类的构造方法。</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227143030302.png" alt="image-20240227143030302"></p>
<h3 id="异常的处理包括两种方式："><a href="#异常的处理包括两种方式：" class="headerlink" title="异常的处理包括两种方式："></a>异常的处理包括两种方式：</h3><h4 id="1-声明异常：类似于推卸责任的处理方式"><a href="#1-声明异常：类似于推卸责任的处理方式" class="headerlink" title="1.声明异常：类似于推卸责任的处理方式"></a>1.声明异常：类似于推卸责任的处理方式</h4><p>在方法定义时使用throws关键字声明异常，**&#x3D;&#x3D;告知调用者，调用这个方法可能会出现异常&#x3D;&#x3D;**。这种处理方式的态度是：如果出现了异常则会抛给调用者来处理。</p>
<p>如果一个异常发生后希望调用者来处理的，使用声明异常（俗话说：交给上级处理）</p>
<p><strong>&#x3D;&#x3D;注意这里是throws，然后在后面需要throw e的时候是没有s的&#x3D;&#x3D;</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> <span class="keyword">throws</span> AException, BException... &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果Exception和Exception都继承了Exception，那么也可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> <span class="keyword">throws</span> XException&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&#x3D;&#x3D;调用者在调用m()方法时，编译器会检测到该方法上用throws声明了异常，表示可能会抛出异常，编译器会继续检测该异常是否为编译时异常，如果为编译时异常则必须在编译阶段进行处理，如果不处理编译器就会报错。&#x3D;&#x3D;</strong></p>
<p><strong>如果所有位置都采用throws，包括main方法的处理态度也是throws，如果运行时出现了异常，最终异常是抛给了main方法的调用者（JVM），JVM则会终止程序的执行。</strong>&#x3D;&#x3D;<strong>因此为了保证程序在出现异常后不被中断，至少main方法不要再使用throws进行声明了。</strong>&#x3D;&#x3D;</p>
<p>发生异常后，在发生异常的位置上，往下的代码是不会执行的，除非进行了异常的捕捉。</p>
<h4 id="2-捕捉异常：真正的处理捕捉异常（真正的处理异常-try…catch…关键字-）"><a href="#2-捕捉异常：真正的处理捕捉异常（真正的处理异常-try…catch…关键字-）" class="headerlink" title="2.捕捉异常：真正的处理捕捉异常（真正的处理异常 (try…catch…关键字)）"></a>2.捕捉异常：真正的处理捕捉异常（真正的处理异常 (try…catch…关键字)）</h4><p>在可能出现异常的代码上使用try..catch进行捕捉处理。这种处理方式的态度是：把异常抓住。其它方法如果调用这个方法，对于调用者来说是不知道这个异常发生的。因为这个异常被抓住并处理掉了。</p>
<p>如果一个异常发生后，不需要调用者知道，也不需要调用者来处理，选择使用捕捉方式处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 尝试执行可能会出现异常的代码</span></span><br><span class="line"><span class="comment">// try块中的代码如果执行出现异常，出现异常的位置往下的代码是不会执行的，直接进入catch块执行</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(AException e)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到AException类型的异常，在这里处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(BException e)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到BException类型的异常，在这里处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XException e)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到XException类型的异常，在这里处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当try..catch..将所有发生的异常捕捉后，这里的代码是会继续往下执行的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 尝试执行可能会出现异常的代码</span></span><br><span class="line"><span class="comment">// try块中的代码如果执行出现异常，出现异常的位置往下的代码是不会执行的，直接进入catch块执行</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(AException e|BException e2)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到AException类型的异常，在这里处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XException e)&#123;</span><br><span class="line"><span class="comment">// </span></span><br></pre></td></tr></table></figure>

<p>catch可以写多个。并且遵循自上而下，从小到大。</p>
<p>因为，如果最大的在上面，后面的小的异常都不会抛出了，就会导致异常抛出的不够精确</p>
<h4 id="异常在处理的整个过程中应该是：声明和捕捉联合使用。"><a href="#异常在处理的整个过程中应该是：声明和捕捉联合使用。" class="headerlink" title="异常在处理的整个过程中应该是：声明和捕捉联合使用。"></a>异常在处理的整个过程中应该是：声明和捕捉联合使用。</h4><h4 id="什么时候捕捉？什么时候声明？"><a href="#什么时候捕捉？什么时候声明？" class="headerlink" title="什么时候捕捉？什么时候声明？"></a>什么时候捕捉？什么时候声明？</h4><p>如果**&#x3D;&#x3D;异常发生后需要调用者来处理的，需要调用者知道的，则采用声明方式。&#x3D;&#x3D;**否则采用捕捉。</p>
<h4 id="异常的常用方法"><a href="#异常的常用方法" class="headerlink" title="异常的常用方法"></a>异常的常用方法</h4><p> 获取异常的简单描述信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	exception.getMessage();</span><br><span class="line">	</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 尝试执行可能会出现异常的代码</span></span><br><span class="line"><span class="comment">// try块中的代码如果执行出现异常，出现异常的位置往下的代码是不会执行的，直接进入catch块执行</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(AException e)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到AException类型的异常，在这里处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(BException e)&#123;</span><br><span class="line"><span class="comment">// 如果捕捉到BException类型的异常，在这里处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XException e)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line">    System.out.println(message);</span><br><span class="line"><span class="comment">// 如果捕捉到XException类型的异常，在这里处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>         获取的message是通过构造方法创建异常对象时传递过去的message。
</code></pre>
<p> 打印异常堆栈信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exception.printStackTrace();</span><br></pre></td></tr></table></figure>

<p> 要会看异常的堆栈信息：</p>
<p>​			异常信息的打印是符合栈数据结构的。</p>
<p>​			看异常信息主要看最开始的描述信息。看栈顶信息。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227152502694.png" alt="image-20240227152502694"></p>
<h3 id="finally语句块"><a href="#finally语句块" class="headerlink" title="finally语句块"></a>finally语句块</h3><h4 id="finally语句块中的代码是一定会执行的。"><a href="#finally语句块中的代码是一定会执行的。" class="headerlink" title="finally语句块中的代码是一定会执行的。"></a>finally语句块中的代码是一定会执行的。</h4><h4 id="finally语句块不能单独使用，至少需要配合try语句块一起使用："><a href="#finally语句块不能单独使用，至少需要配合try语句块一起使用：" class="headerlink" title="finally语句块不能单独使用，至少需要配合try语句块一起使用："></a>finally语句块不能单独使用，至少需要配合try语句块一起使用：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>...<span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>...<span class="keyword">catch</span>...<span class="keyword">finally</span></span><br></pre></td></tr></table></figure>

<h4 id="通常在finally语句块中完成资源的释放"><a href="#通常在finally语句块中完成资源的释放" class="headerlink" title="通常在finally语句块中完成资源的释放"></a>通常在finally语句块中完成资源的释放</h4><p>资源释放的工作比较重要，如果资源没有释放会一直占用内存。</p>
<p>为了保证资源的关闭，也就是说：不管程序是否出现异常，关闭资源的代码一定要保证执行。</p>
<p>因此在finally语句块中通常进行资源的释放。</p>
<h4 id="final、finally、finalize分别是什么？"><a href="#final、finally、finalize分别是什么？" class="headerlink" title="final、finally、finalize分别是什么？"></a>final、finally、finalize分别是什么？</h4><p>final是一个关键字，修饰的类无法继承，修饰的方法无法覆盖，修饰的变量不能修改。</p>
<p>finally是一个关键字，和try一起使用，finally语句块中的代码一定会执行。\</p>
<p>finalize是一个标识符，它是Object类中的一个方法名。</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227152745145.png" alt="image-20240227152745145"></p>
<blockquote>
<p>innotnull</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227153843258.png" alt="image-20240227153843258"></p>
<h4 id="面试经典题"><a href="#面试经典题" class="headerlink" title="面试经典题"></a>面试经典题</h4><h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227154130653.png" alt="image-20240227154130653"></h5><blockquote>
<p>i为多少? 答:100</p>
<p>原因: </p>
<p>两个原则,(1)程序是自上而下执行的,(2)finally肯定是要执行的</p>
<p>所以,i返回的是100,但是会新建一个临时变量去执行i++</p>
<p>执行流程是先用一个临时变量做i++;然后做return,所以如果是return true;返回的就是true</p>
</blockquote>
<h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227213044733.png" alt="image-20240227213044733"></h5><blockquote>
<p>false:从上往下,finally一定会在最后执行</p>
</blockquote>
<h5 id="3"><a href="#3" class="headerlink" title="3."></a>3.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227213351296.png" alt="image-20240227213351296"></h5><blockquote>
<p>执行下一个</p>
<p>原则:就近原则(从继承关系的角度上讲)</p>
<p>null引用类型,距离String更近,String是Object的子类</p>
</blockquote>
<h5 id="4"><a href="#4" class="headerlink" title="4."></a>4.<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227213539958.png" alt="image-20240227213539958" style="zoom:200%;" /></h5><h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227214002828.png" alt="image-20240227214002828"></h5><blockquote>
<p>常理来说:a&#x3D;&#x3D;10;</p>
<p>因为static块是在类加载的时候运行的,最先运行的,按照顺序运行的.</p>
<p>在创建static int a的时候,(method这个方法还没有运行到???运行到了吗),b还没有赋值,默认值0.所以a没有被这个方法成功赋值,此外,由于静态变量即使不赋值也会赋值默认值,所以赋值了0</p>
</blockquote>
<h5 id="6"><a href="#6" class="headerlink" title="6."></a>6.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227214340480.png" alt="image-20240227214340480"></h5><blockquote>
<p>代码的执行顺序</p>
<p>我答:答不出来一点</p>
<p>答案:</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227215936922.png" alt="image-20240227215936922"></p>
</blockquote>
<p>所以static不是一定要在这个B使用之前就跑了,就想B的静态代码就是最后跑的,但是此刻已经实现了new B()</p>
<h3 id="方法覆盖与异常"><a href="#方法覆盖与异常" class="headerlink" title="方法覆盖与异常"></a>方法覆盖与异常</h3><p>方法重写之后，不能比父类方法抛出更多的异常，可以更少。</p>
<p>就比如父类抛的是一个RuntimeExceptipn ,子类不能抛Exception</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227154550203.png" alt="image-20240227154550203"></p>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="String类-注意-引用数据类型"><a href="#String类-注意-引用数据类型" class="headerlink" title="String类(注意:引用数据类型)"></a>String类(注意:引用数据类型)</h3><h4 id="String初识"><a href="#String初识" class="headerlink" title="String初识"></a>String初识</h4><blockquote>
<p>String类是无法继承的;</p>
<p>jdk9 之后引入了一种字符串压缩机制</p>
</blockquote>
<h5 id="Java中的String属于引用数据类型，代表字符串。"><a href="#Java中的String属于引用数据类型，代表字符串。" class="headerlink" title="Java中的String属于引用数据类型，代表字符串。"></a>Java中的String属于引用数据类型，代表字符串。</h5><h5 id="Java专门在-堆-中为字符串准备了一个-字符串常量池-。-JDK8"><a href="#Java专门在-堆-中为字符串准备了一个-字符串常量池-。-JDK8" class="headerlink" title="Java专门在&#x3D;&#x3D;堆&#x3D;&#x3D;中为字符串准备了一个&#x3D;&#x3D;字符串常量池&#x3D;&#x3D;。(JDK8)"></a>Java专门在&#x3D;&#x3D;堆&#x3D;&#x3D;中为字符串准备了一个&#x3D;&#x3D;字符串常量池&#x3D;&#x3D;。(JDK8)</h5><blockquote>
<p>因为字符串使用比较频繁，放在字符串常量池中省去了对象的创建过程，从而提高程序的执行效率。（常量池属于一种缓存技术，缓存技术是提高程序执行效率的重要手段。）</p>
</blockquote>
<p>在编译阶段,就会把” “起来的字符串全部创建到字符串常量池里面(必须要有一份),然后用的时候直接拿</p>
<p>JVM在启动的时候,会进行一系列的初始化,其中就包括字符串常量池的初始化会在类加载的过程中就初始化出来了,程序在真正运行中,是不用创建字符串对象的&#x2F;&#x2F; <em>一种缓存技术</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> “hello”; </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> “hello”;</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true 说明s1和s2指向了字符串常量池中的同一个字符串对象。</span></span><br><span class="line">注意：字符串字面量在编译的时候就已经确定了将其放到字符串常量池中。JVM启动时会立即程序中带有双引号的字符串全部放入字符串常量池。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Java8之后字符串常量池在堆中。Java8之前字符串常量池在永久代。"><a href="#Java8之后字符串常量池在堆中。Java8之前字符串常量池在永久代。" class="headerlink" title="Java8之后字符串常量池在堆中。Java8之前字符串常量池在永久代。"></a>Java8之后字符串常量池在堆中。Java8之前字符串常量池在永久代。</h5><h5 id="字符串字面量一旦创建是不可变的。（底层String源码中有一个属性：private-final-byte-value-）"><a href="#字符串字面量一旦创建是不可变的。（底层String源码中有一个属性：private-final-byte-value-）" class="headerlink" title="字符串字面量一旦创建是不可变的。（底层String源码中有一个属性：private final byte[] value;）"></a>字符串字面量一旦创建是不可变的。（底层String源码中有一个属性：private final byte[] value;）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> “hello”; 其中“hello”存储在字符串常量池中。</span><br></pre></td></tr></table></figure>

<p>“hello”不可变。不能变成“hello123”。如果进行字符串拼接，必然创建新的字符串对象。<br>是 “hello”不可变，不是s不可变，s可以指向其它的字符串对象：s &#x3D; “xyz”;</p>
<blockquote>
<p>从底层源码看,底层String源码中有一个属性：private final byte[] value;底层是个byte[]数组,数组长度不可变,所以长度不可变,</p>
<p>此外,这个数组是用private final修饰的,所以这个变量不可以被访问和继承修改</p>
<p>所以String的字面量一旦创建不可变</p>
<p>StringBuilder是可变的字符串数组,它的底层是byte[] value,所以可以改变,可以创建一个更大的数组,然后这个value就可以指向新的数组</p>
</blockquote>
<h4 id="String的拼接"><a href="#String的拼接" class="headerlink" title="String的拼接"></a>String的拼接</h4><h5 id="①动态拼接之后的新字符串不会自动放到字符串常量池中："><a href="#①动态拼接之后的新字符串不会自动放到字符串常量池中：" class="headerlink" title="①动态拼接之后的新字符串不会自动放到字符串常量池中："></a>①动态拼接之后的新字符串不会自动放到字符串常量池中：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> “abc”;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> “def”;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> “abcdef”;</span><br></pre></td></tr></table></figure>

<p><strong>&#x3D;&#x3D;5.System.out.println(s3 &#x3D;&#x3D; s4); &#x2F;&#x2F; false 说明拼接后的字符串并没有放到字符串常量池&#x3D;&#x3D;</strong></p>
<p>&#x3D;&#x3D;<strong>6.以上程序中字符串常量中有三个： “abc” “def” “abcdef”</strong>&#x3D;&#x3D; </p>
<p>&#x3D;&#x3D;<strong>7.以上程序中除了字符串常量池的字符串之外，在堆中还有一个字符串对象 “abcdef”</strong>&#x3D;&#x3D;</p>
<h5 id="②两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。"><a href="#②两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。" class="headerlink" title="②两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。"></a>②两个字符串字面量拼接会做编译阶段的优化，在编译阶段就会进行字符串的拼接。</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> “aaa” + “bbb”;</span><br></pre></td></tr></table></figure>

<p>以上程序会在编译阶段进行拼接，因此以上程序在字符串常量池中只有一个： “aaabbb”</p>
<blockquote>
<p>常量池可以改变吗?</p>
<p>可以,语句:s3.intern()</p>
<p>但是我们不能去删除常量池中的内容,系统自己有一些调整的操作</p>
<p>此时,s4和s5都在字符串常量池中</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227193208940.png" alt="image-20240227193208940"></p>
<h4 id="String类常用的构造方法有以下几种："><a href="#String类常用的构造方法有以下几种：" class="headerlink" title="String类常用的构造方法有以下几种："></a>String类常用的构造方法有以下几种：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String(<span class="type">char</span>[] value)：<span class="comment">//根据字符数组创建一个新的字符串对象。</span></span><br><span class="line">String(<span class="type">char</span>[] value, <span class="type">int</span> offset, <span class="type">int</span> count)：<span class="comment">//根据字符数组的指定部分创建一个新的字符串对象。</span></span><br><span class="line">String(<span class="type">byte</span>[] bytes)：<span class="comment">//根据字节数组创建一个新的字符串对象，默认使用平台默认的字符集进行解码。</span></span><br><span class="line">String(<span class="type">byte</span>[] bytes, <span class="type">int</span> offset, <span class="type">int</span> length)：<span class="comment">//根据字节数组的指定部分创建一个新的字符串对象，默认使用平台默认的字符集进行解码。</span></span><br><span class="line">String(<span class="type">byte</span>[] bytes, Charset charset)：</span><br><span class="line"><span class="comment">//根据字节数组和指定的字符集创建一个新的字符串对象。</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(bytes, Charset.defaultCharset());</span><br><span class="line">String(<span class="type">byte</span>[] bytes, String charsetName)：</span><br><span class="line"><span class="comment">//根据字节数组和指定的字符集名称创建一个新的字符串对象。</span></span><br><span class="line"><span class="comment">//这是一个解码的过程。你需要提前知道“byte[] bytes”是通过哪个编码方式进行编码得到的。</span></span><br><span class="line"><span class="comment">//如果通过GBK的方式进行编码得到的“byte[] bytes”，调用以上构造方法时采用UTF-8的方式进行解码。就会出现乱码。</span></span><br><span class="line">String(String original)：</span><br><span class="line"><span class="comment">//通过复制现有字符串创建一个新的字符串对象。</span></span><br><span class="line"><span class="comment">//这个方法被@IntrinsicCandidate标注，这个注解的作用是告诉编译器,该方法或构造函数是一个内在的候选方法,可以被优化和替换为更高效的代码。因此它是不建议使用的。</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(“hello”); 这个代码会让常量池中有一个 “hello”，并且在堆中也有有一个String对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[](<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars,offset=<span class="number">1</span>,count=<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">99</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">//这是一个解码的过程,也是采用的平台默认的字符集.</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bs2 = <span class="string">&quot;sssssfda&quot;</span>.getBytes(Charset.defaultCharset());</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs2,Charset.defaultCharset());</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bs2,StanderCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227195325953.png" alt="image-20240227195325953"></p>
<blockquote>
<p>这样会乱码</p>
</blockquote>
<h4 id="String的常用方法"><a href="#String的常用方法" class="headerlink" title="String的常用方法"></a>String的常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>; <span class="comment">//返回索引处的char值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>; <span class="comment">//获取字符串长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; <span class="comment">//判断字符串是否为空字符串，如果length()是0就是空字符串。//</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span>; <span class="comment">//判断两个字符串是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span>; <span class="comment">//判断两个字符串是否相等，忽略大小写。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(CharSequence s)</span>; <span class="comment">//判断当前字符串中是否包含某个子字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span>; <span class="comment">//判断当前字符串是否以某个字符串开头</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span>; <span class="comment">//判断当前字符串是否以某个字符串结尾</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span>; <span class="comment">//两个字符串按照字典顺序比较大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareToIgnoreCase</span><span class="params">(String str)</span>; <span class="comment">//两个字符串按照字典顺序比较大小，比较时忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>;<span class="comment">// 获取当前字符串中str字符串的第一次出现处的下标。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>; <span class="comment">//从当前字符串的fromIndex下标开始往右搜索，获取当前字符串中str字符串的第一次出现处的下标。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span>; <span class="comment">//获取当前字符串中str字符串的最后一次出现处的下标。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>; <span class="comment">//从当前字符串的fromIndex下标开始往左搜索，获取当前字符串中str字符串的最后一次出现处的下标。</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">stripLeading</span><span class="params">()</span>; 去除前空白</span><br><span class="line">String <span class="title function_">stripTrailing</span><span class="params">()</span>; 去除后空白</span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line">String <span class="title function_">intern</span><span class="params">()</span>; 获取字符串常量池中的字符串，如果常量池中没有，则将字符串加入常量池并返回。</span><br><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;; <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// 将字符串 “abcd”放入字符串常量池并返回常量池中的字符串 “abcd”</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">join</span><span class="params">(CharSequence d, CharSequence... elements)</span>; <span class="comment">//将多个字符串以某个分隔符连接（Java8新增）</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">join</span><span class="params">(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">boolean</span> b)</span>; <span class="comment">//以下所有的静态方法valueOf作用是将非字符串类型的数据转换为字符串形式。</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span> c)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span>[] data)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">char</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">double</span> d)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">float</span> f)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span>;</span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(Object obj)</span>;</span><br><span class="line"><span class="type">byte</span>[] getBytes(); <span class="comment">//将字符串转换成字节数组。其实就是对字符串进行编码。默认按照系统默认字符集。</span></span><br><span class="line"><span class="type">byte</span>[] getBytes(String charsetName); <span class="comment">//将字符串按照指定字符集的方式进行编码。</span></span><br><span class="line"><span class="type">byte</span>[] getBytes(Charset charset);</span><br><span class="line"><span class="type">char</span>[] toCharArray(); <span class="comment">//将字符串转换字符数组。</span></span><br><span class="line">String <span class="title function_">toLowerCase</span><span class="params">()</span>; <span class="comment">//转小写</span></span><br><span class="line">String <span class="title function_">toUpperCase</span><span class="params">()</span>; <span class="comment">//转大写</span></span><br><span class="line">String <span class="title function_">concat</span><span class="params">(String str)</span>; <span class="comment">//进行字符串的拼接操作。和 + 的区别？</span></span><br><span class="line"><span class="comment">//+ 既可以进行求和，也可以进行字符串的拼接，底层拼接时会创建StringBuilder对象进行拼接。+ 拼接null时不会出现空指针异常。</span></span><br><span class="line"><span class="comment">//concat方法参数只能时字符串类型，拼接时不会创建StringBuilder对象，拼接完成后返回一个新的String对象。拼接null会出现空指针异常。</span></span><br><span class="line"><span class="comment">//+ 使用较多。如果进行大量字符串拼接，这两个都不合适。</span></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>; <span class="comment">//从指定下标beginIndex开始截取子字符串</span></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span>;</span><br><span class="line">String <span class="title function_">trim</span><span class="params">()</span>; <span class="comment">//去除字符串前后空白（只能去除ASCII码中的空格和制表符）</span></span><br><span class="line">String <span class="title function_">strip</span><span class="params">()</span>; <span class="comment">//去除字符串前后空白（支持所有的编码形式的空白，可以将全角空格去除，\u3000是全角空格，Java11新增）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227202458188.png" alt="image-20240227202458188"></p>
<p>前&gt;后;负</p>
<p>前&lt;后;正</p>
<p>相等;0</p>
<blockquote>
<p>右键 show Diagram</p>
</blockquote>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>①正则表达式（regular expression），简称为regex或regexp，是一种用于描述特定模式的表达式。它可以匹配、查找、替换文本中与该模式匹配的内容，被广泛应用于各种文本处理和匹配相关的应用中。</p>
<p>②正则表达式的应用:</p>
<blockquote>
<p>1.验证输入内容的格式是否正确。例如，邮箱，手机号，密码等</p>
<p>2.在文本编辑器中进行搜索和替换。例如，在代码编辑器中查找指定字符串或替换错误的代码成为正确的代码块</p>
<p>3.数据挖掘和信息提取。正则表达式可以从HTML、XML、JSON等格式的数据中提取所需的信息</p>
<p>4.用于编写脚本语言，如awk，grep和sed</p>
<p>5.服务器端编程。正则表达式在处理数据和字符串时具有高效的性能，可以在开发Web应用程序时被广泛应用</p>
</blockquote>
<p>③正则表达式和Java语言的关系？</p>
<p>Java语言中可以使用正则表达式。C语言以及其它大部分编程语言都是支持正则表达式的。</p>
<h4 id="String的正则表达式相关的方法："><a href="#String的正则表达式相关的方法：" class="headerlink" title="&#x3D;&#x3D;String的正则表达式相关的方法：&#x3D;&#x3D;"></a>&#x3D;&#x3D;String的正则表达式相关的方法：&#x3D;&#x3D;</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前字符串中所有的target替换成replacement，返回一个新的字符串。</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前字符串中所有符合正则表达式的regex替换成replacement。</span></span><br><span class="line"></span><br><span class="line">String[] split(String regex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前字符串以某个正则表达式表示的子字符串进行分割，返回一个字符串数组。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前字符串是否符合正则表达式regex。</span></span><br></pre></td></tr></table></figure>

<h4 id="String的面试题"><a href="#String的面试题" class="headerlink" title="String的面试题"></a>String的面试题</h4><h5 id="1-1"><a href="#1-1" class="headerlink" title="1."></a>1.</h5><img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204034015.png" alt="image-20240227204034015" style="zoom:150%;" />

<blockquote>
<p>false;</p>
<p>true</p>
</blockquote>
<h5 id="2-1"><a href="#2-1" class="headerlink" title="2."></a>2.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204118497.png" alt="image-20240227204118497"></h5><blockquote>
<p>true;因为这种拼接会在编译阶段完成，编译器优化策略</p>
<p>true</p>
</blockquote>
<h5 id="3-1"><a href="#3-1" class="headerlink" title="3."></a>3.<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204222677.png" alt="image-20240227204222677" style="zoom:200%;" /></h5><blockquote>
<p>false:yin_yang:这个和上面那个不一样，上面那个是字面量相加，是可以在编译阶段实现，这个是变量，不在编译阶段实现，是存放在堆里的字符串变量；</p>
<p>如果s3.intern（），那就是一样了</p>
<p>true</p>
</blockquote>
<h5 id="4-1"><a href="#4-1" class="headerlink" title="4."></a>4.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204622761.png" alt="image-20240227204622761"></h5><blockquote>
<p>3个对象，a一个b一个，s一个，放在字符串常量区里</p>
</blockquote>
<h5 id="5-1"><a href="#5-1" class="headerlink" title="5."></a>5.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227204749867.png" alt="image-20240227204749867"></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串常量池中一个&quot;a&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串常量池中一个&quot;b&quot;,堆中一个s2</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s3--&gt;堆中两个，一个StringBuilder(在拼接的时候自动创建的)，一个string(StringBuilder调用toString转换的)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1+s2</span><br></pre></td></tr></table></figure>

<h5 id="6-1"><a href="#6-1" class="headerlink" title="6."></a>6.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227210701818.png" alt="image-20240227210701818"></h5><blockquote>
<p>字符串常量区：“a”,”b”</p>
<p>堆：new的a一个，new的b一个，拼接生成的StringBuilder一个，调用toString生成的一个String一个</p>
<p>一共6个对象</p>
</blockquote>
<h5 id="7"><a href="#7" class="headerlink" title="7."></a>7.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227210824500.png" alt="image-20240227210824500"></h5><blockquote>
<p>答案：不会出现异常，底层会默认调用valueOf，将非字符串类型的数据转换为字符串形式。结果null</p>
</blockquote>
<h5 id="8"><a href="#8" class="headerlink" title="8."></a>8.<img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227211247488.png" alt="image-20240227211247488"></h5><blockquote>
<p>没有final的话，false，s3不在字符串常量池里</p>
<p>&#x2F;&#x2F;&#x2F;*********************</p>
<p>true</p>
<p>final修饰后，s2不可变，就是个常量，所以这个拼接是在编译时候完成的，没有创建StringBuilder对象</p>
<p>所以是true</p>
</blockquote>
<h5 id="9"><a href="#9" class="headerlink" title="9."></a>9.<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227211841286.png" alt="image-20240227211841286" style="zoom: 67%;" /></h5><blockquote>
<p>false;</p>
<p>因为getB()是一个方法，只能在运行阶段，不能在编译阶段，所以虽然s2是个常量，但是他不在字符串常量区，在堆里面。</p>
<p>所以s3这个拼接操作也是在运行时候执行的，地址不一样，所以是false</p>
</blockquote>
<h5 id="10"><a href="#10" class="headerlink" title="10."></a>10.<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227212157813.png" alt="image-20240227212157813" style="zoom:67%;" /></h5><blockquote>
<p>false</p>
<p>equals 的前提，两种类型要一样，这俩类型不一样</p>
</blockquote>
<h3 id="StringBuffer与StringBuilder"><a href="#StringBuffer与StringBuilder" class="headerlink" title="StringBuffer与StringBuilder"></a>StringBuffer与StringBuilder</h3><h4 id="StringBuffer和StringBuilder：可变长度字符串"><a href="#StringBuffer和StringBuilder：可变长度字符串" class="headerlink" title="StringBuffer和StringBuilder：可变长度字符串"></a>StringBuffer和StringBuilder：可变长度字符串</h4><img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227220453859.png" alt="image-20240227220453859" style="zoom: 25%;" />

<ul>
<li><p><strong>使用情况：这两个类是专门为频繁进行字符串拼接而准备</strong>。</p>
</li>
<li><p><strong>二者差别：</strong>StringBuffer先出现的，Java5的时候新增了StringBuilder。StringBuffer是线程安全的。在不需要考虑线程安全问题的情况下优先选择StringBuilder，效率较高一些。</p>
</li>
<li><p><strong>底层:</strong>       	是 byte[] 数组，并且这个 byte[] 数组没有被final修饰，这说明如果byte[]数组满了，可以创建一个更大的新数组来达到扩容，然后它可以重新指向这个新的数组对象。</p>
</li>
<li><p><strong>优化策略：</strong>&#x3D;&#x3D;创建StringBuilder对象时，预估计字符串的长度，给定一个合适的初始化容量，减少底层数组的扩容。&#x3D;&#x3D;</p>
</li>
<li><p>StringBuilder默认初始化容量：16</p>
</li>
<li><p>StringBuilder一次扩容多少？可以通过Debug跟踪一下append方法。扩容策略是：从当前容量开始，**&#x3D;&#x3D;每次扩容为原来的2倍再加上2&#x3D;&#x3D;**</p>
</li>
</ul>
<blockquote>
<p>原来是i，扩容后就是2i+2，如果是默认的，就开始2*16+2 ，然后2*（2+16）+2</p>
<p>如果拼接的字符串很大，大于了预期增长值，就会增大到拼接的字符串长度</p>
<p>假如是初始化len:50的字符串：</p>
<p>l16+minCapacity(34)&#x3D;&#x3D;50</p>
<p>34&gt;16+2,所以扩容大小为34</p>
</blockquote>
<p>count 目前真实的存储数量</p>
<h4 id="StringBuffer和StringBuilder构造方法"><a href="#StringBuffer和StringBuilder构造方法" class="headerlink" title="StringBuffer和StringBuilder构造方法"></a>StringBuffer和StringBuilder构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder() <span class="comment">//构造一个字符串生成器，其中不包含任何字符，初始容量为16个字符。</span></span><br><span class="line"></span><br><span class="line">StringBuilder(<span class="type">int</span> capacity) <span class="comment">//构造一个字符串生成器，其中不包含任何字符，并且具有由容量参数指定的初始容量。</span></span><br><span class="line"></span><br><span class="line">StringBuilder(String str)<span class="comment">// 构造初始化为指定字符串内容的字符串生成器</span></span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240227222910252.png" alt="image-20240227222910252"></p>
<h4 id="StringBuffer和StringBuilder常用方法"><a href="#StringBuffer和StringBuilder常用方法" class="headerlink" title="StringBuffer和StringBuilder常用方法"></a>StringBuffer和StringBuilder常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder <span class="title function_">append</span><span class="params">(Type data)</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder <span class="title function_">deleteCharAt</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, String str)</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder <span class="title function_">replace</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, String str)</span></span><br><span class="line"></span><br><span class="line">StringBuilder <span class="title function_">reverse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> index, <span class="type">char</span> ch)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">int</span> newLength)</span>;<span class="comment">//会把已有的数据抹掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start)</span>;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line"></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>long begin &#x3D; System.current.TimeMills();</p>
<p>从1970年1月1日 0时0分0秒开始 的总毫秒数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下这种写法尽量避免，效率太低：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> “”;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">    <span class="comment">// 优化策略：底层会新建一个StringBuilder对象</span></span><br><span class="line">    <span class="comment">// 然后调用StringBuilder的append(i)方法进行追加</span></span><br><span class="line">    <span class="comment">// 然后再调用StringBuilder toString()方法转成String类型</span></span><br><span class="line">    <span class="comment">// 也就是说：这里会频繁的创建String对象，导致效率很低</span></span><br><span class="line">    <span class="comment">// 同时给GC带来巨大压力。</span></span><br><span class="line">    s += i;</span><br><span class="line">&#125;</span><br><span class="line">因此建议使用下面的方式，只创建一个StringBuilder对象</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228101346290.png" alt="image-20240228101346290"></p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="什么是包装类？有什么用？"><a href="#什么是包装类？有什么用？" class="headerlink" title="什么是包装类？有什么用？"></a>什么是包装类？有什么用？</h4><blockquote>
<p>我的理解，将基础类型进行包装，形成一个引用类型，方便编程</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228101801236.png" alt="image-20240228101801236"></p>
<p>比如在一个函数中，其接受的参数是引用类型(Object)，实际应用起来是对于数字操作的，直接传进去数字是不行的，是会报错的，所以我们把这个int的10，包装成引用类型的10.</p>
<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228102517804.png" alt="image-20240228102517804" style="zoom: 33%;" />

<h4 id="包装类中的6个数字类型都继承了Number类"><a href="#包装类中的6个数字类型都继承了Number类" class="headerlink" title="包装类中的6个数字类型都继承了Number类"></a>包装类中的6个数字类型都继承了Number类</h4><blockquote>
<p>boolean 和character没有继承</p>
</blockquote>
<p>①Byte、Short、Integer、Long、Float、Double都继承了Number类，因此这些类中都有以下这些方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">byteValue()</span><br><span class="line">shortValue()</span><br><span class="line">intValue()</span><br><span class="line">longValue()</span><br><span class="line">floatValue()</span><br><span class="line">doubleValue()</span><br></pre></td></tr></table></figure>

<p><strong>&#x3D;&#x3D;这些方法的作用就是将包装类型的数据转换为基本数据类型。&#x3D;&#x3D;</strong></p>
<p>包装类转换成基本数据类型的过程我们称为：&#x3D;&#x3D;<strong>拆箱</strong> <strong>unboxing</strong>&#x3D;&#x3D;</p>
<p><strong>Boolean的拆箱方法：booleanValue();</strong></p>
<p><strong>Character的拆箱方法：charValue();</strong></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228102834512.png" alt="image-20240228102834512"></p>
<h4 id="Integer的常量（为例子）"><a href="#Integer的常量（为例子）" class="headerlink" title="Integer的常量（为例子）"></a>Integer的常量（为例子）</h4><p>①通过Integer提供的常量可以获取int的最大值和最小值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①最大值：Integer.MAX_VALUE</span><br><span class="line"></span><br><span class="line">②最小值：Integer.MIN_VALUE</span><br></pre></td></tr></table></figure>

<p>②当然，其它5个数字包装类也有对应的常量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①byte最大值：Byte.MAX_VALUE</span><br><span class="line"></span><br><span class="line">②byte最小值：Byte.MIN_VALUE</span><br><span class="line"></span><br><span class="line">③short最大值：Short.MAX_VALUE</span><br><span class="line"></span><br><span class="line">④short最小值：Short.MIN_VALUE</span><br><span class="line"></span><br><span class="line">⑤......</span><br></pre></td></tr></table></figure>

<h4 id="Integer的构造方法"><a href="#Integer的构造方法" class="headerlink" title="Integer的构造方法"></a>Integer的构造方法</h4><h5 id="①Integer-int-value"><a href="#①Integer-int-value" class="headerlink" title="①Integer(int value)"></a>①Integer(int value)</h5><p>1.Java9之后标记已过时，不建议使用。</p>
<p>2.该构造方法可以将基本数据类型转换成包装类。这个过程我们称为<strong>装箱boxing</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"> <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;100&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(s);</span><br></pre></td></tr></table></figure>



<h5 id="②Integer-String-s"><a href="#②Integer-String-s" class="headerlink" title="②Integer(String s)"></a>②Integer(String s)</h5><p>1.Java9之后标记已过时，不建议使用。</p>
<p>2.该构造方法可以将字符串数字转换成包装类。但字符串必须是整数数字，如果不是会出现异常：<strong>NumberFormatException</strong></p>
<h4 id="Integer的常用方法"><a href="#Integer的常用方法" class="headerlink" title="Integer的常用方法"></a>Integer的常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>; <span class="comment">//比较大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">//最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">//最小值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s)</span>; <span class="comment">//将字符串数字转换成数字类型。其它包装类也有这个方法：</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    Double.parseDouble(String s)**</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toBinaryString</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">//获取数字二进制的字符串表示形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toHexString</span><span class="params">(<span class="type">int</span> i)</span>;<span class="comment">// 获取数字十六进制的字符串表示形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toOctalString</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">//获取数字八进制的字符串表示形式</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Integer anotherInteger)</span>; <span class="comment">//比较大小，可见实现了Comparable接口</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>; <span class="comment">//包装类已经重写了equals()方法。</span></span><br><span class="line"></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>; <span class="comment">//包装类已经重写了toString()方法。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span>; <span class="comment">//将包装类拆箱为基本数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">//将基本数据类型转换成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>; <span class="comment">//将基本数据类型转换成Integer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(String s)</span> /将字符串转换成Integer（这个字符串必须是数字字符串才行，不然出现NumberFormatException）</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228111527964.png" alt="image-20240228111527964"></p>
<h4 id="Java5新特性：自动装箱和自动拆箱"><a href="#Java5新特性：自动装箱和自动拆箱" class="headerlink" title="Java5新特性：自动装箱和自动拆箱"></a>Java5新特性：自动装箱和自动拆箱</h4><blockquote>
<p>编译阶段的功能</p>
</blockquote>
<p>①Java5之后为了开发方便，引入了新特性：自动拆箱和自动装箱。</p>
<p>②自动装箱：auto boxing</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<p>③自动拆箱：auto unboxing</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"></span><br><span class="line">System.out.println(a + <span class="number">1</span>); 这里的a也会做自动拆箱。</span><br></pre></td></tr></table></figure>

<p>⑤注意空指针异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码出现空指针异常的原因是a在进行自动拆箱时，会调用 a.intValue()方法。</p>
<p>因为a是null，访问实例方法会出现空指针异常，因此使用时应注意。<br><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228111945428.png" alt="image-20240228111945428"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228112019609.png" alt="image-20240228112019609"></p>
<h4 id="整数型常量池"><a href="#整数型常量池" class="headerlink" title="整数型常量池"></a>整数型常量池</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228112206054.png" alt="image-20240228112206054"></p>
<p>①**&#x3D;&#x3D;[-128 ~ 127] Java为这个区间的Integer对象创建了整数型常量池。&#x3D;&#x3D;**</p>
<p>②也就是说如果整数没有超出范围的话，直接从整数型常量池获取Integer对象。</p>
<p>③以下是一个面试题：请说出它的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer x = 128;</span><br><span class="line"></span><br><span class="line">Integer y = 128;</span><br><span class="line"></span><br><span class="line">System.out.println(x == y); // false</span><br><span class="line"></span><br><span class="line">Integer a = 127;</span><br><span class="line"></span><br><span class="line">Integer b = 127;</span><br><span class="line"></span><br><span class="line">System.out.println(a == b); // true</span><br></pre></td></tr></table></figure>

<h3 id="大数字"><a href="#大数字" class="headerlink" title="大数字"></a>大数字</h3><blockquote>
<p>如果整数超过long的最大值怎么办？</p>
<p>这个是引用数据类型</p>
</blockquote>
<h4 id="①java中提供了一种引用数据类型来解决这个问题：-java-math-BigInteger-。它的父类是-Number。"><a href="#①java中提供了一种引用数据类型来解决这个问题：-java-math-BigInteger-。它的父类是-Number。" class="headerlink" title="①java中提供了一种引用数据类型来解决这个问题：**&#x3D;&#x3D;java.math.BigInteger&#x3D;&#x3D;。它的父类是&#x3D;&#x3D;Number。&#x3D;&#x3D;**"></a>①java中提供了一种引用数据类型来解决这个问题：**&#x3D;&#x3D;java.math.BigInteger&#x3D;&#x3D;<strong>。它的父类是</strong>&#x3D;&#x3D;Number。&#x3D;&#x3D;**</h4><h4 id="②常用构造方法：BigInteger-String-val"><a href="#②常用构造方法：BigInteger-String-val" class="headerlink" title="②常用构造方法：BigInteger(String val)"></a>②常用构造方法：BigInteger(String val)</h4><h4 id="③常用方法："><a href="#③常用方法：" class="headerlink" title="③常用方法："></a>③常用方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger <span class="title function_">add</span><span class="params">(BigInteger val)</span>; 求和</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">subtract</span><span class="params">(BigInteger val)</span>; 相减</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">multiply</span><span class="params">(BigInteger val)</span>; 乘积</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">divide</span><span class="params">(BigInteger val)</span>; 商</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(BigInteger val)</span>; 比较</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">abs</span><span class="params">()</span>; 绝对值</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">max</span><span class="params">(BigInteger val)</span>; 最大值</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">min</span><span class="params">(BigInteger val)</span>; 最小值</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">pow</span><span class="params">(<span class="type">int</span> exponent)</span>; 次幂</span><br><span class="line"></span><br><span class="line">BigInteger <span class="title function_">sqrt</span><span class="params">()</span>; 平方根</span><br></pre></td></tr></table></figure>

<h4 id="如果浮点型数据超过double的最大值怎么办？"><a href="#如果浮点型数据超过double的最大值怎么办？" class="headerlink" title="如果浮点型数据超过double的最大值怎么办？"></a>如果浮点型数据超过double的最大值怎么办？</h4><p>①java中提供了一种引用数据类型来解决这个问题**&#x3D;&#x3D;：java.math.BigDecimal&#x3D;&#x3D;<strong>（</strong>经常用在财务软件中<strong>）。它的父类是</strong>&#x3D;&#x3D;Number。&#x3D;&#x3D;**</p>
<p>②构造方法：**&#x3D;&#x3D;BigDecimal(String val)&#x3D;&#x3D;**</p>
<p>③常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal augend)</span>; 求和</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal subtrahend)</span>; 相减</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal multiplicand)</span>; 乘积</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor)</span>; 商</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">max</span><span class="params">(BigDecimal val)</span>; 最大值</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">min</span><span class="params">(BigDecimal val)</span>; 最小值</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">movePointLeft</span><span class="params">(<span class="type">int</span> n)</span>; 向左移动小数点</span><br><span class="line"></span><br><span class="line">BigDecimal <span class="title function_">movePointRight</span><span class="params">(<span class="type">int</span> n)</span>; 向右移动小数点</span><br></pre></td></tr></table></figure>

<h4 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h4><p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228113359145.png" alt="image-20240228113359145"></p>
<h3 id="日期处理"><a href="#日期处理" class="headerlink" title="日期处理"></a>日期处理</h3><h4 id="日期相关API"><a href="#日期相关API" class="headerlink" title="日期相关API"></a>日期相关API</h4><p>①**&#x3D;&#x3D;long l &#x3D; System.currentTimeMillis();&#x3D;&#x3D;** &#x2F;&#x2F; 获取自1970年1月1日0时0分0秒到系统当前时间的总毫秒数。</p>
<p>②java.util.Date 日期类</p>
<p>​		①构造方法：Date()</p>
<p>​		②构造方法：Date(long 毫秒)</p>
<p>③java.util.SimpleDateFormat 日期格式化类</p>
<p>​		①日期转换成字符串（java.util.Date -&gt; java.lang.String）</p>
<p>​		②字符串转换成日期（java.lang.String -&gt; java.util.Date）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Date ---》string  format</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sdf.format(now);</span><br><span class="line"></span><br><span class="line"><span class="comment">//string--》Date parse</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> <span class="string">&quot;2008-08-08 08:08:08 888&quot;</span>;<span class="comment">//字符串格式和下面这个format格式要对上，不然就会报解析异常</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf2.parse(strDate)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取指定的时间，单位为毫秒级别</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span>);</span><br><span class="line">System.out.println(date1);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//获取当前系统的前十分钟</span></span><br><span class="line"><span class="type">Date</span>  <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</span><br><span class="line">System.out.println(date2);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>④java.util.Calendar 日历类</p>
<p>​		①获取当前时间的日历对象：Calendar c &#x3D; Calendar.getInstance();</p>
<p>​		②获取日历中的某部分：int year &#x3D; c.get(Calendar.YEAR);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar.YEAR <span class="comment">//获取年份 Calendar.MONTH 获取月份，0表示1月，1表示2月，...，11表示12月</span></span><br><span class="line"></span><br><span class="line">Calendar.DAY_OF_MONTH <span class="comment">//获取本月的第几天 Calendar.DAY_OF_YEAR 获取本年的第几天</span></span><br><span class="line"></span><br><span class="line">Calendar.HOUR_OF_DAY <span class="comment">//小时，24小时制 Calendar.HOUR 小时，12小时制</span></span><br><span class="line"></span><br><span class="line">Calendar.MINUTE <span class="comment">//获取分钟 Calendar.SECOND 获取秒</span></span><br><span class="line"></span><br><span class="line">Calendar.MILLISECOND <span class="comment">//获取毫秒 Calendar.DAY_OF_WEEK 获取星期几，1表示星期日，...，7表示星期六</span></span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228130311011.png" alt="image-20240228130311011"></p>
<h5 id="①java-util-Calendar-日历类"><a href="#①java-util-Calendar-日历类" class="headerlink" title="①java.util.Calendar 日历类"></a>①java.util.Calendar 日历类</h5><p>​	1.日历的set方法：设置日历</p>
<blockquote>
<p>静态变量</p>
</blockquote>
<p>​			1.calendar.set(Calendar.YEAR, 2023); </p>
<p>​			2.calendar.set(2008, Calendar.SEPTEMBER,8);</p>
<p>​	2.日历的add方法（日历中各个部分的加减）：</p>
<p>​			1.calendar.add(Calendar.YEAR, 1);</p>
<p>​	3.日历对象的setTime()让日历关联具体的时间</p>
<p>​			1.calendar.setTime(new Date());</p>
<p>​	4.日历对象的getTime()方法获取日历的具体时间：</p>
<p>​			1.Date time &#x3D; calendar.getTime();</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228131052018.png" alt="image-20240228131052018"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calendar</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> <span class="string">&quot;2008-05-12 15:30:30&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(strDate);</span><br><span class="line">cal.setTime(date);</span><br><span class="line">System.out.println(cal.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">System.out.println(cal.get(Calendar.MINUTE));</span><br></pre></td></tr></table></figure>

<h3 id="Java8的新日期API"><a href="#Java8的新日期API" class="headerlink" title="Java8的新日期API"></a>Java8的新日期API</h3><blockquote>
<p>传统的日期API存在线程问题</p>
<p>新的API在java.time包</p>
</blockquote>
<h4 id="传统的日期API存在线程安全问题，Java8又提供了一套全新的日期API"><a href="#传统的日期API存在线程安全问题，Java8又提供了一套全新的日期API" class="headerlink" title="传统的日期API存在线程安全问题，Java8又提供了一套全新的日期API"></a>传统的日期API存在线程安全问题，Java8又提供了一套全新的日期API</h4><ul>
<li>①java.time.LocalDate、java.time.LocalTime、java.time.LocalDateTime 日期、时间、日期时间</li>
<li>②java.time.Instant 时间戳信息197001010000到现在的时间毫秒</li>
<li>③java.time.Duration 计算两个<strong>时间对象</strong>之间的时间间隔，精度为纳秒</li>
<li>④java.time.Period 计算两个日期之间的时间间隔，以年、月、日为单位。</li>
<li>⑤java.time.temporal.<strong>TemporalAdjusters</strong> 提供了一些方法用于方便的进行日期时间调整</li>
<li>⑥java.time.format.DateTimeFormatter 用于进行日期时间格式化和解析</li>
</ul>
<h4 id="LocalDate日期、LocalTime时间、LocalDateTime日期时间"><a href="#LocalDate日期、LocalTime时间、LocalDateTime日期时间" class="headerlink" title="LocalDate日期、LocalTime时间、LocalDateTime日期时间"></a>LocalDate日期、LocalTime时间、LocalDateTime日期时间</h4><h5 id="①获取当前时间（精确到纳秒，1秒-1000毫秒，1毫秒-1000微秒，1微秒-1000纳秒）"><a href="#①获取当前时间（精确到纳秒，1秒-1000毫秒，1毫秒-1000微秒，1微秒-1000纳秒）" class="headerlink" title="①获取当前时间（精确到纳秒，1秒&#x3D;1000毫秒，1毫秒&#x3D;1000微秒，1微秒&#x3D;1000纳秒）"></a>①获取当前时间（精确到纳秒，1秒&#x3D;1000毫秒，1毫秒&#x3D;1000微秒，1微秒&#x3D;1000纳秒）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now(); </span><br></pre></td></tr></table></figure>

<h5 id="②获取指定日期时间"><a href="#②获取指定日期时间" class="headerlink" title="②获取指定日期时间"></a>②获取指定日期时间</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2008</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>); <span class="comment">// 获取指定的日期时间</span></span><br></pre></td></tr></table></figure>

<h5 id="③加日期和加时间"><a href="#③加日期和加时间" class="headerlink" title="③加日期和加时间"></a>③加日期和加时间</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> ldt.plusYears(<span class="number">1</span>).plusMonths(<span class="number">1</span>).plusDays(<span class="number">1</span>).plusHours(<span class="number">1</span>).plusMinutes(<span class="number">1</span>).plusSeconds(<span class="number">1</span>).plusNanos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="④减日期和减时间"><a href="#④减日期和减时间" class="headerlink" title="④减日期和减时间"></a>④减日期和减时间</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> ldt.minusYears(<span class="number">1</span>).minusMonths(<span class="number">1</span>).minusDays(<span class="number">1</span>).minusHours(<span class="number">1</span>).minusMinutes(<span class="number">1</span>).minusSeconds(<span class="number">1</span>).minusNanos(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h5 id="⑤获取年月日时分秒"><a href="#⑤获取年月日时分秒" class="headerlink" title="⑤获取年月日时分秒"></a>⑤获取年月日时分秒</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> now.getYear(); <span class="comment">// 年 int month = now.getMonth().getValue(); // 月</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> now.getDayOfMonth(); <span class="comment">// 一个月的第几天 int dayOfWeek = now.getDayOfWeek().getValue(); // 一个周第几天</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfYear</span> <span class="operator">=</span> now.getDayOfYear(); <span class="comment">// 一年的第几天 int hour = now.getHour(); // 时</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> now.getMinute(); <span class="comment">// 分 int second = now.getSecond(); // 秒</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> now.getNano(); <span class="comment">// 纳秒</span></span><br></pre></td></tr></table></figure>

<h4 id="Instant-时间戳（获取1970年1月1日-0时0分0秒到某个时间的时间戳）"><a href="#Instant-时间戳（获取1970年1月1日-0时0分0秒到某个时间的时间戳）" class="headerlink" title="&#x3D;&#x3D;Instant 时间戳（获取1970年1月1日 0时0分0秒到某个时间的时间戳）&#x3D;&#x3D;"></a>&#x3D;&#x3D;Instant 时间戳（获取1970年1月1日 0时0分0秒到某个时间的时间戳）&#x3D;&#x3D;</h4><h5 id="①获取系统当前时间（UTC：全球标准时间）"><a href="#①获取系统当前时间（UTC：全球标准时间）" class="headerlink" title="①获取系统当前时间（UTC：全球标准时间）"></a>①获取系统当前时间（UTC：全球标准时间）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now(); </span><br></pre></td></tr></table></figure>

<h5 id="②获取时间戳"><a href="#②获取时间戳" class="headerlink" title="②获取时间戳"></a>②获取时间戳</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">epochMilli</span> <span class="operator">=</span> instant.toEpochMilli(); </span><br></pre></td></tr></table></figure>

<h4 id="Duration-计算时间间隔"><a href="#Duration-计算时间间隔" class="headerlink" title="Duration 计算时间间隔"></a>Duration 计算时间间隔</h4><h5 id="①计算两个时间相差时间间隔Duration-between-now1-now2"><a href="#①计算两个时间相差时间间隔Duration-between-now1-now2" class="headerlink" title="①计算两个时间相差时间间隔Duration.between(now1, now2);"></a>①计算两个时间相差时间间隔Duration.between(now1, now2);</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2008</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> <span class="type">LocalDateTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2009</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"> <span class="type">Duration</span> <span class="variable">between</span> <span class="operator">=</span> Duration.between(now1, now2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个时间差多少个小时</span></span><br><span class="line"></span><br><span class="line">System.out.println(between.toHours());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 两个时间差多少天</span></span><br><span class="line"></span><br><span class="line">System.out.println(between.toDays());</span><br></pre></td></tr></table></figure>

<h4 id="Period-计算日期间隔"><a href="#Period-计算日期间隔" class="headerlink" title="Period 计算日期间隔"></a>Period 计算日期间隔</h4><h5 id="①计算两个日期间隔Period-between-now1-now2"><a href="#①计算两个日期间隔Period-between-now1-now2" class="headerlink" title="①计算两个日期间隔Period.between(now1, now2);"></a>①计算两个日期间隔Period.between(now1, now2);</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="type">LocalDate</span> <span class="variable">now1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2007</span>,<span class="number">7</span>,<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="type">LocalDate</span> <span class="variable">now2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2008</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="type">Period</span> <span class="variable">between</span> <span class="operator">=</span> Period.between(now1, now2);</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 相差年数</span></span><br><span class="line"></span><br><span class="line">​    System.out.println(between.getYears());</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 相差月数</span></span><br><span class="line"></span><br><span class="line">​    System.out.println(between.getMonths());</span><br><span class="line"></span><br><span class="line">​    <span class="comment">// 相差天数</span></span><br><span class="line"></span><br><span class="line">​    System.out.println(between.getDays());</span><br></pre></td></tr></table></figure>

<h4 id="TemporalAdjusters-时间矫正器"><a href="#TemporalAdjusters-时间矫正器" class="headerlink" title="TemporalAdjusters  时间矫正器"></a>TemporalAdjusters  时间矫正器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">①<span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">// 获取系统当前时间</span></span><br><span class="line"></span><br><span class="line">②now.with(TemporalAdjusters.firstDayOfMonth()); <span class="comment">// 当前月的第一天</span></span><br><span class="line"></span><br><span class="line">③now.with(TemporalAdjusters.firstDayOfNextYear()); <span class="comment">// 下一年的第一天</span></span><br><span class="line"></span><br><span class="line">④now.with(TemporalAdjusters.lastDayOfYear()); <span class="comment">// 本年最后一天</span></span><br><span class="line"></span><br><span class="line">⑤now.with(TemporalAdjusters.lastDayOfMonth()); <span class="comment">// 本月最后一天</span></span><br><span class="line"></span><br><span class="line">⑥now.with(TemporalAdjusters.next(DayOfWeek.MONDAY)); <span class="comment">// 下周一</span></span><br><span class="line"></span><br><span class="line">⑦......</span><br></pre></td></tr></table></figure>

<h4 id="DateTimeFormatter-日期格式化"><a href="#DateTimeFormatter-日期格式化" class="headerlink" title="DateTimeFormatter 日期格式化"></a>DateTimeFormatter 日期格式化</h4><h5 id="①日期格式化-（LocalDateTime-–-String）"><a href="#①日期格式化-（LocalDateTime-–-String）" class="headerlink" title="①日期格式化 （LocalDateTime –&gt; String）"></a>①日期格式化 （LocalDateTime –&gt; String）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dtf.format(now);</span><br></pre></td></tr></table></figure>

<h5 id="②将字符串转换成日期（String-–-LocalDateTime）"><a href="#②将字符串转换成日期（String-–-LocalDateTime）" class="headerlink" title="②将字符串转换成日期（String –&gt; LocalDateTime）"></a>②将字符串转换成日期（String –&gt; LocalDateTime）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2008-08-08 08:08:08&quot;</span>, dtf);</span><br><span class="line"></span><br><span class="line">System.out.println(localDateTime);</span><br></pre></td></tr></table></figure>



<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><blockquote>
<p>java.lang.Math 数学工具类，都是**&#x3D;&#x3D;静态方法&#x3D;&#x3D;**</p>
</blockquote>
<h5 id="①常用属性：static-final-double-PI（圆周率）"><a href="#①常用属性：static-final-double-PI（圆周率）" class="headerlink" title="①常用属性：static final double PI（圆周率）"></a>①常用属性：static final double PI（圆周率）</h5><h5 id="②常用方法："><a href="#②常用方法：" class="headerlink" title="②常用方法："></a>②常用方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> a)</span>; <span class="comment">//绝对值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//向上取整</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//向下取整</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">//最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;<span class="comment">// 最小值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">random</span><span class="params">()</span>; <span class="comment">//随机数[0.0, 1.0)   int num = (int)(Math.random() * 100);可以获取[0-100)的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//四舍五入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">//平方根</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>;  <span class="comment">//a的b次幂</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><blockquote>
<p>枚举（Java5新特性）</p>
</blockquote>
<h4 id="①枚举类型在Java中是一种-引用数据类型。"><a href="#①枚举类型在Java中是一种-引用数据类型。" class="headerlink" title="①枚举类型在Java中是一种&#x3D;&#x3D;引用数据类型。&#x3D;&#x3D;"></a>①枚举类型在Java中是一种&#x3D;&#x3D;引用数据类型。&#x3D;&#x3D;</h4><h4 id="②合理使用枚举类型可以让代码更加清晰、可读性更高，可以有效地避免一些常见的错误。"><a href="#②合理使用枚举类型可以让代码更加清晰、可读性更高，可以有效地避免一些常见的错误。" class="headerlink" title="②合理使用枚举类型可以让代码更加清晰、可读性更高，可以有效地避免一些常见的错误。"></a>②合理使用枚举类型可以让代码更加清晰、可读性更高，可以有效地避免一些常见的错误。</h4><h4 id="③什么情况下考虑使用枚举类型？"><a href="#③什么情况下考虑使用枚举类型？" class="headerlink" title="③什么情况下考虑使用枚举类型？"></a>③什么情况下考虑使用枚举类型？</h4><p>​	1.这个数据是有限的，并且可以一枚一枚列举出来的。</p>
<p>​	2.枚举类型是类型安全的，它可以有效地防止使用错误的类型进行赋值。</p>
<h4 id="④枚举如何定义？以下是最基本的格式："><a href="#④枚举如何定义？以下是最基本的格式：" class="headerlink" title="④枚举如何定义？以下是最基本的格式："></a>④枚举如何定义？以下是最基本的格式：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举类型名 &#123;</span><br><span class="line"></span><br><span class="line">  枚举值<span class="number">1</span>, 枚举值<span class="number">2</span>, 枚举值<span class="number">3</span>, 枚举值<span class="number">4</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="⑤通过反编译-javap-可以看到："><a href="#⑤通过反编译-javap-可以看到：" class="headerlink" title="⑤通过反编译(javap)可以看到："></a>⑤通过反编译(javap)可以看到：</h4><p>1.所有枚举类型默认继承<strong>java.lang.Enum</strong>,因此枚举类型无法继承其他类。</p>
<p><strong>2.所有的枚举类型都被final修饰，所以枚举类型是无法继承的</strong></p>
<p><strong>3.所有的枚举值都是常量</strong></p>
<p>4.所有的枚举类型中都有一个values数组（可以通过values()获取所有枚举值并遍历）</p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228134745351.png" alt="image-20240228134745351"></p>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228134809247.png" alt="image-20240228134809247"></p>
<h4 id="枚举的高级用法"><a href="#枚举的高级用法" class="headerlink" title="枚举的高级用法"></a>枚举的高级用法</h4><h5 id="①普通类中可以编写的元素，枚举类型中也可以编写。"><a href="#①普通类中可以编写的元素，枚举类型中也可以编写。" class="headerlink" title="①普通类中可以编写的元素，枚举类型中也可以编写。"></a>①普通类中可以编写的元素，枚举类型中也可以编写。</h5><blockquote>
<p>静态代码块，构造代码块</p>
<p>实例方法，静态方法</p>
<p>实例变量，静态变量</p>
</blockquote>
<h5 id="②枚举类中的-构造方法是私有化-的（默认就是私有化的，只能在本类中调用）"><a href="#②枚举类中的-构造方法是私有化-的（默认就是私有化的，只能在本类中调用）" class="headerlink" title="②枚举类中的&#x3D;&#x3D;构造方法是私有化&#x3D;&#x3D;的（默认就是私有化的，只能在本类中调用）"></a>②枚举类中的&#x3D;&#x3D;构造方法是私有化&#x3D;&#x3D;的（默认就是私有化的，只能在本类中调用）</h5><p>构造方法调用时不能用new。直接使用“枚举值(实参);”调用。</p>
<p>每一个枚举值相当于枚举类型的实例。</p>
<blockquote>
<p>枚举类最开始的时候 定义的枚举值就是枚举类对象，会调用构造函数，默认会调用无参构造函数</p>
<p>如果定义了有参构造函数，没有修改在上面定义的枚举值的话，就会报错</p>
<p>所以需要对于枚举值修改一下构造函数</p>
</blockquote>
<p><img src="/../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228144551282.png" alt="image-20240228144551282"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>) ,SUMMER(<span class="string">&quot;夏天&quot;</span>),AUTUMN(<span class="string">&quot;秋天&quot;</span>),WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;春天&quot;</span>;</span><br><span class="line">    Season(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeasonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> get();</span><br><span class="line">        <span class="keyword">switch</span> (season)&#123;</span><br><span class="line">            <span class="keyword">case</span> SPRING -&gt; System.out.println(Season.SPRING.name());</span><br><span class="line">            <span class="keyword">case</span> SUMMER -&gt; System.out.println(Season.SUMMER.name());</span><br><span class="line">            <span class="keyword">case</span> AUTUMN -&gt; System.out.println(Season.AUTUMN.name());</span><br><span class="line">            <span class="keyword">case</span> WINTER -&gt; System.out.println(Season.WINTER.name());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Season.SPRING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="③枚举类型中如果编写了其他代码，-必须要有枚举值，枚举值的定义要放到最上面，"><a href="#③枚举类型中如果编写了其他代码，-必须要有枚举值，枚举值的定义要放到最上面，" class="headerlink" title="③枚举类型中如果编写了其他代码，&#x3D;&#x3D;必须要有枚举值，枚举值的定义要放到最上面，&#x3D;&#x3D;"></a>③枚举类型中如果编写了其他代码，&#x3D;&#x3D;必须要有枚举值，枚举值的定义要放到最上面，&#x3D;&#x3D;</h5><p>&#x3D;&#x3D;最后一个枚举值的分号不能省略。&#x3D;&#x3D;</p>
<h5 id="④枚举类因为默认继承了-java-lang-Enum-，因此不能再继承其他类，但可以实现接口。"><a href="#④枚举类因为默认继承了-java-lang-Enum-，因此不能再继承其他类，但可以实现接口。" class="headerlink" title="④枚举类因为默认继承了&#x3D;&#x3D;java.lang.Enum&#x3D;&#x3D;，因此不能再继承其他类，但可以实现接口。"></a>④枚举类因为默认继承了&#x3D;&#x3D;java.lang.Enum&#x3D;&#x3D;，因此不能再继承其他类，但可以实现接口。</h5><p>第一种实现方式：在枚举类中实现。</p>
<p>第二种实现方式：让每一个枚举值实现接口。</p>
<img src="../blog_images/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%863/image-20240228134927319.png" alt="image-20240228134927319" style="zoom:50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,SUMMER(<span class="string">&quot;夏天&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lalala&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,AUTUMN(<span class="string">&quot;秋天&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,WINTER(<span class="string">&quot;冬天&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    或者</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>),AUTUMN(<span class="string">&quot;秋天&quot;</span>),WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;春天&quot;</span>;</span><br><span class="line">    Season(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><h4 id="java-util-Random-随机数生成器（生成随机数的工具类）"><a href="#java-util-Random-随机数生成器（生成随机数的工具类）" class="headerlink" title="java.util.Random 随机数生成器（生成随机数的工具类）"></a>java.util.Random 随机数生成器（生成随机数的工具类）</h4><h5 id="①常用构造方法："><a href="#①常用构造方法：" class="headerlink" title="①常用构造方法："></a>①常用构造方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random()</span><br></pre></td></tr></table></figure>

<h5 id="②常用方法：-1"><a href="#②常用方法：-1" class="headerlink" title="②常用方法："></a>②常用方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span>; 获取一个<span class="type">int</span>类型取值范围内的随机<span class="type">int</span>数</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">(<span class="type">int</span> bound)</span>; 获取[<span class="number">0</span>,bound)区间的随机数</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">nextDouble</span><span class="params">()</span>; 获取[<span class="number">0.0</span>, <span class="number">1.0</span>)的随机数。</span><br></pre></td></tr></table></figure>

<h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><h4 id="java-lang-System类的常用方法："><a href="#java-lang-System类的常用方法：" class="headerlink" title="java.lang.System类的常用方法："></a>java.lang.System类的常用方法：</h4><h5 id="①常用属性："><a href="#①常用属性：" class="headerlink" title="①常用属性："></a>①常用属性：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> PrintStream err 标准错误输出流（System.err.println(“错误信息”);输出红色字体）</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> InputStream in 标准输入流</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> PrintStream out 标准输出流</span><br></pre></td></tr></table></figure>



<h5 id="②常用方法：-2"><a href="#②常用方法：-2" class="headerlink" title="②常用方法："></a>②常用方法：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src, <span class="type">int</span> srcPos, Object dest, <span class="type">int</span> destPos, <span class="type">int</span> length)</span>; 数组拷贝</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>; 退出虚拟机</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">gc</span><span class="params">()</span>; 建议启动垃圾回收器</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">currentTimeMillis</span><span class="params">()</span>; 获取自<span class="number">1970</span>-<span class="number">01</span>-<span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">000</span>到系统当前时间的总毫秒数</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> <span class="title function_">nanoTime</span><span class="params">()</span>; 获取自<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日<span class="number">0</span>时<span class="number">0</span>分<span class="number">0</span>秒以来，当前时间的纳秒数</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Map&lt;String,String&gt; <span class="title function_">getenv</span><span class="params">()</span>; 获取当前系统的环境变量，例如Path，JAVA_HOME，CLASSPATH等。</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Properties <span class="title function_">getProperties</span><span class="params">()</span>; 获取当前系统的属性。</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">getProperty</span><span class="params">(String key)</span>; 通过key获取指定的系统属性。</span><br></pre></td></tr></table></figure>

<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><blockquote>
<p>具有全球唯一性的标识</p>
</blockquote>
<h4 id="UUID（通用唯一标识符）是一种软件构建的标准，用来生成具有唯一性的ID。"><a href="#UUID（通用唯一标识符）是一种软件构建的标准，用来生成具有唯一性的ID。" class="headerlink" title="UUID（通用唯一标识符）是一种软件构建的标准，用来生成具有唯一性的ID。"></a>UUID（通用唯一标识符）是一种软件构建的标准，用来生成具有唯一性的ID。</h4><h4 id="UUID具有以下特点："><a href="#UUID具有以下特点：" class="headerlink" title="UUID具有以下特点："></a>UUID具有以下特点：</h4><p>​	①UUID可以在分布式系统中<strong>生成唯一的标识符</strong>，避免因为主键冲突等问题带来的麻烦。</p>
<p>​	&#x3D;&#x3D;<strong>②UUID具有足够的唯一性，重复的概率相当低。UUID使用的是128位数字，除了传统的16进制表示之外（32位的16进制表示</strong>），还有<strong>基于62进制的表示，可以更加简洁紧凑。</strong>&#x3D;&#x3D;</p>
<p>③UUID生成时不需要依赖任何中央控制器或数据库服务器，可以在本地方便、快速地生成唯一标识符。</p>
<p>④UUID生成后可以被许多编程语言支持并方便地转化为字符串表示形式，适用于多种应用场景。</p>
<p><strong>在Java开发中，UUID的使用是非常普遍的。它可以用于生成数据表主键、场景标识、链路追踪、缓存Key等。</strong>使用UUID可以方便地避免主键、缓存Key等因冲突而产生的问题，同时能够实现多种功能，例如追踪、缓存、日志记录等。</p>
<h4 id="Java中的java-util-UUID类提供对UUID的支持"><a href="#Java中的java-util-UUID类提供对UUID的支持" class="headerlink" title="Java中的java.util.UUID类提供对UUID的支持"></a>Java中的java.util.UUID类提供对UUID的支持</h4><p>①生成UUID：static UUID randomUUID();</p>
<p>②将UUID转换为字符串：String toString();</p>
]]></content>
      <categories>
        <category>Java体系知识</category>
        <category>java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Redis-记录</title>
    <url>/2024/02/21/Redis-%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="第一章-Redis-概述"><a href="#第一章-Redis-概述" class="headerlink" title="第一章 Redis 概述"></a>第一章 Redis 概述</h1><h2 id="一、Redis-Remote-Dictionary-Server-远程字典服务"><a href="#一、Redis-Remote-Dictionary-Server-远程字典服务" class="headerlink" title="一、Redis(Remote Dictionary Server)远程字典服务"></a>一、Redis(Remote Dictionary Server)远程字典服务</h2><ol>
<li><p>使用 &#x3D;&#x3D;ANSI C 语言&#x3D;&#x3D;编写、&#x3D;&#x3D;支持网络、可基于内存亦可持久化的日志型、NoSQL 开源内存数据库&#x3D;&#x3D;，其提供多种语言的 API。</p>
</li>
<li><p>Redis被称为字典服务的原因在于，redis是一个key-value的存储系统。</p>
<blockquote>
<p>支持存储的value类型有很多，包括String（字符串）、List（链表）、Set（集合）、Zset（sorted set– 有序集合）和哈希类型等</p>
</blockquote>
</li>
</ol>
<h2 id="二、NoSQL"><a href="#二、NoSQL" class="headerlink" title="二、NoSQL"></a>二、NoSQL</h2><p>Nosql（non-relational，Not Only SQL），泛指的是非关系型的数据库。</p>
<blockquote>
<p>比如社交类的等等</p>
</blockquote>
<p>&#x3D;&#x3D;NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，特别是大数据应用难题&#x3D;&#x3D;</p>
<p>传统方法不适合这种情况。</p>
<h3 id="1-键值存储数据库"><a href="#1-键值存储数据库" class="headerlink" title="1. 键值存储数据库"></a>1. 键值存储数据库</h3><p>类似Map的key-value对。</p>
<blockquote>
<p>典型代表redis</p>
</blockquote>
<h3 id="2-列存储数据库"><a href="#2-列存储数据库" class="headerlink" title="2. 列存储数据库"></a>2. 列存储数据库</h3><p>注意的是 ，关系数据库是行关系库，其存在的问题在于，按照行存储的数据在物理层面占用的是连续的存储空间，&#x3D;&#x3D;是不适合海量的数据存储&#x3D;&#x3D;的。</p>
<p>而按列存储则可以实现一个分布式存储，适合海量的存储</p>
<blockquote>
<p>典型的代表就是HBase</p>
</blockquote>
<h3 id="3-文档型数据库"><a href="#3-文档型数据库" class="headerlink" title="3. 文档型数据库"></a>3. 文档型数据库</h3><p>NoSQL与关系型数据的结合，最想关系型数据库的NoSQL</p>
<blockquote>
<p>典型代表就是MongoDB。</p>
</blockquote>
<h3 id="4-图像（Graph）数据库"><a href="#4-图像（Graph）数据库" class="headerlink" title="4. 图像（Graph）数据库"></a>4. 图像（Graph）数据库</h3><blockquote>
<p>用于存放一个节点关系的数据库，例如描述不同人间的关系。典型代表是 Neo4J。</p>
</blockquote>
<h2 id="三、Redis的用途"><a href="#三、Redis的用途" class="headerlink" title="三、Redis的用途"></a>三、Redis的用途</h2><h3 id="1-数据缓存"><a href="#1-数据缓存" class="headerlink" title="1.数据缓存"></a>1.数据缓存</h3><p>Redis在生产中用的最多的场景：&#x3D;&#x3D;数据缓存&#x3D;&#x3D;。</p>
<p>正常情况下，用户-&gt;服务器-&gt;数据库 （query），然后再返回。</p>
<p>但是当用户很多的时候，就是高并发的时候，解决不了了。</p>
<p>因此提出解决方案： 用户-&gt;服务器-&gt;缓存-&gt; 数据库 （query）</p>
<p><img src="/../blog_images/Redis-%E8%AE%B0%E5%BD%95/image-20240223001703204.png" alt="image-20240223001703204"></p>
<p>这样DBMS压力就会减轻。</p>
<blockquote>
<p>即客户端从 DBMS 中查询出的数据首先写入到 Redis 中，后续无论哪个客户端再需要访问该数据，直接读取 Redis 中的即可，不仅减小了 RT，而且降低了 DBMS 的压力。</p>
<p>而且，DBMS一般存放在磁盘中，而Redis作为内存数据库是放在内存中的，且直接通过key来查询，缓存层的查询非常的快，高并发的问题可以解决。</p>
</blockquote>
<h4 id="数据不一致问题？："><a href="#数据不一致问题？：" class="headerlink" title="数据不一致问题？："></a>数据不一致问题？：</h4><p>当一个用户提出要修改，修改了DBMS，没有修改缓存层，就会存在一个脏数据&#x2F;</p>
<p><img src="/../blog_images/Redis-%E8%AE%B0%E5%BD%95/image-20240223074739083.png" alt="image-20240223074739083"></p>
<p>预热：服务器不是刚开就提供服务，会有一个预热，把一些基础数据先保存到缓存中</p>
<h2 id="四、Redis-特性"><a href="#四、Redis-特性" class="headerlink" title="四、Redis 特性"></a>四、<strong>Redis</strong> <strong>特性</strong></h2><h3 id="1-性能极高："><a href="#1-性能极高：" class="headerlink" title="1.性能极高："></a>1.性能极高：</h3><p>Redis 读的速度可以达到 11w 次&#x2F;s，写的速度可以达到 8w 次&#x2F;s。只所以具有，这么高的性能，因为以下几点原因：</p>
<p>1）Redis 的所有操作都是在内存中发生的。</p>
<p>2）Redis 是用 C 语言开发的。</p>
<p>3）Redis 源码非常精细（集性能与优雅于一身）。</p>
<h3 id="2-简单稳定"><a href="#2-简单稳定" class="headerlink" title="2.简单稳定"></a>2.简单稳定</h3><p>Redis 源码很少。早期版本只有 2w 行左右。从 3.0 版本开始，增加了集群功能，代码变为了 5w 行左右。</p>
<h3 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3.持久化"></a>3.持久化</h3><p>数据缓存是暂时的，要保存到磁盘，才能保证数据安全。Redis 内存中的数据可以进行持久化，其有两种方式：RDB 与 AOF。</p>
<h3 id="4-高可用集群"><a href="#4-高可用集群" class="headerlink" title="4.高可用集群"></a>4.高可用集群</h3><p>Redis 提供了高可用的主从集群功能，可以确保系统的安全性</p>
<h3 id="5-丰富的数据类型"><a href="#5-丰富的数据类型" class="headerlink" title="5.丰富的数据类型"></a>5.丰富的数据类型</h3><p>Redis 是一个 key-value 存储系统。支持存储的 value 类型很多，包括String(字符串)、List(链表)、Set(集合)、Zset(sorted set –有序集合)和 Hash（哈希类型）等，还有 BitMap、HyperLogLog、Geospatial 类型</p>
<ol>
<li><p> BitMap：一般用于大数据量的二值性统计。<br>比如员工是否打卡</p>
</li>
<li><p> HyperLogLog：其是 Hyperlog Log，用于对数据量超级庞大的日志做去重统计。</p>
</li>
<li><p> Geospatial：地理空间，其主要用于地理位置相关的计算。</p>
<p>比如“附近的人”</p>
</li>
</ol>
<h3 id="6-强大的功能"><a href="#6-强大的功能" class="headerlink" title="6.强大的功能"></a>6.强大的功能</h3><p>Redis 提供了数据过期功能、发布&#x2F;订阅功能、简单事务功能，还支持 Lua脚本扩展功能。</p>
<h3 id="7-客户端语言广泛"><a href="#7-客户端语言广泛" class="headerlink" title="7.客户端语言广泛"></a>7.客户端语言广泛</h3><p>Redis提供了简单的 TCP 通信协议，编程语言可以方便地的接入 Redis。所以，有很多的开源社区、大公司等开发出了很多语言的 Redis 客户端。</p>
<h3 id="8-支持-ACL-权限控制"><a href="#8-支持-ACL-权限控制" class="headerlink" title="8.支持 ACL 权限控制"></a>8.支持 ACL 权限控制</h3><p>之前的权限控制非常笨拙。从 Redis6 开始引入了 ACL 模块，可以为不同用户定制不同的用户权限。</p>
<p><img src="/../blog_images/Redis-%E8%AE%B0%E5%BD%95/image-20240223081342029.png" alt="image-20240223081342029"></p>
<blockquote>
<p>linux 的drwxr-xr-x ：d表示目录&#x2F;l表示链接，rwx表示用户（创建者User）读写可执行；Group r-x后三位表示和创建者同组用户读可执行。Other r-x</p>
</blockquote>
<h3 id="9-支持多线程-IO-模型"><a href="#9-支持多线程-IO-模型" class="headerlink" title="9.支持多线程 IO 模型"></a>9.支持多线程 IO 模型</h3><p>Redis 之前版本采用的是单线程模型，从 6.0 版本开始支持了多线程模型。</p>
<h2 id="五-Redis-的-IO-模型"><a href="#五-Redis-的-IO-模型" class="headerlink" title="五.Redis 的 IO 模型"></a>五.<strong>Redis</strong> <strong>的</strong> <strong>IO</strong> <strong>模型</strong></h2><p>单线程模型 多线程模型 混合模型</p>
<p>Redis 客户端提交的各种请求是如何最终被 Redis 处理的？Redis 处理客户端请求所采用的处理架构，称为 Redis 的 IO 模型。不同版本的 Redis 采用的 IO 模型是不同的。</p>
<h3 id="1-单线程模型"><a href="#1-单线程模型" class="headerlink" title="1.单线程模型"></a>1.<strong>单线程模型</strong></h3><blockquote>
<p>性能还是很强,写8w&#x2F;qps,读11w&#x2F;qps–&gt;内存\单线程可维护性比较高(多线程存在线程切换问题,顾及到数据安全问题\死锁问题)</p>
<p>问题:持久化等操作和客户端没太多联系,但是又比较费时,于是提出了混合线程模型</p>
</blockquote>
<p>对于 Redis 3.0 及其以前版本，Redis 的 IO 模型采用的是纯粹的单线程模型。即所有客户端的请求全部由一个线程处理。</p>
<p><img src="/../blog_images/Redis-%E8%AE%B0%E5%BD%95/image-20240223082516763.png" alt="image-20240223082516763"></p>
<p>每个客户端若要向 Redis 提交请求，都需要与 Redis 建立一个 socket 连接，并向事件分发器注册一个事件。</p>
<p>一旦该事件发生就表明该连接已经就绪。而一旦连接就绪，事件分发器就会感知到，然后获取客户端通过该连接发送的请求，并将由该事件分发器所绑定的这个唯一的线程来处理。</p>
<p>如果该线程还在处理多个任务，则将该任务写入到任务队列等待线程处理。只所以称为事件分发器，是因为它会根据不同的就绪事件，将任务交由不同的事件处理器去处理</p>
<p><strong>&#x3D;&#x3D;Redis 的单线程模型采用了多路复用技术。&#x3D;&#x3D;</strong></p>
<p>对于多路复用器的多路选择算法常见的有三种：select 模型、poll 模型、epoll 模型。</p>
<ol>
<li><p>poll 模型的选择算法：采用的是轮询算法。该模型对客户端的就绪处理是有延迟的。</p>
</li>
<li><p>epoll 模型的选择算法：采用的是回调方式。根据就绪事件发生后的处理方式的不同，又可分为 LT 模型与 ET 模型。</p>
</li>
</ol>
<h3 id="2-混合线程模型"><a href="#2-混合线程模型" class="headerlink" title="2.混合线程模型"></a>2.混合线程模型</h3><p>从 Redis 4.0 版本开始，Redis 中就开始加入了多线程元素。处理客户端请求的仍是单线</p>
<p>程模型，但对于一些比较耗时但又不影响对客户端的响应的操作，就由后台其它线程来处理。</p>
<p>例如，持久化、对 AOF 的 rewrite、对失效连接的清理等</p>
<h3 id="3-多线程模型"><a href="#3-多线程模型" class="headerlink" title="3.多线程模型"></a>3.<strong>多线程模型</strong></h3><p><img src="/../blog_images/Redis-%E8%AE%B0%E5%BD%95/image-20240223083447687.png" alt="image-20240223083447687"></p>
<p>内存响应时间(RT)100ns</p>
<p>Redis 每秒处理读写请求 达到:1s&#x2F;100ns &#x3D; &#x3D;1kw次,实际情况是,redis8w&#x2F;qps,读11w&#x2F;qps,差距那么大的原因 就是redis的单线程</p>
<p>是将单线程和多线程各取其优点.</p>
<p><img src="/../blog_images/Redis-%E8%AE%B0%E5%BD%95/image-20240223083854779.png" alt="image-20240223083854779"></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2024/02/23/SpringBoot/</url>
    <content><![CDATA[<blockquote>
<p>这个是从原理开始讲的，这个我不照着写，我就是学</p>
</blockquote>
<p>springboot内置了tomcat，所以可以直接打包成jar包</p>
<h1 id="什么是tomcat"><a href="#什么是tomcat" class="headerlink" title="什么是tomcat"></a>什么是tomcat</h1><p>Tomcat是常见的免费的web服务器。</p>
<h2 id="1-不使用tomcat访问html"><a href="#1-不使用tomcat访问html" class="headerlink" title="1. 不使用tomcat访问html"></a>1. 不使用tomcat访问html</h2><p>可以在浏览器的地址里看到 file:d:&#x2F;test.html 这样的格式，是通过打开本地文件的形式打开的</p>
<p>但是我们平时上网看到的html网址一般都是: <a href="https://link.zhihu.com/?target=http://12306.com/index.html">http://12306.com/index.html</a> 这样的形式<br>这是因为有web服务器的存在</p>
<h2 id="2-使用tomcat后，访问html"><a href="#2-使用tomcat后，访问html" class="headerlink" title="2.使用tomcat后，访问html"></a>2.使用tomcat后，访问html</h2><p>使用tomcat后，可以像127.0.0.1:8080&#x2F;test.html这样访问一个网站，而不是访问一个html文件。因为tomcat本身就是一个web服务器，test.html部署在了这个web服务器上</p>
<p><img src="/../blog_images/SpringBoot/2018120522281643.gif" alt="img"></p>
<h1 id="SpringBoot启动"><a href="#SpringBoot启动" class="headerlink" title="SpringBoot启动"></a>SpringBoot启动</h1>]]></content>
      <tags>
        <tag>Java体系知识</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/2024/02/23/SpringSecurity/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>dlyk_part1</title>
    <url>/2024/02/18/dlyk-part1/</url>
    <content><![CDATA[<h1 id="一、技术的版本控制"><a href="#一、技术的版本控制" class="headerlink" title="一、技术的版本控制"></a>一、技术的版本控制</h1><p><img src="/../blog_images/dlyk-part1/image-20240218015738084.png" alt="image-20240218015738084"></p>
<p><img src="/../blog_images/dlyk-part1/image-20240218015750388.png" alt="image-20240218015750388"></p>
<p><img src="/../blog_images/dlyk-part1/image-20240221152352894.png" alt="image-20240221152352894"></p>
<p><img src="/../blog_images/dlyk-part1/image-20240221152403852.png" alt="image-20240221152403852"></p>
<p><img src="/../blog_images/dlyk-part1/image-20240221152414970.png" alt="image-20240221152414970"></p>
<p><img src="/../blog_images/dlyk-part1/image-20240221152423433.png" alt="image-20240221152423433"></p>
<h1 id="二、动力云客的项目概述"><a href="#二、动力云客的项目概述" class="headerlink" title="二、动力云客的项目概述"></a>二、动力云客的项目概述</h1><p>这个项目就是一个商业的集合营销销售为一体的客户关系管理系统，采用信息化、数字化的方式来进行营销和看客户管理。</p>
<h2 id="1-项目数据库：Mysql一个数据库"><a href="#1-项目数据库：Mysql一个数据库" class="headerlink" title="1.项目数据库：Mysql一个数据库"></a>1.项目数据库：Mysql一个数据库</h2><h2 id="2-前端项目："><a href="#2-前端项目：" class="headerlink" title="2.前端项目："></a>2.前端项目：</h2><p> 这是一个前后端分离的项目 （前端vue–&gt;（ajax axios） http请求–&gt;后端项目（spring boot）</p>
<p> （1） node.js是一个开源的跨平台的JavaScript运行时环境，类似java的jvm</p>
<p> （2） npm JavaScript依赖包管理器 ，全世界都可以用这个来共享javascript包，负责前端项目的打包，插件的下载 node package manager </p>
<p> （3）Vite 是快速构建前端Vue项目的脚手架，可以理解为开发Spring boot的Spring initializr的快速构建工具。（之前是用vue-cil的）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm create vite@latest//</span><br></pre></td></tr></table></figure>

<h1 id="三、启动之前的项目"><a href="#三、启动之前的项目" class="headerlink" title="三、启动之前的项目"></a>三、启动之前的项目</h1><p>用的是jdk17 ；</p>
<p>前端跑起来需要进入package.json 在scripts 处 跑dev</p>
<h2 id="1-admin的密码"><a href="#1-admin的密码" class="headerlink" title="1. admin的密码"></a>1. admin的密码</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t_user</span><br><span class="line"><span class="keyword">SET</span> login_pwd <span class="operator">=</span> <span class="string">&#x27;$2a$10$t1ZZqt3jgYNabcSS1NMZ/uqGALlCF/VH5wSL3CYduABGeVvKFVEi6&#x27;</span>  <span class="comment">-- 这里替换为新密码的哈希值</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>哈希代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordEncoderExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 BCryptPasswordEncoder</span></span><br><span class="line">        <span class="type">PasswordEncoder</span> <span class="variable">encoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编码密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">rawPassword</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encodedPassword</span> <span class="operator">=</span> encoder.encode(rawPassword);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印编码后的密码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Encoded Password: &quot;</span> + encodedPassword);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-端口"><a href="#2-端口" class="headerlink" title="2. 端口"></a>2. 端口</h2><p>前端的端口：8080 在vite.config.js中修改</p>
<p>后端的端口：8088 在application.yml中修改</p>
<p><img src="/../blog_images/dlyk-part1/image-20240218232659713.png" alt="image-20240218232659713"></p>
]]></content>
      <categories>
        <category>Java项目</category>
        <category>动力云客</category>
      </categories>
  </entry>
  <entry>
    <title>dlyk-part2-front-1</title>
    <url>/2024/02/18/dlyk-part2-front-1/</url>
    <content><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="一-、-登录界面"><a href="#一-、-登录界面" class="headerlink" title="一 、 登录界面"></a>一 、 登录界面</h2><h3 id="（1）用vite脚手架创建项目"><a href="#（1）用vite脚手架创建项目" class="headerlink" title="（1）用vite脚手架创建项目"></a>（1）用vite脚手架创建项目</h3><blockquote>
<p>工程化方式，采用脚手架工具创建一个vue工程，然后进行开发；（项目开发<strong>广泛</strong>使用）</p>
</blockquote>
<p><img src="/../blog_images/dlyk-part2-front-1/image-20240218233633476.png" alt="image-20240218233633476"></p>
<h3 id="（2）vue项目的工程结构说明"><a href="#（2）vue项目的工程结构说明" class="headerlink" title="（2）vue项目的工程结构说明"></a>（2）vue项目的工程结构说明</h3><p><img src="/../blog_images/dlyk-part2-front-1/image-20240218234826841.png" alt="image-20240218234826841"><img src="/../blog_images/dlyk-part2-front-1/image-20240219000847361.png" alt="image-20240219000847361"></p>
<p><img src="/../blog_images/dlyk-part2-front-1/image-20240219000858770.png" alt="image-20240219000858770"></p>
<p><img src="/../blog_images/dlyk-part2-front-1/image-20240219000912548.png" alt="image-20240219000912548"></p>
<p><img src="/../blog_images/dlyk-part2-front-1/image-20240219000919973.png" alt="image-20240219000919973"></p>
<h2 id="（3）启动Vue项目工程"><a href="#（3）启动Vue项目工程" class="headerlink" title="（3）启动Vue项目工程"></a>（3）启动Vue项目工程</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是为了修改端口 之前的（老版本）vue端口占了8080，这里</span></span><br><span class="line">vite,config.<span class="property">js</span>:</span><br><span class="line"></span><br><span class="line"><span class="attr">server</span>:&#123;</span><br><span class="line">  <span class="attr">host</span>:<span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">  <span class="attr">port</span>:<span class="number">8081</span>,</span><br><span class="line">  <span class="attr">open</span>:<span class="literal">true</span>,</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> dlyk_front</span><br><span class="line">npm install  或者  npm i</span><br><span class="line">npm run dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="（4）开始Vue的项目开发"><a href="#（4）开始Vue的项目开发" class="headerlink" title="（4）开始Vue的项目开发"></a>（4）开始Vue的项目开发</h2><ul>
<li><h3 id="最基础的文件"><a href="#最基础的文件" class="headerlink" title="最基础的文件"></a>最基础的文件</h3><p>最基础的就是.vue文件，这个文件的就是vue界面，也成为vue组件，一般来说是分为三个部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. //&lt;template&gt; 这个里面写了一个html业面要展示的内容</span><br><span class="line"></span><br><span class="line">   //&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">2. //&lt;script&gt; 这个里面鞋的是javascript的代码</span><br><span class="line"></span><br><span class="line">   //&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">3. //&lt;style&gt; 这里写的是css的样式 </span><br></pre></td></tr></table></figure>


</li>
<li><h3 id="vue工程的运行流程分析"><a href="#vue工程的运行流程分析" class="headerlink" title="vue工程的运行流程分析"></a>vue工程的运行流程分析</h3><p>&#x3D;&#x3D;项目的运行入口：main.js&#x3D;&#x3D;</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; from <span class="string">&#x27;vue&#x27;</span><span class="comment">//createApp是函数</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App from <span class="string">&#x27;./App.vue&#x27;</span><span class="comment">//从一个单文件组件中导入根组件</span></span><br><span class="line"></span><br><span class="line">createApp(App)</span><br><span class="line">    .mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">    <span class="comment">//利用导入的函数 创建一个vue应用</span></span><br><span class="line">    <span class="comment">//挂载到页面的#app这个id下，id在index.html&lt;div id=&#x27;app&#x27;&gt;</span></span><br><span class="line">    <span class="comment">//动态渲染在这个div里</span></span><br><span class="line">    <span class="comment">//运行一下，把运行的结果放在这个id的标签下</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="登录页面使用的技术"><a href="#登录页面使用的技术" class="headerlink" title="登录页面使用的技术"></a>登录页面使用的技术</h3><p>vue – controller - service – manager - mapper ( mysql、redis)</p>
<p>页面使用了element-plus进行页面开发；</p>
<h4 id="1-element-plus安装"><a href="#1-element-plus安装" class="headerlink" title="1. element plus安装"></a>1. element plus安装</h4></li>
</ul>
<blockquote>
<p>我们的项目，需要使用到一些页面的效果（表单、输入框、表格、按钮、布局、图标等等），我们采用的都是element-plus给我们提供的；</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、项目中要安装element-plus：</span><br><span class="line">npm install element-plus --save</span><br><span class="line">npm i element-plus --save</span><br><span class="line">-g 全局安装，安装到D:\course\tool\node-v20.9.0-win-x64\node_global</span><br><span class="line">--save表示安装包信息会写入package.json的dependencies中，在dependencies中，那么项目打包就会依赖到该模块；</span><br><span class="line">--save-dev上线不需要用，如果项目打包时不需要依赖该模块，那么就使用--save-dev，它会在devDependencies下，表示项目开发需要依赖该模块，项目打包发布就不需要它；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、导入element-plus"><a href="#2、导入element-plus" class="headerlink" title="2、导入element-plus"></a>2、导入element-plus</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在main.js中</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ElementPlus from <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="comment">//css不用 from</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line">createApp(App).use(ElementPlus).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">    <span class="comment">//挂载一定是最后一步</span></span><br></pre></td></tr></table></figure>

<h4 id="3-element提供的组件"><a href="#3-element提供的组件" class="headerlink" title="3. element提供的组件"></a>3. element提供的组件</h4><blockquote>
<p><a href="https://element-plus.gitee.io/zh-CN/guide/design.html#%E4%B8%80%E8%87%B4-consistency">设计 | Element Plus (gitee.io)</a></p>
</blockquote>
<p>element-plus提供的组件：</p>
<p>1、Basic 基础组件</p>
<p>2、配置组件</p>
<p>3、Form 表单组件</p>
<p>4、Data 数据展示</p>
<p>5、Navigation 导航</p>
<p>6、Feedback 反馈组件</p>
<p>7、Others 其他</p>
<p><img src="/../blog_images/dlyk-part2-front-1/image-20240219004142653.png" alt="image-20240219004142653"></p>
<h4 id="4-布局"><a href="#4-布局" class="headerlink" title="4. 布局"></a>4. 布局</h4><p> 这里是利用element实现最简单的左右布局，由于我们不弄前端，这个浅浅了解就行，无需非常深入</p>
<h5 id="step1：创建新vue-component"><a href="#step1：创建新vue-component" class="headerlink" title="step1：创建新vue component"></a>step1：创建新vue component</h5><blockquote>
<p>composition api:大项目 、推荐</p>
<p>options api ：初学者</p>
</blockquote>
<p>创建<img src="/../blog_images/dlyk-part2-front-1/image-20240219073424268.png" alt="image-20240219073424268"></p>
<h5 id="step2：界面"><a href="#step2：界面" class="headerlink" title="step2：界面"></a>step2：界面</h5><p>创建一个view文件夹 ，里面都是要写的一些页面 。</p>
<p>在view文件夹下面 创建LoginView.vue的页面，然后就开始编写。</p>
<p>去element ui的网站里面去复制格局和部件等等。</p>
<p>当要加入表单的时候，就是要从页面获取信息的时候，需要在script里加入一些设置</p>
<p>注意：</p>
<p>要在App.vue处增加内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; from <span class="string">&#x27;vue&#x27;</span><span class="comment">//createApp这个是一个函数</span></span><br><span class="line"><span class="comment">//import &#x27;./style.css&#x27;</span></span><br><span class="line"><span class="comment">//import App from &#x27;./App.vue&#x27;//从一个单文件组件中导入根组件</span></span><br><span class="line"><span class="keyword">import</span> ElementPlus from <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> loginView from <span class="string">&quot;./view/LoginView.vue&quot;</span>;</span><br><span class="line">createApp(loginView).use(ElementPlus).mount(<span class="string">&#x27;#app&#x27;</span>)<span class="comment">//创建一个vue对象//挂载到页面的#app这个id下</span></span><br><span class="line">    <span class="comment">//上面两句很重要</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">el-container</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--    左侧--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-aside</span> <span class="attr">width</span>=<span class="string">&quot;200px&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../assets/loginBox.svg&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;imgTitle&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        欢迎使用动力云客系统</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-aside</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!--    右侧--&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">el-main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;loginTile&quot;</span>&gt;</span>欢迎登录<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">ref</span>=<span class="string">&quot;loginRefForm&quot;</span> <span class="attr">:model</span>=<span class="string">&quot;user&quot;</span> <span class="attr">label-width</span>=<span class="string">&quot;120px&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;loginRules&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;账号&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;loginAct&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;user.loginAct&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;loginPwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user.loginPwd&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登 录<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">label</span>=<span class="string">&quot;记住我&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user.rememberMe&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">el-main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">el-container</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//定义页面使用到的变量，定义时初始值都是给个空的</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;defineComponent&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;LoginView&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义页面使用到的变量，定义时初始值都是给个空的</span></span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">//对象变量定义，是&#123;&#125;</span></span><br><span class="line">      user : &#123;&#125;,</span><br><span class="line">      <span class="comment">//字符串变量定义，是&#x27;&#x27;</span></span><br><span class="line">      name : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="comment">//数字变量定义，是0</span></span><br><span class="line">      age : <span class="number">0</span>,</span><br><span class="line">      <span class="comment">//数组变量定义，是[]</span></span><br><span class="line">      arr : [],</span><br><span class="line">      <span class="comment">//list集合对象(对象数组)，是[&#123;&#125;]</span></span><br><span class="line">      userList : [&#123;&#125;],</span><br><span class="line">      <span class="comment">//定义登录表单的验证规则</span></span><br><span class="line">      loginRules : &#123;</span><br><span class="line">        <span class="comment">//定义账号的验证规则，规则可以有多个，所以是数组</span></span><br><span class="line">        loginAct : [</span><br><span class="line">          &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;请输入登录账号&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">//定义密码的验证规则，规则可以有多个，所以是数组</span></span><br><span class="line">        loginPwd : [</span><br><span class="line">          &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;请输入登录密码&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">min</span>: <span class="number">6</span>, <span class="attr">max</span>: <span class="number">16</span>, <span class="attr">message</span>: <span class="string">&#x27;登录密码长度为6-16位&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="step3：表单验证"><a href="#step3：表单验证" class="headerlink" title="step3：表单验证"></a>step3：表单验证</h5><blockquote>
<p>（1）账号字段：loginAct （account）登录账号；</p>
<p>（2）密码字段：loginPwd （password）登录密码；</p>
<p>（3）是否记住我字段：rememberMe</p>
<p>需求：前端非空验证；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、在&lt;el-form&gt;里面定义一个:rules=&quot;rules&quot;；</span><br><span class="line">2、在要验证的el-input上的&lt;el-form-item&gt;中定义prop=xx 比如下面的loginAct和pwd， </span><br><span class="line">3、给要验证的字段定义验证规则；</span><br></pre></td></tr></table></figure>

<p>3、给要验证的字段定义验证规则；</p>
</blockquote>
<ol>
<li>在el-form头标签里面写：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;el-form ref=<span class="string">&quot;loginRefForm&quot;</span> :model=<span class="string">&quot;user&quot;</span> label-width=<span class="string">&quot;120px&quot;</span> :rules=<span class="string">&quot;loginRules&quot;</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;账号&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;loginAct&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;user.loginAct&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;loginPwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user.loginPwd&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line">	这里是增加了一个点击事件</span><br><span class="line">        &lt;el-form-item&gt;</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;login&quot;</span>&gt;</span>登 录<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span></span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">label</span>=<span class="string">&quot;记住我&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user.rememberMe&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span></span><br><span class="line">      &lt;/el-form&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>需要在script里面</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123;defineComponent&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;LoginView&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义页面使用到的变量，定义时初始值都是给个空的</span></span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">//对象变量定义，是&#123;&#125;</span></span><br><span class="line">      user : &#123;&#125;,</span><br><span class="line">      <span class="comment">//字符串变量定义，是&#x27;&#x27;</span></span><br><span class="line">      name : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="comment">//数字变量定义，是0</span></span><br><span class="line">      age : <span class="number">0</span>,</span><br><span class="line">      <span class="comment">//数组变量定义，是[]</span></span><br><span class="line">      arr : [],</span><br><span class="line">      <span class="comment">//list集合对象(对象数组)，是[&#123;&#125;]</span></span><br><span class="line">      userList : [&#123;&#125;],</span><br><span class="line">      <span class="comment">//定义登录表单的验证规则</span></span><br><span class="line">      loginRules : &#123;</span><br><span class="line">        <span class="comment">//定义账号的验证规则，规则可以有多个，所以是数组</span></span><br><span class="line">        loginAct : [</span><br><span class="line">          &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;请输入登录账号&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">//定义密码的验证规则，规则可以有多个，所以是数组</span></span><br><span class="line">        loginPwd : [</span><br><span class="line">          &#123; <span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;请输入登录密码&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">min</span>: <span class="number">6</span>, <span class="attr">max</span>: <span class="number">16</span>, <span class="attr">message</span>: <span class="string">&#x27;登录密码长度为6-16位&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要加入这个属性</p>
<p>ref&#x3D;”loginRefForm”   </p>
<p>表示在提交之前 需要执行一下规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-form ref=&quot;loginRefForm&quot; :model=&quot;user&quot; label-width=&quot;120px&quot; :rules=&quot;loginRules&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/dlyk-part2-front-1/image-20240221130953823.png" alt="image-20240221130953823"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">loginRefForm</span>.<span class="title function_">validate</span>( <span class="function">(<span class="params">isValid</span>) =&gt;</span> &#123;</span><br></pre></td></tr></table></figure>

<p>这个会调用:rules&#x3D;”loginRules”规则 ，然后得到一个返回值，就是一个验证之后的结果。</p>
<p>如果是true 表示验证通过</p>
<p>​	验证通过后 ，就表示要提交了。axios 。ajax</p>
<p>反之表示没通过</p>
<h5 id="step4-使用axios-封装"><a href="#step4-使用axios-封装" class="headerlink" title="step4: 使用axios &#x2F;&#x2F;封装"></a>step4: 使用axios &#x2F;&#x2F;封装</h5><p>主要就是封装4个方法；</p>
<p>doGet() 查询</p>
<p>doPost() 新增</p>
<p>doPut() 修改</p>
<p>doDelete() 删除</p>
<ol>
<li>创建文件与文件夹</li>
</ol>
<p>  <img src="/../blog_images/dlyk-part2-front-1/image-20240221140148575.png" alt="image-20240221140148575"></p>
<ol start="2">
<li><p>封装函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本这个函数是只有function 但是因为要在别的页面上使用，所以就加上了一个export，这里导出</span></span><br><span class="line"><span class="comment">//那边导入</span></span><br><span class="line"><span class="comment">// 从这个框架导入组件</span></span><br><span class="line"><span class="keyword">import</span> axios from <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line">export function <span class="title function_">doGet</span><span class="params">(url ,params)</span>&#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">        method: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        params: params, <span class="comment">//&#123;name: &quot;对的&quot;, age: 22&#125;,</span></span><br><span class="line">        dataType:<span class="string">&quot;json&quot;</span></span><br><span class="line">    &#125;).then(function (rep)&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        reo.data.forEach(function (stu)&#123;</span><br><span class="line">            s += stu.name + <span class="string">&quot;-------------------&quot;</span>+stu.age+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        document.getElementById(<span class="string">&quot;mydiv&quot;</span>).innerHTML = s;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function <span class="title function_">doPost</span><span class="params">(url,data )</span>&#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">        method: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        data: data, <span class="comment">//&#123;name: &quot;对的&quot;, age: 22&#125;,</span></span><br><span class="line">        dataType:<span class="string">&quot;json&quot;</span></span><br><span class="line">    &#125;).then(function (rep)&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        reo.data.forEach(function (stu)&#123;</span><br><span class="line">            s += stu.name + <span class="string">&quot;-------------------&quot;</span>+stu.age+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        document.getElementById(<span class="string">&quot;mydiv&quot;</span>).innerHTML = s;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">export function <span class="title function_">doPut</span><span class="params">(url,data )</span>&#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">        method: <span class="string">&quot;put&quot;</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        data: data, <span class="comment">//&#123;name: &quot;对的&quot;, age: 22&#125;,</span></span><br><span class="line">        dataType:<span class="string">&quot;json&quot;</span></span><br><span class="line">    &#125;).then(function (rep)&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        reo.data.forEach(function (stu)&#123;</span><br><span class="line">            s += stu.name + <span class="string">&quot;-------------------&quot;</span>+stu.age+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        document.getElementById(<span class="string">&quot;mydiv&quot;</span>).innerHTML = s;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">export function <span class="title function_">doDelete</span><span class="params">(url ,params)</span>&#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">        method: <span class="string">&quot;Delete&quot;</span>,</span><br><span class="line">        url: url,</span><br><span class="line">        params: params, <span class="comment">//&#123;name: &quot;对的&quot;, age: 22&#125;,</span></span><br><span class="line">        dataType:<span class="string">&quot;json&quot;</span></span><br><span class="line">    &#125;).then(function (rep)&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">s</span> <span class="operator">=</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        reo.data.forEach(function (stu)&#123;</span><br><span class="line">            s += stu.name + <span class="string">&quot;-------------------&quot;</span>+stu.age+<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        document.getElementById(<span class="string">&quot;mydiv&quot;</span>).innerHTML = s;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="step4-使用axios-封装-1"><a href="#step4-使用axios-封装-1" class="headerlink" title="step4: 使用axios &#x2F;&#x2F;封装"></a>step4: 使用axios &#x2F;&#x2F;封装</h5><blockquote>
<p>一般提交是使用一个表单，然后用put提交，也可以用get 但是一般用put</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在httpRequest.js开始处</span><br><span class="line"><span class="comment">//定义端口的地址，默认地址前缀，</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&quot;http://localhost:8089&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="（5）动力云客后端项目创建"><a href="#（5）动力云客后端项目创建" class="headerlink" title="（5）动力云客后端项目创建"></a>（5）动力云客后端项目创建</h2><p><img src="/../blog_images/dlyk-part2-front-1/image-20240221145546841.png" alt="image-20240221145546841"></p>
<p><img src="/../blog_images/dlyk-part2-front-1/image-20240221150859764.png" alt="image-20240221150859764"><img src="/../blog_images/dlyk-part2-front-1/image-20240221150910929.png" alt="image-20240221150910929"></p>
<p><img src="/../blog_images/dlyk-part2-front-1/image-20240221150924045.png" alt="image-20240221150924045"></p>
<h2 id="（6）编写yml配置文件"><a href="#（6）编写yml配置文件" class="headerlink" title="（6）编写yml配置文件"></a>（6）编写yml配置文件</h2><p>进入<img src="/../blog_images/dlyk-part2-front-1/image-20240222102204105.png" alt="image-20240222102204105"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8089</span><span class="comment">//端口 这里改成了8089</span></span><br><span class="line">  servlet:</span><br><span class="line">    context-path: /</span><br><span class="line"></span><br><span class="line">#配置数据库连接相关信息</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//localhost:3306/dlyk?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false//这里是链接数据库</span></span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">123456</span></span><br><span class="line">    hikari:</span><br><span class="line">      #最大连接数，默认是<span class="number">10</span></span><br><span class="line">      maximum-pool-size: <span class="number">30</span></span><br><span class="line">      #最小空闲连接，默认是<span class="number">10</span></span><br><span class="line">      minimum-idle: <span class="number">30</span></span><br><span class="line">      #等待连接池分配连接的最大时长，超过该时长还没有可用连接则发生超时异常（单位毫秒）</span><br><span class="line">      connection-timeout: <span class="number">5000</span></span><br><span class="line">      #空闲连接的最大时长，空闲多久就被释放回收，设置为<span class="number">0</span>不让连接回收</span><br><span class="line">      idle-timeout: <span class="number">0</span></span><br><span class="line">      #一个连接的最大生命时间，超过该时间还没有使用就回收掉（单位毫秒），最好不要超过<span class="number">8</span>小时</span><br><span class="line">      max-lifetime: <span class="number">18000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  #配置redis的连接信息</span><br><span class="line">  data:</span><br><span class="line">    redis:</span><br><span class="line">      host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="comment">//redis的host 要去看redis的配置。</span></span><br><span class="line">      port: <span class="number">6379</span></span><br><span class="line">      password: <span class="number">123456</span></span><br><span class="line">      database: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  #设置jackson返回json数据时，时区和格式</span><br><span class="line">  jackson:</span><br><span class="line">    time-zone: GMT+<span class="number">8</span></span><br><span class="line">    date-format: yyyy-MM-dd HH:mm:ss</span><br><span class="line"></span><br><span class="line">#指定一下mapper.xml文件的位置</span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper<span class="comment">/*.xml</span></span><br><span class="line"><span class="comment">  configuration:</span></span><br><span class="line"><span class="comment">    #在控制台打印sql语句</span></span><br><span class="line"><span class="comment">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#定义定时任务的调度时间</span></span><br><span class="line"><span class="comment">project:</span></span><br><span class="line"><span class="comment">  task:</span></span><br><span class="line"><span class="comment">    cron: &#x27;* */</span><span class="number">5</span> * * * *<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    delay: 180000</span></span><br></pre></td></tr></table></figure>

<h2 id="（7）mysql反向工程生成表"><a href="#（7）mysql反向工程生成表" class="headerlink" title="（7）mysql反向工程生成表"></a>（7）mysql反向工程生成表</h2><p><img src="/../blog_images/dlyk-part2-front-1/image-20240222102505798.png" alt="image-20240222102505798"></p>
<p><img src="/../blog_images/dlyk-part2-front-1/image-20240222102955294.png" alt="image-20240222102955294"> </p>
<h3 id="注意：Free-Mybatis-plugin-直接在setting-–-plugin-搜索下载就行，然后选中数据库里面的所有表，点击mybatis-generator-，"><a href="#注意：Free-Mybatis-plugin-直接在setting-–-plugin-搜索下载就行，然后选中数据库里面的所有表，点击mybatis-generator-，" class="headerlink" title="注意：Free Mybatis plugin 直接在setting –&gt; plugin 搜索下载就行，然后选中数据库里面的所有表，点击mybatis generator ，"></a>注意：Free <a href="https://so.csdn.net/so/search?q=Mybatis&spm=1001.2101.3001.7020">Mybatis</a> plugin 直接在setting –&gt; plugin 搜索下载就行，然后选中数据库里面的所有表，点击mybatis generator ，</h3><p><img src="/../blog_images/dlyk-part2-front-1/image-20240222120628352.png" alt="image-20240222120628352"></p>
<p>生成结果</p>
<p><img src="/../blog_images/dlyk-part2-front-1/image-20240222120824860.png" alt="image-20240222120824860"></p>
<h2 id="8-加入mapper包的扫描"><a href="#8-加入mapper包的扫描" class="headerlink" title="(8)加入mapper包的扫描"></a>(8)加入mapper包的扫描</h2><p>在<img src="/../blog_images/dlyk-part2-front-1/image-20240222121147528.png" alt="image-20240222121147528"></p>
<p>加入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">//！！！！！！！！！！ 加入这个</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.bjpowernode.mapper&quot;&#125;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DlykServerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DlykServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此外 ，由于mapper的xml（sql语句文件）与mapper不在一个文件夹下面，所以需要指定一下，在application.yml中指定</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br><span class="line">  configuration:</span><br><span class="line">    #??????sql??</span><br><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java项目</category>
        <category>动力云客</category>
      </categories>
  </entry>
  <entry>
    <title>dlyk-part2-front-2</title>
    <url>/2024/02/21/dlyk-part2-front-2/</url>
    <content><![CDATA[<h1 id="这个主要是登录页面后端项目，包括一些基础的搭建工作"><a href="#这个主要是登录页面后端项目，包括一些基础的搭建工作" class="headerlink" title="这个主要是登录页面后端项目，包括一些基础的搭建工作"></a>这个主要是登录页面后端项目，包括一些基础的搭建工作</h1><h2 id="一、项目分层"><a href="#一、项目分层" class="headerlink" title="一、项目分层"></a>一、项目分层</h2><p><img src="/../blog_images/dlyk-part2-front-2/image-20240222121622494.png" alt="image-20240222121622494"></p>
<p>这个就是最常见的，这张图来自于阿里规范</p>
<ol>
<li><p>终端显示层：Vue</p>
</li>
<li><p>开放接口：给其他公司调用</p>
</li>
<li><p>请求处理层：web层</p>
</li>
</ol>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222130745201.png" alt="image-20240222130745201"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3. 【参考】分层领域模型规约：</span><br><span class="line">• DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</span><br><span class="line">这个do对应的就是项目中的model</span><br><span class="line"></span><br><span class="line">• DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。</span><br><span class="line">相当于是service和manager层，但是在项目中没有使用</span><br><span class="line"></span><br><span class="line">• BO（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。</span><br><span class="line">没有使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">• Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。</span><br><span class="line">controller -&gt;service-&gt;manager-&gt;DO 传参数，这个参数是用query来封装的</span><br><span class="line"></span><br><span class="line">• VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</span><br><span class="line">等价于result的我们的R对象</span><br></pre></td></tr></table></figure>



<h4 id="step1：按照上图构建文件目录"><a href="#step1：按照上图构建文件目录" class="headerlink" title="step1：按照上图构建文件目录"></a>step1：按照上图构建文件目录</h4><p><img src="/../blog_images/dlyk-part2-front-2/image-20240222130603666.png" alt="image-20240222130603666"></p>
<p>在result里面加入封装的代码</p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222132938591.png" alt="image-20240222132938591"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统一封装web层向前端页面返回的结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示返回的结果码，比如200成功，500失败</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示返回的结果信息，比如 用户登录状态失效了，请求参数格式有误.......</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示返回的结果数据，数据可能是一个对象，也可以是一个List集合.....</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">OK</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.builder()</span><br><span class="line">                .code(CodeEnum.OK.getCode())</span><br><span class="line">                .msg(CodeEnum.OK.getMsg())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">OK</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.builder()</span><br><span class="line">                .code(code)</span><br><span class="line">                .msg(msg)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">OK</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.builder()</span><br><span class="line">                .code(CodeEnum.OK.getCode())</span><br><span class="line">                .msg(CodeEnum.OK.getMsg())</span><br><span class="line">                .data(data)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">OK</span><span class="params">(CodeEnum codeEnum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.builder()</span><br><span class="line">                .code(CodeEnum.OK.getCode())</span><br><span class="line">                .msg(codeEnum.getMsg())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">FAIL</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.builder()</span><br><span class="line">                .code(CodeEnum.FAIL.getCode())</span><br><span class="line">                .msg(CodeEnum.FAIL.getMsg())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">FAIL</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.builder()</span><br><span class="line">                .code(CodeEnum.FAIL.getCode())</span><br><span class="line">                .msg(msg)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">FAIL</span><span class="params">(CodeEnum codeEnum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> R.builder()</span><br><span class="line">                .code(codeEnum.getCode())</span><br><span class="line">                .msg(codeEnum.getMsg())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222133207911.png" alt="image-20240222133207911"></p>
<p>传参数是统统都用query来传输</p>
<h4 id="step2：后端登录代码实现"><a href="#step2：后端登录代码实现" class="headerlink" title="step2：后端登录代码实现"></a>step2：后端登录代码实现</h4><p>后台提供一个spring security的接口</p>
<h4 id="（1）创建UserService层"><a href="#（1）创建UserService层" class="headerlink" title="（1）创建UserService层"></a>（1）创建UserService层</h4><p><img src="/../blog_images/dlyk-part2-front-2/image-20240222133807376.png" alt="image-20240222133807376"></p>
<h4 id="（2）extends-UserDetailsService"><a href="#（2）extends-UserDetailsService" class="headerlink" title="（2）extends UserDetailsService"></a>（2）extends UserDetailsService</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserDetailsService 里面有关于数据库查找的一些相关的内容</p>
<h4 id="（3）写（2）接口的实现"><a href="#（3）写（2）接口的实现" class="headerlink" title="（3）写（2）接口的实现"></a>（3）写（2）接口的实现</h4><p><img src="/../blog_images/dlyk-part2-front-2/image-20240222134110834.png" alt="image-20240222134110834"></p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222134241729.png" alt="image-20240222134241729"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bjpowernode.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注入 Mapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TUserMapper tUserMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">TUser</span> <span class="variable">tUser</span> <span class="operator">=</span> tUserMapper.selectByLoginAct(username);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tUser == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;登录账号不存在！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        按照username查找对象，返回一个TUser对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;selectByLoginAct没有实现&#x3D;&#x3D;，所以需要去实现一下</p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222134902977.png" alt="image-20240222134902977"></p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222135129842.png" alt="image-20240222135129842"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByLoginAct&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">  from t_user</span><br><span class="line">  where login_act = #&#123;username,jdbcType=VARCHAR&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;这样就完成了，相当于定义一个函数（这个函数要进行的是一些sql命令），然后去xml中实现这个函数&#x3D;&#x3D;</p>
<h4 id="（4）改写return的内容"><a href="#（4）改写return的内容" class="headerlink" title="（4）改写return的内容"></a>（4）改写return的内容</h4><blockquote>
<p>关于UserDeitails接口，详见</p>
<p><a href="https://blog.csdn.net/qq_22078107/article/details/106654924">【详解】Spring Security的GrantedAuthority（已授予的权限）_org.springframework.security.core.grantedauthority-CSDN博客</a></p>
</blockquote>
<p>&#x3D;&#x3D;getAuthorities()方法将返回此用户的所拥有的权限。这个集合将用于用户的访问控制，也就是Authorization。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>所谓权限，就是一个字符串。一般不会重复。</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>所谓权限检查，就是查看用户权限列表中是否含有匹配的字符串。</strong>&#x3D;&#x3D;</p>
<p>之后学习Spring Security</p>
<h5 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h5><p><img src="/../blog_images/dlyk-part2-front-2/image-20240222135527190.png" alt="image-20240222135527190"></p>
<p>这个return按理来说是需要返回一个UserDetails的对象，但是现在是只有一个函数返回的tUser 的对象，所以我们需要去TUser.java处去实现这个接口。如下图所示：</p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222135713974.png" alt="image-20240222135713974"></p>
<p>注意，在UserDetails这个接口中存在7个方法，所以我们需要在TUser中把这7个方法全部都实现了。</p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222135807457.png" alt="image-20240222135807457"></p>
<p>在TUser.java处 快捷键alt+insert，把所有的接口函数导入一下</p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222140250334.png" alt="image-20240222140250334"></p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222140327393.png" alt="image-20240222140327393"></p>
<h5 id="2-编写实现"><a href="#2-编写实现" class="headerlink" title="2. 编写实现"></a>2. 编写实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    *********************************实现UserDetails的七个方法**************************************************</span></span><br><span class="line"><span class="comment">//    这个是角色list</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissionList;</span><br><span class="line"><span class="comment">//    权限标识符list</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; roleList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line"><span class="comment">//        先定义一个list 用来返回得到的角色对象</span></span><br><span class="line">        List&lt;GrantedAuthority&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得角色list,forEach遍历，遍历得到list的每个对象是role，然后将这个role add到list中</span></span><br><span class="line">        <span class="built_in">this</span>.getRoleList().forEach(role -&gt;&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(role));</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//获得权限标识符</span></span><br><span class="line">        <span class="built_in">this</span>.getPermissionList().forEach(permission -&gt;&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(permission));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        这个是账号有无过期，这是这个项目的数据库表的设计 ，数据库里个字段，保证可行就是没有过期</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAccountNoExpired()==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAccountNoLocked()==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getCredentialsNoExpired()==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAccountEnabled()==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-生成jwt-，忽略，全部-JsonIgnore"><a href="#3-生成jwt-，忽略，全部-JsonIgnore" class="headerlink" title="3.生成jwt ，忽略，全部+@JsonIgnore"></a>3.生成jwt ，忽略，全部+@JsonIgnore</h5><p><img src="/../blog_images/dlyk-part2-front-2/image-20240222142026445.png" alt="image-20240222142026445"></p>
<p>不把返回值字段当成js字段</p>
<h5 id="4-完成-到UserServiceImpl-java处，return-tUser"><a href="#4-完成-到UserServiceImpl-java处，return-tUser" class="headerlink" title="4.完成 到UserServiceImpl.java处，return tUser"></a>4.完成 到UserServiceImpl.java处，return tUser</h5><h5 id="5-写一个配置类"><a href="#5-写一个配置类" class="headerlink" title="5.写一个配置类"></a>5.写一个配置类</h5><p><img src="/../blog_images/dlyk-part2-front-2/image-20240222142430458.png" alt="image-20240222142430458"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity httpSecurity, CorsConfigurationSource configurationSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//禁用跨站请求伪造</span></span><br><span class="line">        <span class="keyword">return</span> httpSecurity</span><br><span class="line"><span class="comment">//                链式编程，这边是要做一个登录</span></span><br><span class="line">                .formLogin( (formLogin) -&gt; &#123;</span><br><span class="line">                    formLogin.loginProcessingUrl(Constants.LOGIN_URI) <span class="comment">//登录处理地址，不需要写Controller</span></span><br><span class="line">                            .usernameParameter(<span class="string">&quot;loginAct&quot;</span>)</span><br><span class="line">                            .passwordParameter(<span class="string">&quot;loginPwd&quot;</span>)</span><br><span class="line"><span class="comment">//                            以上是登录，如果登录成功了，就要返回一个结果</span></span><br><span class="line">                            .successHandler(myAuthenticationSuccessHandler)</span><br><span class="line"><span class="comment">//                            如果失败了也要返回结果</span></span><br><span class="line">                            .failureHandler(myAuthenticationFailureHandler);</span><br><span class="line">                &#125;)</span><br><span class="line"><span class="comment">//                以上的handle是直接用的别的，之后如需要详细了解，再研究</span></span><br><span class="line"><span class="comment">//需要对于请求拦截</span></span><br><span class="line">                .authorizeHttpRequests( (authorize) -&gt; &#123;</span><br><span class="line">                    authorize.requestMatchers(<span class="string">&quot;/api/login&quot;</span>).permitAll()</span><br><span class="line">                            .anyRequest().authenticated(); <span class="comment">//其它任何请求都需要登录后才能访问</span></span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;里面用到了一些handler的一些文件，直接用的，需要进一步学习&#x3D;&#x3D;</p>
<p>因为用到了这些，所以需要注入一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> MyAuthenticationFailureHandler myAuthenticationFailureHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> MyLogoutSuccessHandler myLogoutSuccessHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> MyAccessDeniedHandler myAccessDeniedHandler;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为是外面复制进来的，所以需要改写一下：</p>
<p>（在com.bjpowernode目录下创建package util，在里面加入JSONUtils工具类、ResponseUtils。）</p>
<p><strong>MyAuthenticationSuccessHandler</strong>：</p>
<blockquote>
<p>就是成功后需要做什么事情</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class MyAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;</span><br><span class="line">        //通过request、response，得到authentication 登录成功后的用户信息</span><br><span class="line">        // 登录成功，执行该方法，在该方法中返回json给前端，就行了</span><br><span class="line">        TUser tUser = (TUser) authentication.getPrincipal();</span><br><span class="line"></span><br><span class="line">        //登录成功，用户信息返回前台</span><br><span class="line">        R result = R.OK(tUser);</span><br><span class="line"></span><br><span class="line">        //把R对象转成json</span><br><span class="line">        String resultJSON = JSONUtils.toJSON(result);</span><br><span class="line"></span><br><span class="line">        //把R以json返回给前端</span><br><span class="line">        ResponseUtils.write(response, resultJSON);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-完成最简单的实现"><a href="#6-完成最简单的实现" class="headerlink" title="6.完成最简单的实现"></a>6.完成最简单的实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">securityFilterChain</span><span class="params">(HttpSecurity httpSecurity, CorsConfigurationSource configurationSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//禁用跨站请求伪造</span></span><br><span class="line">        <span class="keyword">return</span> httpSecurity</span><br><span class="line"><span class="comment">//                链式编程，这边是要做一个登录</span></span><br><span class="line">                .formLogin( (formLogin) -&gt; &#123;</span><br><span class="line">                    formLogin.loginProcessingUrl(<span class="string">&quot;/api/login&quot;</span>) <span class="comment">//登录处理地址，不需要写Controller</span></span><br><span class="line">                            .usernameParameter(<span class="string">&quot;loginAct&quot;</span>)</span><br><span class="line">                            .passwordParameter(<span class="string">&quot;loginPwd&quot;</span>)</span><br><span class="line"><span class="comment">//                            以上是登录，如果登录成功了，就要返回一个结果</span></span><br><span class="line">                            .successHandler(myAuthenticationSuccessHandler)</span><br><span class="line"><span class="comment">//                            如果失败了也要返回结果</span></span><br><span class="line">                            .failureHandler(myAuthenticationFailureHandler);</span><br><span class="line">                &#125;)</span><br><span class="line"><span class="comment">//                以上的handle是直接用的别的，之后如需要详细了解，再研究</span></span><br><span class="line"><span class="comment">//需要对于请求拦截</span></span><br><span class="line">                .authorizeHttpRequests( (authorize) -&gt; &#123;</span><br><span class="line">                    authorize.requestMatchers(<span class="string">&quot;/api/login&quot;</span>).permitAll()</span><br><span class="line">                            .anyRequest().authenticated(); <span class="comment">//其它任何请求都需要登录后才能访问</span></span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-用Apifox验证是否成功"><a href="#7-用Apifox验证是否成功" class="headerlink" title="7.用Apifox验证是否成功"></a>7.用Apifox验证是否成功</h5><p> 使用网页版，如下操作</p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222152059742.png" alt="image-20240222152059742"></p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222152137062.png" alt="image-20240222152137062"></p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222152456724.png" alt="image-20240222152456724"></p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222152604580.png" alt="image-20240222152604580"></p>
<p>最后选择开发环境</p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222152626036.png" alt="image-20240222152626036"></p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222154805491.png" alt="image-20240222154805491"></p>
<h5 id="8-一些错误需要修改"><a href="#8-一些错误需要修改" class="headerlink" title="8. 一些错误需要修改"></a>8. 一些错误需要修改</h5><h6 id="a-密码加密了。所以需要注入一个-SecurityConfig"><a href="#a-密码加密了。所以需要注入一个-SecurityConfig" class="headerlink" title="a.密码加密了。所以需要注入一个&#x2F;&#x2F;SecurityConfig"></a>a.密码加密了。所以需要注入一个&#x2F;&#x2F;SecurityConfig</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//There is no PasswordEncoder mapped for the id &quot;null&quot;</span></span><br><span class="line"><span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>细的需要再学习一下java se—</p>
<h6 id="b-需要排除一下list为空的问题-TUser-java"><a href="#b-需要排除一下list为空的问题-TUser-java" class="headerlink" title="b. 需要排除一下list为空的问题&#x2F;&#x2F;TUser.java"></a>b. 需要排除一下list为空的问题&#x2F;&#x2F;TUser.java</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line"><span class="comment">//        先定义一个list 用来返回得到的角色对象</span></span><br><span class="line">        List&lt;GrantedAuthority&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得角色list,forEach遍历，遍历得到list的每个对象是role，然后将这个role add到list中</span></span><br><span class="line">        <span class="keyword">if</span>(!ObjectUtils.isEmpty(<span class="built_in">this</span>.getRoleList()))&#123;</span><br><span class="line">            <span class="built_in">this</span>.getRoleList().forEach(role -&gt;&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(role));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得权限标识符</span></span><br><span class="line">        <span class="keyword">if</span>(!ObjectUtils.isEmpty(<span class="built_in">this</span>.getPermissionList()))&#123;</span><br><span class="line">            <span class="built_in">this</span>.getPermissionList().forEach(permission -&gt;&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(permission));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-前后端联通–-解决跨域问题"><a href="#9-前后端联通–-解决跨域问题" class="headerlink" title="9.前后端联通–&gt;解决跨域问题"></a>9.前后端联通–&gt;解决跨域问题</h5><p><img src="/../blog_images/dlyk-part2-front-2/image-20240222203338737.png" alt="image-20240222203338737"></p>
<p>此时启动前后端系统，输入账号密码会出现这个错误，这个cors错误叫做跨域错误 </p>
<blockquote>
<p>跨域报错：Access to XMLHttpRequest at ‘<a href="http://localhost:8089/api/login">http://localhost:8089/api/login</a>‘ from origin ‘<a href="http://localhost:8081/">http://localhost:8081</a>‘ has been blocked by CORS policy；</p>
<p>跨域：</p>
<p>源头：<a href="http://localhost:8081/">http://localhost:8081</a> 目的地：<a href="http://localhost:8080/api">http://localhost:8089/api</a>&#x2F;login</p>
<p>1、协议不同， <a href="http://localhost:8080/">http://localhost:8080</a>   <a href="http://localhost:8080/">https://localhost:8080</a></p>
<p>2、域名不同， <a href="http://localhost:8080/">http://localhost:8080</a>   <a href="http://localhost:8080/">http://dlyk.bjpowernode.com:8080</a></p>
<p>3、端口不同  <a href="http://localhost:8080/">http://localhost:8080</a>   <a href="http://localhost:8080/">http://localhost:8082</a></p>
<p>三个里面只要有任何一个不同就是跨域；</p>
</blockquote>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222203608653.png" alt="image-20240222203608653"></p>
<p><strong>&#x3D;&#x3D;如何解决！&#x3D;&#x3D;</strong></p>
<p>在<img src="/../blog_images/dlyk-part2-front-2/image-20240222203942321.png" alt="image-20240222203942321"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">securityFilterChain这个函数里面</span><br><span class="line">//支持跨域请求</span><br><span class="line">.cors( (cors) -&gt; &#123;</span><br><span class="line">    cors.configurationSource(configurationSource);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CorsConfigurationSource <span class="title function_">configurationSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">    configuration.setAllowedOrigins(Arrays.asList(<span class="string">&quot;*&quot;</span>)); <span class="comment">//允许任何来源，http://localhost:8081</span></span><br><span class="line">    configuration.setAllowedMethods(Arrays.asList(<span class="string">&quot;*&quot;</span>)); <span class="comment">//允许任何请求方法，post、get、put、delete</span></span><br><span class="line">    configuration.setAllowedHeaders(Arrays.asList(<span class="string">&quot;*&quot;</span>)); <span class="comment">//允许任何的请求头</span></span><br><span class="line"></span><br><span class="line">    <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, configuration);</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>ctrl+h 看接口的几个实现</p>
<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222204459230.png" alt="image-20240222204459230"></p>
<h5 id="10-axios请求后返回的响应对象"><a href="#10-axios请求后返回的响应对象" class="headerlink" title="10.axios请求后返回的响应对象"></a>10.axios请求后返回的响应对象</h5><p><img src="/../blog_images/dlyk-part2-front-2/image-20240222205748168.png" alt="image-20240222205748168"></p>
<p> 其中data就是后端springboot响应返回的那个R对象；</p>
<h4 id="11-修改前端接到后端返回数据后的操作"><a href="#11-修改前端接到后端返回数据后的操作" class="headerlink" title="11.修改前端接到后端返回数据后的操作"></a>11.修改前端接到后端返回数据后的操作</h4><h6 id="a-创建返回的util-因为后续可能很多地方都需要使用"><a href="#a-创建返回的util-因为后续可能很多地方都需要使用" class="headerlink" title="a.创建返回的util&#x2F;&#x2F;因为后续可能很多地方都需要使用"></a>a.创建返回的util&#x2F;&#x2F;因为后续可能很多地方都需要使用</h6><p><img src="/../blog_images/dlyk-part2-front-2/image-20240222210454177.png" alt="image-20240222210454177"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">messageTip</span>(<span class="params">msg, type</span>) &#123;</span><br><span class="line">    <span class="title class_">ElMessage</span>(&#123;</span><br><span class="line">        <span class="attr">showClose</span>: <span class="literal">true</span>, <span class="comment">//是否显示关闭按钮</span></span><br><span class="line">        <span class="attr">center</span>: <span class="literal">true</span>, <span class="comment">//文字是否居中</span></span><br><span class="line">        <span class="attr">duration</span>: <span class="number">3000</span>, <span class="comment">//显示时间，单位为毫秒</span></span><br><span class="line">        <span class="attr">message</span>: msg, <span class="comment">//提示的消息内容</span></span><br><span class="line">        <span class="attr">type</span>: type, <span class="comment">//消息类型：&#x27;success&#x27; | &#x27;warning&#x27; | &#x27;info&#x27; | &#x27;error&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="b-修改登录成功后返回的消息"><a href="#b-修改登录成功后返回的消息" class="headerlink" title="b.修改登录成功后返回的消息"></a>b.修改登录成功后返回的消息</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//这个是loginvView.vue</span><br><span class="line">//比如一些消息提醒等</span><br><span class="line">methods: &#123;</span><br><span class="line">  //登录函数</span><br><span class="line">  login() &#123;</span><br><span class="line">    //提交前验证输入框的合法性</span><br><span class="line">    this.$refs.loginRefForm.validate( (isValid) =&gt; &#123;</span><br><span class="line">      //isValid是验证后的结果，如果是true表示验证通过，否则未通过</span><br><span class="line">      if (isValid) &#123;</span><br><span class="line">        //验证通过，可以提交登录</span><br><span class="line">        //这是个js对象，可用来传输数据，用键值对传输对象</span><br><span class="line">        let formData = new FormData();</span><br><span class="line">        formData.append(&quot;loginAct&quot;, this.user.loginAct);</span><br><span class="line">        formData.append(&quot;loginPwd&quot;, this.user.loginPwd);</span><br><span class="line">        formData.append(&quot;rememberMe&quot;, this.user.rememberMe);</span><br><span class="line"></span><br><span class="line">        doPost(&quot;/api/login&quot;, formData).then( (resp) =&gt; &#123;</span><br><span class="line">          //用了==&gt;才能使用this这个变量</span><br><span class="line">          console.log(resp);</span><br><span class="line">          if (resp.data.code === 200) &#123;</span><br><span class="line">            //登录成功，提示一下</span><br><span class="line">            messageTip(&quot;登录成功&quot;, &quot;success&quot;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            //登录失败，也提示一下</span><br><span class="line">            messageTip(&quot;登录失败&quot;, &quot;error&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  //免登录（自动登录）</span><br><span class="line">  freeLogin() &#123;</span><br><span class="line">    let token = window.localStorage.getItem(getTokenName());</span><br><span class="line">    if (token) &#123; //表示token有值，token不是空，token存在</span><br><span class="line">      doGet(&quot;/api/login/free&quot;, &#123;&#125;).then(resp =&gt; &#123;</span><br><span class="line">        if (resp.data.code === 200)  &#123;</span><br><span class="line">          //token验证通过了，那么可以免登录</span><br><span class="line">          window.location.href = &quot;/dashboard&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-登录成功后跳转系统的主页面"><a href="#12-登录成功后跳转系统的主页面" class="headerlink" title="12.登录成功后跳转系统的主页面"></a>12.登录成功后跳转系统的主页面</h4><h5 id="a-跳转页面"><a href="#a-跳转页面" class="headerlink" title="a.跳转页面"></a>a.跳转页面</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.location.href = &quot;/dashboard&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222211409570.png" alt="image-20240222211409570"></p>
<h5 id="b-添加路由"><a href="#b-添加路由" class="headerlink" title="b.添加路由"></a>b.添加路由</h5><p>路由：就是vue访问的路径；</p>
<p>比如: &#x2F;</p>
<p>比如：&#x2F;dashboard</p>
<p>1、用npm命令安装路由</p>
<p>npm install vue-router –save</p>
<p>2、在src下面新建一个router文件夹，在router文件夹下新建一个router.js文件，在router.js文件里面写入以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从vue-router这个依赖库中导入createRouter()函数, createWebHistory()函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="comment">//定义一个变量</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="comment">//路由的历史，可以实现一些前进后退</span></span><br><span class="line">    <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line">    <span class="comment">//p配置路由，里面可以配置多个路由，</span></span><br><span class="line">    <span class="comment">//路由就是vue访问的路径</span></span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//路由的路径</span></span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="comment">//路由路径所对应的页面</span></span><br><span class="line">            component : <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../view/LoginView.vue&#x27;</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/dashboard&#x27;</span>,</span><br><span class="line">            <span class="comment">//路由路径所对应的页面</span></span><br><span class="line">            component : <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../view/dashboard.vue&#x27;</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//这个是导出路由，导出之后才能用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222212744356.png" alt="image-20240222212744356"></p>
<h5 id="c-在使用路由时导入路由："><a href="#c-在使用路由时导入路由：" class="headerlink" title="c. 在使用路由时导入路由："></a>c. 在使用路由时导入路由：</h5><p>在main.js中导入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router from <span class="string">&#x27;./router/router.js&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="d-在main-js中使用路由"><a href="#d-在main-js中使用路由" class="headerlink" title="d.在main.js中使用路由"></a>d.在main.js中使用路由</h5><p>app.use(router);</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span><span class="comment">//createApp这个是一个函数</span></span><br><span class="line"><span class="comment">//import &#x27;./style.css&#x27;</span></span><br><span class="line"><span class="comment">//import App from &#x27;./App.vue&#x27;//从一个单文件组件中导入根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"><span class="comment">//从router.js导入组件</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/router.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> loginView <span class="keyword">from</span> <span class="string">&quot;./view/LoginView.vue&quot;</span>;</span><br><span class="line"><span class="title function_">createApp</span>(loginView).<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>).<span class="title function_">use</span>(router).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)<span class="comment">//创建一个vue对象//挂载到页面的#app这个id下</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="e-使用标签渲染路由地址所对应的页面组件；"><a href="#e-使用标签渲染路由地址所对应的页面组件；" class="headerlink" title="e. 使用&lt;router-view&#x2F;&gt;标签渲染路由地址所对应的页面组件；"></a>e. 使用&lt;router-view&#x2F;&gt;标签渲染路由地址所对应的页面组件；</h5><p>和上面的区别是导入了App ，且createApp(App)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span><span class="comment">//createApp这个是一个函数</span></span><br><span class="line"><span class="comment">//import &#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span><span class="comment">//从一个单文件组件中导入根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"><span class="comment">//从router.js导入组件</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/router.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> loginView <span class="keyword">from</span> <span class="string">&quot;./view/LoginView.vue&quot;</span>;</span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>).<span class="title function_">use</span>(router).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)<span class="comment">//创建一个vue对象//挂载到页面的#app这个id下</span></span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/dlyk-part2-front-2/image-20240222213354364.png" alt="image-20240222213354364"></p>
<p>如果访问&#x2F;. ，那么就渲染LoginView.vue,如果是&#x2F;dashBoard，那么就渲染dashboard.vue</p>
]]></content>
      <categories>
        <category>Java项目</category>
        <category>动力云客</category>
      </categories>
  </entry>
  <entry>
    <title>dlyk-part3</title>
    <url>/2024/02/22/dlyk-part3/</url>
    <content><![CDATA[<h1 id="一、创建DashboardView-vue界面"><a href="#一、创建DashboardView-vue界面" class="headerlink" title="一、创建DashboardView.vue界面"></a>一、创建DashboardView.vue界面</h1><p> 这个我没有全听，就是复制过来了，大致理解了 p28-29</p>
<h2 id="1-布局"><a href="#1-布局" class="headerlink" title="1. 布局"></a>1. 布局</h2><h2 id="2-菜单制作"><a href="#2-菜单制作" class="headerlink" title="2.菜单制作"></a>2.菜单制作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-menu</span><br><span class="line">    active-text-color=&quot;#ffd04b&quot;</span><br><span class="line">    background-color=&quot;#334157&quot;</span><br><span class="line">    class=&quot;el-menu-vertical-demo&quot;</span><br><span class="line">    :default-active=&quot;currentRouterPath&quot;</span><br><span class="line">    text-color=&quot;#fff&quot;</span><br><span class="line">    style=&quot;border-right: solid 0px;&quot;</span><br><span class="line">    :collapse=&quot;isCollapse&quot;</span><br><span class="line">    :collapse-transition=&quot;false&quot;</span><br><span class="line">    :router=&quot;true&quot;</span><br><span class="line">    :unique-opened=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;el-sub-menu :index=&quot;index&quot; v-for=&quot;(menuPermission, index) in user.menuPermissionList&quot; :key=&quot;menuPermission.id&quot;&gt;</span><br><span class="line">    &lt;template #title&gt;</span><br><span class="line">      &lt;el-icon&gt;&lt;component :is=&quot;menuPermission.icon&quot;&gt;&lt;/component&gt;&lt;/el-icon&gt;</span><br><span class="line">      &lt;span&gt; &#123;&#123;menuPermission.name&#125;&#125; &lt;/span&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;el-menu-item v-for=&quot;subPermission in menuPermission.subPermissionList&quot; :key=&quot;subPermission.id&quot; :index=&quot;subPermission.url&quot;&gt;</span><br><span class="line">      &lt;el-icon&gt;&lt;component :is=&quot;subPermission.icon&quot;&gt;&lt;/component&gt;&lt;/el-icon&gt;</span><br><span class="line">      &#123;&#123;subPermission.name&#125;&#125;</span><br><span class="line">    &lt;/el-menu-item&gt;</span><br><span class="line">  &lt;/el-sub-menu&gt;</span><br><span class="line">&lt;/el-menu&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3-菜单加入图标-美观"><a href="#3-菜单加入图标-美观" class="headerlink" title="3.菜单加入图标&#x2F;美观"></a>3.菜单加入图标&#x2F;美观</h2><h3 id="（1）-安装图标"><a href="#（1）-安装图标" class="headerlink" title="（1） 安装图标"></a>（1） 安装图标</h3><p>npm install @element-plus&#x2F;icons-vue –save</p>
<h3 id="（2）注册所有图标，在main-js中注册："><a href="#（2）注册所有图标，在main-js中注册：" class="headerlink" title="（2）注册所有图标，在main.js中注册："></a>（2）注册所有图标，在main.js中注册：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span><span class="comment">//createApp这个是一个函数</span></span><br><span class="line"><span class="comment">//import &#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span><span class="comment">//从一个单文件组件中导入根组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"><span class="comment">//从router.js导入组件</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/router.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ElementPlusIconsVue</span> <span class="keyword">from</span> <span class="string">&#x27;@element-plus/icons-vue&#x27;</span></span><br><span class="line"><span class="comment">//在这里先创建了，然后再后续的操作</span></span><br><span class="line"><span class="keyword">let</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, component] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(<span class="title class_">ElementPlusIconsVue</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    app.<span class="title function_">component</span>(key, component)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> loginView <span class="keyword">from</span> <span class="string">&quot;./view/LoginView.vue&quot;</span>;</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>).<span class="title function_">use</span>(router).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)<span class="comment">//创建一个vue对象//挂载到页面的#app这个id下</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（3）使用图标，复制图标的代码，粘贴到项目中即可；"><a href="#（3）使用图标，复制图标的代码，粘贴到项目中即可；" class="headerlink" title="（3）使用图标，复制图标的代码，粘贴到项目中即可；"></a>（3）使用图标，复制图标的代码，粘贴到项目中即可；</h3><blockquote>
<p><a href="https://element-plus.gitee.io/zh-CN/component/icon.html#icon-collection">Icon 图标 | Element Plus (gitee.io)</a></p>
</blockquote>
<p><el-icon><Plus /></el-icon></p>
<p><el-icon><Minus /></el-icon></p>
<p><el-icon><CirclePlus /></el-icon></p>
<p>Vue中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$refs 拿到页面上ref属性的那个dom元素；</span><br><span class="line"></span><br><span class="line">$router vue路由对象，里面提供了一些方法供什么使用；</span><br></pre></td></tr></table></figure>

<p><img src="/../blog_images/dlyk-part3/image-20240222220629465.png" alt="image-20240222220629465"></p>
<h3 id="（4）添加图标的动作"><a href="#（4）添加图标的动作" class="headerlink" title="（4）添加图标的动作"></a>（4）添加图标的动作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;el-icon <span class="keyword">class</span>=<span class="string">&quot;show&quot;</span> @click=<span class="string">&quot;showMenu&quot;</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">Fold</span> /&gt;</span></span>&lt;/el-icon&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods : &#123;</span><br><span class="line">  <span class="comment">//左侧菜单左右展开和折叠</span></span><br><span class="line">  <span class="title function_">showMenu</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isCollapse</span> = !<span class="variable language_">this</span>.<span class="property">isCollapse</span>;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>isCollapse定义</p>
<p><img src="/../blog_images/dlyk-part3/image-20240222221224747.png" alt="image-20240222221224747"></p>
<p>设置变量：</p>
<p><img src="/../blog_images/dlyk-part3/image-20240222221302322.png" alt="image-20240222221302322"></p>
<p>调整宽度</p>
<p><img src="/../blog_images/dlyk-part3/image-20240222221350959.png" alt="image-20240222221350959"></p>
<h2 id="4-加入下拉菜单、vue函数钩子"><a href="#4-加入下拉菜单、vue函数钩子" class="headerlink" title="4.加入下拉菜单、vue函数钩子"></a>4.加入下拉菜单、vue函数钩子</h2><blockquote>
<p>函数钩子:就是在渲染页面的时候，就把用户的名字等信息获得到，然后再渲染到页面当中去</p>
</blockquote>
<h3 id="（1）写script"><a href="#（1）写script" class="headerlink" title="（1）写script"></a>（1）写script</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写script</span><br><span class="line">//vue的生命周期中的一个函数钩子，该钩子是在页面渲染后执行</span><br><span class="line">mounted() &#123;</span><br><span class="line">  //加载当前登录用户</span><br><span class="line">  this.loadLoginUser();</span><br><span class="line">  this.loadCurrentRouterPath();</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="（2）写templete-显示"><a href="#（2）写templete-显示" class="headerlink" title="（2）写templete 显示"></a>（2）写templete 显示</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">写templete 显示</span><br><span class="line">&lt;!--右侧：上--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">el-header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">el-icon</span> <span class="attr">class</span>=<span class="string">&quot;show&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;showMenu&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">Fold</span> /&gt;</span><span class="tag">&lt;/<span class="name">el-icon</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">el-dropdown</span> <span class="attr">:hide-on-click</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;el-dropdown-link&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; user.name &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-icon</span> <span class="attr">class</span>=<span class="string">&quot;el-icon--right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">arrow-down</span> /&gt;</span><span class="tag">&lt;/<span class="name">el-icon</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">dropdown</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">el-dropdown-menu</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">el-dropdown-item</span>&gt;</span>我的资料<span class="tag">&lt;/<span class="name">el-dropdown-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">el-dropdown-item</span>&gt;</span>修改密码<span class="tag">&lt;/<span class="name">el-dropdown-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">el-dropdown-item</span> <span class="attr">divided</span> @<span class="attr">click</span>=<span class="string">&quot;logout&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">el-dropdown-item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">el-dropdown-menu</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">el-dropdown</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">el-header</span>&gt;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="（3）写方法"><a href="#（3）写方法" class="headerlink" title="（3）写方法"></a>（3）写方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">写方法！</span><br><span class="line">methods : &#123;</span><br><span class="line">  <span class="comment">//左侧菜单左右展开和折叠</span></span><br><span class="line">  <span class="title function_">showMenu</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">isCollapse</span> = !<span class="variable language_">this</span>.<span class="property">isCollapse</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//加载当前登录用户</span></span><br><span class="line">  <span class="title function_">loadLoginUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="title function_">doGet</span>(<span class="string">&quot;/api/login/info&quot;</span>, &#123;&#125;).<span class="title function_">then</span>( <span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(resp)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">user</span> = resp.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//退出登录</span></span><br><span class="line">  <span class="title function_">logout</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">doGet</span>(<span class="string">&quot;/api/logout&quot;</span>, &#123;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (resp.<span class="property">data</span>.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">removeToken</span>();</span><br><span class="line">        <span class="title function_">messageTip</span>(<span class="string">&quot;退出成功&quot;</span>, <span class="string">&quot;success&quot;</span>);</span><br><span class="line">        <span class="comment">//跳到登录页</span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">messageConfirm</span>(<span class="string">&quot;退出异常，是否要强制退出？&quot;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//用户点击“确定”按钮就会触发then函数</span></span><br><span class="line">          <span class="comment">//既然后端验证token未通过，那么前端的token肯定是有问题的，那没必要存储在浏览器中，直接删除一下</span></span><br><span class="line">          <span class="title function_">removeToken</span>();</span><br><span class="line">          <span class="comment">//跳到登录页</span></span><br><span class="line">          <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">//用户点击“取消”按钮就会触发then函数</span></span><br><span class="line">          <span class="title function_">messageTip</span>(<span class="string">&quot;取消强制退出&quot;</span>, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//加载当前路由路径</span></span><br><span class="line">  <span class="title function_">loadCurrentRouterPath</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> path = <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">path</span>; <span class="comment">//   /dashboard/activity/add</span></span><br><span class="line">    <span class="keyword">let</span> arr = path.<span class="title function_">split</span>(<span class="string">&quot;/&quot;</span>); <span class="comment">//   [  ,dashboard, activity, add]</span></span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &gt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentRouterPath</span> = <span class="string">&quot;/&quot;</span> + arr[<span class="number">1</span>] + <span class="string">&quot;/&quot;</span> + arr[<span class="number">2</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">currentRouterPath</span> = path;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>   &#x3D;&#x3D;<strong>下面这个调用的就是httpRequest.js里面的doGet的axios</strong>&#x3D;&#x3D;   </p>
<pre><code>doGet(&quot;/api/login/info&quot;, &#123;&#125;).then( (resp) =&gt; &#123;
  console.log(resp)
  this.user = resp.data.data;
&#125;)
</code></pre>
<p>  ！！**&#x3D;&#x3D;因此要写后端的接口&#x3D;&#x3D;**，UserController</p>
<h2 id="5-获取登录人信息后端代码实现"><a href="#5-获取登录人信息后端代码实现" class="headerlink" title="5.获取登录人信息后端代码实现"></a>5.获取登录人信息后端代码实现</h2><img src="../blog_images/dlyk-part3/image-20240222222945744.png" alt="image-20240222222945744" style="zoom:50%;" />

<img src="../blog_images/dlyk-part3/image-20240222223051935.png" alt="image-20240222223051935" style="zoom:50%;" />

<h3 id="（1）编写UserController-java"><a href="#（1）编写UserController-java" class="headerlink" title="（1）编写UserController.java"></a>（1）编写UserController.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserController.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.bjpowernode.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.bjpowernode.model.TUser;</span><br><span class="line"><span class="keyword">import</span> com.bjpowernode.result.CodeEnum;</span><br><span class="line"><span class="keyword">import</span> com.bjpowernode.result.R;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    因为是查询请求 所以写getmapping</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/api/login/info&quot;)</span></span><br><span class="line"><span class="comment">//    登录后的用户信息怎么拿？</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">loginInfo</span><span class="params">(Authentication authentication)</span>&#123;</span><br><span class="line">        <span class="type">TUser</span> <span class="variable">tUser</span> <span class="operator">=</span> (TUser)authentication.getPrincipal() ;</span><br><span class="line">        <span class="keyword">return</span> R.OK(tUser);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        public static R OK(Object data) &#123;</span></span><br><span class="line"><span class="comment">//            return R.builder()</span></span><br><span class="line"><span class="comment">//                    .code(CodeEnum.OK.getCode())</span></span><br><span class="line"><span class="comment">//                    .msg(CodeEnum.OK.getMsg())</span></span><br><span class="line"><span class="comment">//                    .data(data)</span></span><br><span class="line"><span class="comment">//                    .build();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）apifox测试成功"><a href="#（2）apifox测试成功" class="headerlink" title="（2）apifox测试成功"></a>（2）apifox测试成功</h3><p><img src="/../blog_images/dlyk-part3/image-20240222224207981.png" alt="image-20240222224207981"></p>
<h3 id="（3）前台调用测试"><a href="#（3）前台调用测试" class="headerlink" title="（3）前台调用测试"></a>（3）前台调用测试</h3><p>没改 嗯，不一定能成</p>
<h1 id="二、用JWT替换sessionP36"><a href="#二、用JWT替换sessionP36" class="headerlink" title="二、用JWT替换sessionP36"></a>二、用JWT替换sessionP36</h1>]]></content>
      <tags>
        <tag>Java项目</tag>
        <tag>动力云客</tag>
      </tags>
  </entry>
</search>
